# 8.Java 本地接口

在本章中，您将学习

*   什么是 Java 本地接口(JNI)
*   如何编写使用本地方法的 Java 程序
*   如何编写 C++程序来实现本机方法
*   如何在 Windows 和 Linux 上为 Java 中使用的方法的本地实现创建一个共享库
*   Java 类型和 JNI 类型之间的数据类型映射
*   如何在本机代码中使用 Java 字符串和数组
*   如何创建 Java 对象，并在本机代码中访问这些对象的字段和方法
*   本机代码中的异常处理
*   如何在本机代码中嵌入 JVM
*   如何在本机代码中使用 JNI 处理线程同步

## 什么是 Java 原生接口？

Java 本地接口(Java Native Interface，JNI)是一种编程接口，它有助于 Java 代码与用 C、C++、FORTRAN 等本地语言编写的代码之间的交互。JNI 支持直接从 Java 调用 C 和 C++函数。如果需要使用用任何其他语言(如 FORTRAN)编写的本机代码，可以使用 C/C++包装函数从 Java 中调用它。互动可以双向进行。Java 代码可以调用本机代码，反之亦然，如图 [8-1](#Fig1) 所示。

![A978-1-4302-6662-4_8_Fig1_HTML.jpg](img/A978-1-4302-6662-4_8_Fig1_HTML.jpg)

图 8-1。

The JNI architecture

Java 使用本机方法调用本机代码。Java 上下文中的本地方法是用 Java 声明并以本地语言(如 C/C++)实现的方法。本机方法实现被编译成一个共享库，由 JVM 加载。共享库在 Windows 上称为动态链接库(DLL ),在 UNIX 上称为共享对象(SO)。在 Java 代码中，以同样的方式调用 Java 方法和本机方法。Java 程序被编译成一种与平台无关的格式，称为字节码。本机代码被编译成依赖于平台的格式。因此，如果一个 Java 应用程序使用本机代码，它就不能再移植到其他平台，除非您在所有平台上开发相同的共享库。有时，您可能会访问本机代码中特定于平台的特性，这些特性是从 Java 应用程序中使用的；在这种情况下，您应该知道您的 Java 应用程序不能在其他平台上运行。

当 Java 通过其类库提供了丰富的特性时，为什么还会有人使用 JNI 呢？出于以下原因，可能有必要使用 JNI 来访问 Java 中的本机代码:

*   如果一个 Java 应用程序需要实现一些特定于平台的特性，而这些特性使用 Java APIs 是不可能实现的。
*   您可能已经有了用本地语言编写的遗留代码，并且希望在 Java 应用程序中重用它。
*   您正在开发一个时间关键的 Java 应用程序，其中 Java 代码的执行速度没有预期的快。您可以将 Java 代码中时间关键的部分转移到本机代码中。

您应该考虑在 Java 应用程序中使用 JNI 作为最后的手段。您必须探索使用 Java APIs 实现所需特性的所有可能性。使用 JNI 还会改变开发应用程序所需的技能。从事 Java 应用程序开发的开发人员要么接受本地语言(C/C++)的培训，要么让懂本地语言的新开发人员加入团队。在 Java 应用程序中使用本机代码会降低应用程序的稳定性，并且容易出现安全风险，因为本机代码是在 JVM 之外运行的。

在本章中，我将使用 C++来实现本地方法。你可以用 C 语言来代替。本章中列出的所有 C++代码示例只需稍加修改就可以移植到 C 语言中。每当您需要对 C++代码进行更改以将其转换为 C 时，我都会详细说明 C++代码和 C 代码之间的区别。

## 系统需求

你需要一个能创建共享库的 C 或 C++编译器。您还需要在计算机上安装一个 JDK 来生成 C/C++头文件。本章中引用的本机代码是使用 NetBeans 8.0 和 Cygwin 作为 Windows 平台上的 C++编译器开发的。Java 8 用于编译和运行 Java 代码。然而，使用 Cygwin 作为 C++编译器并不是运行任何示例的必要条件。您可以使用任何其他 C/C++编译器在您的平台上创建共享库。请访问 [`https://netbeans.org/kb/trails/cnd.html`](https://netbeans.org/kb/trails/cnd.html) 了解更多关于如何配置 NetBeans 使用 C++的详细信息。

## JNI 入门

开发使用 JNI 的 Java 应用程序包括以下步骤:

*   编写 Java 程序
*   编译 Java 程序
*   创建 C/C++头文件
*   编写 C/C++程序
*   创建共享库
*   运行 Java 程序

后续部分将详细讨论每个步骤。

### 编写 Java 程序

使用 JNI 的 Java 程序与纯 Java 程序的区别仅在于两个方面:

*   加载共享库
*   声明本机方法

包含本机方法实现的共享库必须在 Java 调用本机方法之前加载。使用`java.lang.System`类的`loadLibrary(String libraryNameWithoutExtension)`静态方法加载共享库，如下所示:

`// Load a shared library named beginningjava`

`System.loadLibrary("beginningjava");`

您还可以使用`java.lang.Runtime`类的`loadLibrary()`方法加载共享库。在内部，`System`类的`loadLibrary()`方法调用了`Runtime`类的`loadLibrary()`方法。上述代码可以重写如下:

`// Load the shared library`

`Runtime.getRuntime().loadLibrary("beginningjava");`

注意，您需要向`loadLibrary()`方法传递一个共享库名，不带任何特定于平台的前缀和文件扩展名。例如，如果您的共享库文件名在 Windows 上是`beginningjava.dll`或者在 UNIX 上是`beginningjava.so`，那么您需要使用`beginningjava`作为共享库名。`loadLibrary()`方法将添加文件扩展名来查找共享库。这样，您不需要更改 Java 代码，如果您打算在不同的平台上运行相同的 Java 代码，Java 代码会加载共享库。

你也可以使用`System`或`Runtime`类的`load()`方法加载一个共享库。`load()`方法接受带有文件扩展名的共享库的绝对路径。如果 Windows 平台上的`beginningjava.dll`文件在`C:\myjni`目录中，那么对`load()`方法的调用将如下所示:

`// Load the shared library`

`System.load("C:\\myjni\\beginningjava.dll");`

注意，使用`load()`方法迫使您使用共享库的绝对路径和文件扩展名，这使得您的 Java 代码不可移植到其他平台。在本章的例子中，你将使用`System`类的`loadLibrary()`方法来加载共享库。如果无法加载特定的库，`load()`和`loadLibrary()`方法会抛出一个`java.lang.UnsatisfiedLinkError`。

`loadLibrary()`方法如何在只知道库名的情况下找到文件系统中的共享库文件？有两种方法可以让 JVM 知道共享库的位置:

*   将包含共享库的目录包含到 Windows 上的`PATH`环境变量和 UNIX 上的`LD_LIBRARY_PATH`环境变量中。
*   使用`java.library.path` JVM 属性作为命令行选项，指定包含共享库的目录(或多个目录，用分号分隔)。以下命令假设`beginningjava`共享库位于`C:\myjni\lib`目录中:`java -Djava.library.path=C:\myjni\lib your-class-name-to-run`

Java 中使用的本机方法没有用 Java 编写的主体，因为它的实现存在于本机代码中。但是，在使用本机方法之前，需要用 Java 声明它。它是使用`native`关键字声明的。Java 代码中的`native`方法声明以分号结束。下面的代码片段声明了一个名为`hello()`的`native`方法，它没有参数并返回`void`。

`public class Test {`

`// Declare a native method called hello()`

`public``native`T2】

`}`

用 Java 代码调用本机方法与调用任何其他 Java 方法是一样的。

`Test test = new Test();`

`test.hello();`

您可以声明一个本机方法具有`public`、`private`、`protected`或包级范围。一个`native`方法可以被声明为`static`或非静态的。一个 Java 类中可以有任意多的`native`方法。

不能将`native`方法声明为`abstract`。这意味着一个接口不能有`native`方法，因为在一个接口中声明的所有方法如果没有声明为`static`或`default`，那么它们都是`abstract`。一个`abstract`方法意味着该方法的实现缺失，它将在 Java 中实现，而`native`方法意味着该方法的实现缺失，它在本机代码中实现。将一个方法同时声明为`native`和`abstract`将会混淆在哪里寻找该方法的实现——在 Java 代码中还是在本地代码中。这就是方法声明不能使用两个修饰符`abstract`和`native`组合的原因。

关键字`native`只能用于声明方法。您不能将字段声明为`native`。下面的代码片段声明了两个名为`WillCompile`和`WontCompile`的类。类`WillCompile`包含了`native`关键字的有效用法，而类`WontCompile`展示了`native`关键字的无效用法。

`public class WillCompile {`

`public native void m1();`

`private native void m2();`

`protected native void m3();`

`native void m4();`

`public static native void m5();`

`public native int m6(String str);`

`// A non-native method (Java-only method)`

`public int add(int a, int b) {`

`return a + b;`

`}`

`}`

`// Sample of Illegal use of native keyword in a Java class`

`public class WontCompile {`

`// A field cannot be native`

`private native String name;`

`// A method cannot be abstract as well as native`

`public abstract native String getName();`

`}`

现在，您已经准备好编写 Java 代码来调用您的第一个本机方法。您将把您的`native`方法命名为`hello()`。它不接受任何参数，也不返回任何值。稍后您将在 C++中实现它，它将在标准输出中打印一条消息`Hello JNI`。清单 8-1 给出了`HelloJNI`类的完整代码。

清单 8-1。使用名为 hello()的本机方法的 HelloJNI 类

`// HelloJNI.java`

`package com.jdojo.jni;`

`public class HelloJNI {`

`static {`

`// Load the shared library using its name only`

`System.loadLibrary("beginningjava");`

`}`

`// Declare the native method`

`public native void hello();`

`public static void main(String[] args) {`

`// Create a HelloJNI object`

`HelloJNI helloJNI = new HelloJNI();`

`// Call the native method`

`helloJNI.hello();`

`}`

`}`

`HelloJNI`类执行三件事情:

*   它在静态初始化器中加载一个`beginningjava`共享库(Windows 上的`beginningjava.dll`和类 UNIX 操作系统上的`beginningjava.so`)。注意，当你编写和编译`HelloJNI`类时，你不需要有`beginningjava`共享库。运行`HelloJNI`类时需要共享库。`static {` `System.loadLibrary("beginningjava ");` `}`
*   它声明了一个名为`hello()`的`native`方法，稍后将在 C++代码中实现。`public native void hello();`Java 编译器会用`hello() native`方法声明编译`HelloJNI`类，而不需要实现该方法的本机代码。在运行时调用该方法时，将需要该方法的实现。
*   它在`main()`方法中创建了一个`HelloJNI`类的对象，并对该对象调用了`hello()`方法。`HelloJNI helloJNI = new HelloJNI();` `helloJNI.hello();`

`HelloJNI`类的代码很简单。使用`native`方法并不需要在 Java 代码中做什么特别的事情。您还不能运行这个类，因为当您运行它的时候，它会寻找一个包含`hello()`方法本机代码的`beginningjava`共享库，您还没有编写这个库。

### 编译 Java 程序

编译使用本机方法的 Java 程序与编译任何其他 Java 程序是一样的。在编译`HelloJNI`类时，没有什么特殊的设置需要应用。您可以使用`javac`命令来编译它，就像这样:

`javac HelloJNI.java`

该命令将生成一个`HelloJNI.class`文件，该文件将包含`HelloJNI`类的类定义，其完全限定名为`com.jdojo.jni.HelloJNI`。确保您有可用的`HelloJNI.class`文件，因为它是执行下一步所必需的。

### 创建 C/C++头文件

在开始用 C/C++编写本机方法的代码之前，您需要生成一个头文件，其中包含您的 C/C++方法声明。当您编写您的`hello() native`方法的实现时，您将使用这个头文件。Java 和 C/C++中的`hello()`方法的方法签名差别很大。

您不需要担心如何在 C/C++中编写方法签名的细节，Java 代码将使用这些签名。JDK 提供了一个名为`javah`的工具，可以为您生成所有需要的头文件。`javah`工具位于`JDK_HOME\bin`文件夹中，其中`JDK_HOME`是 JDK 的安装文件夹。例如，如果你在 Windows 的`C:\java8`目录中安装了 JDK，那么`javah`工具就在`C:\java8\bin`中。该工具接受 Java 类的完全限定类名，并生成一个扩展名为`.h`的头文件，其中包含指定类中声明的所有`native`方法的方法签名。以下命令将为`HelloJNI`类中的所有`native`方法声明生成一个 C/C++头文件:

`javah com.jdojo.jni.HelloJNI`

`javah`工具将在`CLASSPATH`中寻找`HelloJNI`类。如果不在`CLASSPATH`中，可以使用`–classpath`或- `cp`命令行选项指定`CLASSPATH`，如下所示:

`javah –cp C:\myclasses com.jdojo.jni.HelloJNI`

该命令将在当前目录下生成一个名为`com_jdojo_jni_HelloJNI.h`的头文件。默认情况下，生成的文件名基于该类的完全限定名。类名中的点被替换为下划线，文件的扩展名为`.h`。您还可以通过使用一个`–o`选项来指定`javah`命令将生成的头文件名称。您可以通过执行`javah –help`命令来查看`javah`命令支持的其他选项。清单 8-2 显示了`com_jdojo_jni_HelloJNI.h`文件的内容。

清单 8-2。com_jdojo_jni_HelloJNI.h 文件的内容

`/* DO NOT EDIT THIS FILE - it is machine generated */`

`#include <jni.h>`

`/* Header for class com_jdojo_jni_HelloJNI */`

`#ifndef _Included_com_jdojo_jni_HelloJNI`

`#define _Included_com_jdojo_jni_HelloJNI`

`#ifdef __cplusplus`

`extern "C" {`

`#endif`

`/*`

`* Class:    com_jdojo_jni_HelloJNI`

`* Method:    hello`

`* Signature: ()V`

`*/`

`JNIEXPORT void JNICALL Java_com_jdojo_jni_HelloJNI_hello`

`(JNIEnv *, jobject);`

`#ifdef __cplusplus`

`}`

`#endif`

`#endif`

您不需要担心头文件中的细节。您只需要为您的`native hello()`方法生成的方法签名。Java 代码中的方法签名`void hello()`已经被翻译成 C/C++代码的如下方法签名:

`JNIEXPORT void JNICALL Java_com_jdojo_jni_HelloJNI_hello (JNIEnv *, jobject);`

`JNIEXPORT`和`JNICALL`是两个宏。关键字`void`表示`native`方法不返回任何值。`javah`命令使用一个规则在头文件中生成`native`方法的名称。在这种情况下，方法名是`Java_com_jdojo_jni_HelloJNI_hello`。稍后我将讨论`javah`工具使用的命名规则的细节。虽然 Java 代码中的`hello()`方法的方法声明不接受任何参数，但是头文件中的`native`方法声明接受两个参数。将本地语言中的所有本地方法声明接受比 Java 代码中声明的参数数量多两个的参数作为一条规则。附加参数作为本地语言中的方法的第一和第二参数被添加。第一个参数是一个指向`JNIEnv`类型对象的指针，这是一个函数指针表，便于本地环境和 Java 环境之间的交互。第二个参数的类型为`jobject`或`jclass`。如果`native`方法在 Java 代码中被声明为非静态的，那么第二个参数的类型是`jobject`，它是对调用本机方法的 Java 对象的引用。它类似于 Java 中每个非静态方法内部都有的`this`引用。由于 Java 中的本机`hello()`方法已经被声明为非静态的，所以第二个参数类型是类型`jobject`。如果本地方法在 Java 中被声明为 static，第二个参数将是类型`jclass`，它将是对 JVM 中调用`native`方法的类对象的引用。

在这一步的最后，您应该有一个名为`com_jdojo_jni_HelloJNI.h`的头文件，其内容如清单 8-2 所示。

### 编写 C/C++程序

清单 8-3 显示了您需要为`hello()`本地方法编写的 C/C++代码。下一节将介绍使用 NetBeans IDE 设置项目和编写 C++代码的分步过程。C++的源代码文件被命名为`hellojni.cpp`。在这种情况下，如果您选择使用 C 语言，代码将是相同的。注意，`hello`是 Java 代码中本地方法的名称，而在 C/C++中它被命名为`Java_com_jdojo_jni_HelloJNI_hello`。

清单 8-3。hello()本机方法的 C/C++实现

`// hellojni.cpp`

`#include <stdio.h>`

`#include <jni.h>`

`#include "com_jdojo_jni_HelloJNI.h"`

`JNIEXPORT void JNICALL Java_com_jdojo_jni_HelloJNI_hello(JNIEnv *env, jobject obj) {`

`printf("Hello JNI\n");`

`return;`

`}`

这是这个程序做的事情。它使用三个 C/C++编译器预处理器`include`指令来包含三个头文件:`stdio.h`、`jni.h`和`com_jdojo_jni_HelloJNI.h`。它包括使用标准输入/输出功能的`stdio.h`，使用 JNI 相关功能的`jni.h`，以及包含与您的`hello() native`方法相关的功能的`com_jdojo_jni_HelloJNI.h`。

安装 JDK 时，`jni.h`文件被复制到`JDK_HOME\include`目录。例如，如果你在`C:\java8`安装了 JDK，那么`jni.h`文件将会在`C:\java8\include`目录下。在`JDK_HOME\include`目录下有一个子目录。子目录名称取决于平台。它在 Windows 上被命名为`win32`，在 Linux 上被命名为`linux`，等等..在编译`hellojni.cpp`文件时，需要使用以下两个目录作为包含路径选项:

*   `C:\java8\include`
*   `C:\java8\include\win32`

这些内含路径是给窗户用的。请根据您的平台进行更改。

您可以将`com_jdojo_jni_HelloJNI.h`文件放在机器上的任何目录中。在编译`hellojni.cpp`文件时，您需要在 include-path 选项中包含包含该文件的目录。

函数签名是从`com_jdojo_jni_HelloJNI.h`头文件中复制的。您将这两个参数命名为`env`和`obj`。在代码中为这些参数使用什么名称并不重要。

`JNIEXPORT void JNICALL Java_com_jdojo_jni_HelloJNI_hello`

`(JNIEnv *env, jobject obj)`

您已经通过添加两个语句为`native`方法提供了实现。第一条语句使用`printf()`函数在标准输出上打印消息`Hello JNI`，第二条语句从函数返回，如下所示:

`printf("Hello JNI\n");`

`return;`

### 创建共享库

在本节中，您将把`hellojni.cpp`文件编译成一个名为`beginningjava`的共享库。共享库在 Windows 上是一个名为`beginningjava.dll`的文件，在类 UNIX 操作系统上是一个名为`beginningjava.so`的文件。您的操作系统可能对共享库使用不同的文件扩展名。有许多编译器可用于从 C/C++代码创建共享库。本节说明如何在上创建共享库

*   Windows 使用名为`g++`的 GNU C++编译器，被称为 MinGW 编译器(Minimalist GNU for Windows)。
*   在 Fedora Linux 上使用名为`g++.`的 GNU C++编译器

要创建共享库，您可以在命令提示符或 IDE(如 Windows 上的 Microsoft Visual Studio 或 Windows 和 Linux 上的 NetBeans)上使用 C/C++编译器。请注意，NetBeans 没有附带 C/C++编译器。要使用 NetBeans IDE 创建共享库，您需要下载一个编译器，如 MinGW 或 Cygwin。

#### 在 Windows 上创建共享库

以下部分描述了如何在 Windows 上安装名为`g++`的 MinGW C++编译器，以及如何通过命令提示符使用它来创建名为`beginningjava.dll`的共享库。

##### 安装 MinGW C/C++编译器

按照以下步骤安装 MinGW 编译器:

*   从 [`http://sourceforge.net/projects/mingw`](http://sourceforge.net/projects/mingw) 下载 MinGW 编译器并安装在你的机器上。
*   假设您已经在`C:\MinGW`目录中安装了 MinGW。您需要安装 MinGW 的以下软件包:mingw-developer-toolkit、migw32-base、mingw32-gcc-g++和 msys-base。如果您已将 MinGW 安装在另一个目录中，请在本节的以下讨论中将此目录路径替换为您的安装目录路径。
*   将`C:\MinGW\bin`目录添加到系统`PATH`环境变量中。如果不设置系统 PATH 环境变量，则可以通过在命令提示符下设置 PATH 环境变量来使用 MinGW。
*   验证`C:\MinGw\bin\g++.exe`文件存在于您的机器上。`g++`是`C++`编译器，`gcc`是 MinGW 使用的 C 编译器。你将使用本章中的 C++代码和 g++编译器来编译 C++代码。

##### 使用 g++命令

您需要使用`g++`命令来创建一个共享库。创建共享库需要两种类型的文件:

*   包含 C++代码的 C++源文件。在这种情况下，您将其命名为`hellojin.cpp`，如清单 8-3 所示。
*   清单 8-2 所示的`com_jdojo_jni_HelloJNI.h`头文件。
*   与 JNI 相关的头文件位于`JDK_HOME\include`和 J `DK_HOME\include\win32`目录中，其中`JDK_HOME`是您安装 JDK 的目录。

您可以向`g++`编译器传递几个选项。以下命令显示了创建共享库所需的最少选项:

`g++ -Wl,--kill-at -shared –I<include-dir> -o <output-file> <source-files>`

这里，

*   `-Wl,<option>`用于将选项传递给链接器。`<option>`是一个逗号分隔的链接器选项列表。在这个命令中，您将`--kill-at`选项传递给链接器，以便在导出符号之前从符号中去除标准调用后缀(`@nn`)。如果您没有指定这个选项，当您运行使用共享库的 Java 程序时，您将得到一个`java.lang.UnsatisfiedLinkError`。
*   `–shared`选项表示您想要创建一个共享库。
*   `–I<include-dir>`选项用于传递包含头文件的目录(。h 文件)。您可以对每个目录重复此选项一次。
*   `–o <output-file>`选项指定输出文件名。在您的例子中，您将使用名为`beginningjava.dll`的输出文件。
*   `<source-files>`是用空格分隔的 C++源文件列表。

为了简化生成共享库的命令语法，我假设您的计算机上存在以下目录和文件:

*   `C:\dll\hellojni.cpp`
*   `C:\dll\com_jdojo_jni_HelloJNI.h`
*   `C:\java8\include`
*   `C:\java8\include\win32`

以下命令将在`C:\dll`目录中生成`beginingjava.dll`文件。为了清楚起见，命令的每个部分都显示在单独的行中；您将在一行中输入整个命令。

`C:\> g++ -Wl,--kill-at -shared`

`-IC:/java8/include -IC:/java8/include/win32 -IC:/dll`

`-o C:/dll/beginningjava.dll`

`C:/dll/hellojni.cpp`

请注意文件路径中正斜杠的使用。对于 Windows 上的 g++命令，您可以使用正斜杠或反斜杠作为路径分隔符。请更改命令中的路径，以匹配您计算机上这些文件和目录的路径。

如果您没有将 PATH 环境变量设置为`C:\MinGW\bin`目录，当您运行`g++`命令时，您可能会得到以下错误:

`'g++' is not recognized as an internal or external command,operable program or batch file`

Note

在 Windows 上，如果您想将 NetBeans IDE 与 MinGW 一起使用，请参考以下链接获取设置说明: [`https://netbeans.org/community/releases/80/cpp-setup-instructions.html`](https://netbeans.org/community/releases/80/cpp-setup-instructions.html) `.`

#### 在 Linux 上创建共享库

以下部分描述了如何在 Fedora Linux 上安装名为`g++`的 GNU C++编译器，以及如何在终端上使用它来创建名为`beginningjava.so`的共享库。

##### 安装 MinGW C/C++编译器

在 Linux 上安装`g++`编译器很容易。在 Linux 终端上运行以下命令将安装`g++`编译器:

`$ yum install gcc-c++`

运行该命令时，您可能会收到以下消息:

`$ yum install gcc-c++`

`You need to be root to perform this command.`

`$`

如果您收到此消息，您需要以 root 用户身份登录来安装编译器。使用`su –`命令以 root 身份登录，在出现提示时输入 root 密码，然后运行`yum`命令。

`$ su –`

`Password:` `Enter Your Password Here`

`# yum install gcc-c++`

在安装过程中，`yum`命令会多次提示您确认编译器安装文件的下载。当你得到这些提示时，你需要回答是。如果您的机器上已经安装了 g++编译器，那么`yum`命令将会打印一条相应的消息。

这就是在 Linux 上安装 g+=编译器的全部工作。

##### 使用 g++命令

您需要使用`g++`命令来创建一个共享库。创建共享库需要两种类型的文件:

*   包含 C++代码的 C++源文件。在这种情况下，您将其命名为`hellojni.cpp`，如清单 8-3 所示。
*   清单 8-2 所示的`com_jdojo_jni_HelloJNI.h`头文件。
*   与 JNI 相关的头文件位于`JDK_HOME/include`和 J `DK_HOME/include/win32`目录中，其中`JDK_HOME`是您安装 JDK 的目录。

您可以向`g++`编译器传递几个选项。以下命令显示了创建共享库所需的最少选项:

`g++ -shared –I<include-dir> -o <output-file> <source-files>`

在这里，

*   `–shared`选项表示您想要创建一个共享库。
*   `–I<include-dir>`选项用于传递包含头文件的目录(。`h`文件)。您可以对每个目录重复此选项一次。
*   `–o <output-file>`选项指定输出文件名。在您的例子中，您将使用输出文件名`beginningjava.so`。
*   `<source-files>`是用空格分隔的 C++源文件列表。

为了简化生成共享库的命令语法，我假设您的计算机上存在以下目录和文件:

*   `/home/ksharan/slib/hellojni.cpp`
*   `/home/ksharan/slib/com_jdojo_jni_HelloJNI.h`
*   `/home/ksharan/java8/include`
*   `/home/ksharan/java8/include/linux`

以下命令将在`/home/ksharan/slib`目录中生成`beginingjava.so`文件。为了清楚起见，命令的每个部分都显示在单独的行中；您将在一行中输入整个命令。

`$ g++ -shared`

`-I/home/ksharan/java8/include -I/home/ksharan/java8/include/linux -I/home/ksharan/slib`

`-o /home/ksharan/slib/beginningjava.so`

`/home/ksharan/slib/hellojni.cpp`

请更改命令中的路径，以匹配您计算机上这些文件和目录的路径。

Note

在 Linux 上，如果您想将 NetBeans IDE 与 g++编译器一起使用，请参考下面的设置说明链接: [`https://netbeans.org/community/releases/80/cpp-setup-instructions.html`](https://netbeans.org/community/releases/80/cpp-setup-instructions.html) `.`

### 运行 Java 程序

在继续运行 Java 类之前，请确保您能够创建共享库(Windows 上的`beginningjava.dll`文件和类 UNIX 操作系统上的`beginningjava.so`文件)。如果您不能创建共享库，您可以使用本书源代码提供的共享库。共享库位于一个名为`cplusplus`的目录中。

现在你已经准备好运行你的`HelloJNI` Java 类了，如清单 8-1 所示。假设您已经将`beginningjava`共享库文件放在了`C:\myjni\lib`目录中。使用以下命令运行`HelloJNI`类:

`C:\> java -Djava.library.path=C:\myjni\lib com.jdojo.jni.HelloJNI`

`-Djava.library.path=C:\myjni\lib`选项指示 JVM 在`C:\myjni\lib`目录中寻找共享库。如果上述命令成功运行，它将在标准输出中打印一条消息`Hello JNI`。或者，您也可以将包含共享库的目录添加到 PATH 环境变量中，Java 运行时会找到它。如果共享库在当前目录中，Windows 也将找到共享库，而不设置`java.library.path`选项。下列命令显示如何为当前会话设置 PATH 环境变量(在 Windows 上)并运行类:

`C:\> SET PATH=C:\myjni\lib;%PATH%`

`C:\> java com.jdojo.jni.HelloJNI`

## 本机函数命名规则

该命令使用基于名称管理的命名规则，在 C/C++头文件中生成本机方法名称。Java 运行时使用相同的规则将 Java 本地方法名解析为共享库中的本地函数名。使用名称管理规则，以便为本机函数生成的名称是没有名称冲突的有效 C/C++名称。您可以将名称篡改视为简单地用组成有效函数名的字符替换无效字符。本机函数名是基于以下部分生成的，这些部分用下划线连接在一起:

*   方法名以单词`Java`开头。
*   包含本机方法声明的 Java 类的包的完全限定名。下划线用作包/子包分隔符。
*   Java 中的本机方法名。
*   对于重载的本机方法，两个下划线后跟被破坏的方法的签名

Java 运行时对本地函数使用两个名称——一个短名称和一个长名称。短名称不使用两个下划线后跟被破坏的方法的签名。Java 运行时首先在共享库中搜索简称。如果没有找到使用短名称的函数，它将使用长名称进行搜索。被破坏的名称使用了表 [8-1](#Tab1) 中所示的转换表。

表 8-1。

The Escape Sequence Used in the Name-Mangling Process

<colgroup><col> <col></colgroup> 
| 原始字符 | 替代字符 |
| --- | --- |
| 任何非 ASCII Unicode 字符 | `_0xxxx`注意 _ `oxxxx`中使用的字母都是小写的，比如`_0abcd` |
| `_`(下划线) | `_1` |
| `;`(一个分号) | `_2` |
| `[`(一个开始方括号) | `_3` |

诸如分号和以方括号开头的字符可能作为 Java 内部使用的方法参数签名的一部分出现。表 [8-2](#Tab2) 显示了。Java 代码和 Java 内部使用的方法签名。

表 8-2。

Examples of Java Method’s Declaration and Internally Used Method Signatures

<colgroup><col> <col></colgroup> 
| 方法声明 | 内部使用的方法签名 |
| --- | --- |
| `public static void javaPrintMsg(java.lang.String)` | `(Ljava/lang/String;)V` |
| `public void javaCallBack()` | `()V` |
| `public static void main(java.lang.String[])` | `([Ljava/lang/String;)V` |

如果您声明了一个类型为`java.lang.String`的参数，它在内部被用作`Ljava/lang/String;`。要了解 Java 内部使用的方法的签名，您需要使用带有`–s`选项的`javap`命令。下面的命令将打印出`com.jdojo.jni.HelloJNI`类中所有方法的方法签名。您可以使用`–private`选项打印所有方法的签名，包括`private`方法。

`javap -s -private com.jdojo.jni.HelloJNI`

如果您需要在本地代码的 JNI 函数中使用 Java 方法的方法签名，您应该运行`javap`命令来获取签名，而不是手动输入。您可以学习用于组成 Java 内部使用的方法签名的规则。然而，使用`javap`命令可以很容易地获得这些信息。让我们考虑一下清单 8-4 所示的`Test`类中一些本地方法的声明。

清单 8-4。带有一些本机方法声明的测试类

`package com.jdojo.jni;`

`public class Test {`

`private native void sayHello();`

`private native void printMsg(String msg);`

`private native int[] increment(int[] num, int incrementValue);`

`private native double myMethod(int i, String s[], String ss);`

`private native double myMethod(double i, String s[], String ss);`

`private native double myMethod(short i, String s[], String ss);`

`}`

如果编译`Test`类并运行命令

`javah com.jdojo.jni.Test`

您会得到一个`com_jdojo_jni_Test.h`头文件，其内容如清单 8-5 所示。

清单 8-5。为 com.jdojo.jni.Test 类生成的头文件

`/* DO NOT EDIT THIS FILE - it is machine generated */`

`#include <jni.h>`

`/* Header for class com_jdojo_jni_Test */`

`#ifndef _Included_com_jdojo_jni_Test`

`#define _Included_com_jdojo_jni_Test`

`#ifdef __cplusplus`

`extern "C" {`

`#endif`

`/*`

`* Class:    com_jdojo_jni_Test`

`* Method:    sayHello`

`* Signature: ()V`

`*/`

`JNIEXPORT void JNICALL Java_com_jdojo_jni_Test_sayHello`

`(JNIEnv *, jobject);`

`/*`

`* Class:    com_jdojo_jni_Test`

`* Method:    printMsg`

`* Signature: (Ljava/lang/String;)V`

`*/`

`JNIEXPORT void JNICALL Java_com_jdojo_jni_Test_printMsg`

`(JNIEnv *, jobject, jstring);`

`/*`

`* Class:    com_jdojo_jni_Test`

`* Method:    increment`

`* Signature: ([II)[I`

`*/`

`JNIEXPORT jintArray JNICALL Java_com_jdojo_jni_Test_increment`

`(JNIEnv *, jobject, jintArray, jint);`

`/*`

`* Class:    com_jdojo_jni_Test`

`* Method:    myMethod`

`* Signature: (I[Ljava/lang/String;Ljava/lang/String;)D`

`*/`

`JNIEXPORT jdouble JNICALL Java_com_jdojo_jni_Test_myMethod__I_3Ljava_lang_String_2Ljava_lang_String_2`

`(JNIEnv *, jobject, jint, jobjectArray, jstring);`

`/*`

`* Class:    com_jdojo_jni_Test`

`* Method:    myMethod`

`* Signature: (D[Ljava/lang/String;Ljava/lang/String;)D`

`*/`

`JNIEXPORT jdouble JNICALL Java_com_jdojo_jni_Test_myMethod__D_3Ljava_lang_String_2Ljava_lang_String_2`

`(JNIEnv *, jobject, jdouble, jobjectArray, jstring);`

`/*`

`* Class:    com_jdojo_jni_Test`

`* Method:    myMethod`

`* Signature: (S[Ljava/lang/String;Ljava/lang/String;)D`

`*/`

`JNIEXPORT jdouble JNICALL Java_com_jdojo_jni_Test_myMethod__S_3Ljava_lang_String_2Ljava_lang_String_2`

`(JNIEnv *, jobject, jshort, jobjectArray, jstring);`

`#ifdef __cplusplus`

`}`

`#endif`

`#endif`

您可以查看为不同的`native`方法声明生成的本地函数名。不要担心用于函数参数的数据类型。我将在下一节介绍 Java 和本地语言之间的数据类型映射。

## 数据类型映射

JNI 定义了 Java 中使用的数据类型和本地函数之间的映射。表 [8-3](#Tab3) 列出了 Java 和本地 C/C++语言之间的原始数据类型映射。请注意，在 Java 中，您只需在原始数据类型的名称前添加一个`j`,就可以在 C/C++中获得等效的数据类型名称。JNI 还定义了一个名为`jsize`的数据类型，用来存储长度，比如数组或者字符串的长度。

表 8-3。

The Mapping Between Java Primitive Data Types and JNI Native Data Types

<colgroup><col> <col> <col></colgroup> 
| Java 原始类型 | 本地原始类型 | 描述 |
| --- | --- | --- |
| `boolean` | `jboolean` | 无符号 8 位 |
| `byte` | `jbyte` | 带符号的 8 位 |
| `char` | `jchar` | 无符号 16 位 |
| `double` | `jdouble` | 64 位 |
| `float` | `jfloat` | 32 位 |
| `int` | `jint` | 有符号 32 位 |
| `long` | `jlong` | 有符号 64 位 |
| `short` | `jshort` | 有符号 16 位 |
| `void` | `void` | 不适用的 |

JNI 定义了 Java 引用类型的引用类型等价物。不可能在 JNI 中为所有可以在 Java 中创建的引用类型定义单独的类型。所有 Java 引用类型都可以映射到名为`jobject`的 JNI 引用类型。你有一些专门的 JNI 引用类型，代表 Java 中常用的引用类型，比如 JNI 的`jstring`代表 Java 中的`java.lang.String`。表 [8-4](#Tab4) 列出了 Java 和 JNI 之间的引用类型映射。

表 8-4。

The Reference Type Mapping Between Java and JNI

<colgroup><col> <col></colgroup> 
| Java 引用类型 | JNI 类型 |
| --- | --- |
| 任何 Java 对象 | `jobject` |
| `java.lang.String` | `jstring` |
| `java.lang.Class` | `jclass` |
| `java.lang.Throwable` | `jthrowable` |

JNI 定义了单独的引用类型来表示 Java 数组。类型`jarray`是表示任何 Java 数组类型的通用数组类型。在 Java 中，每种类型的数组都有专门的数组类型。在 JNI，数组类型被命名为`jxxxArray`，其中 x `xx`可以是`object`、`boolean`、`byte`、`char`、`double`、`float`、`int`、`long`、`short`。比如 C/C++中的`jintArray`在 Java 中代表一个`int`数组。注意，Java 中的所有引用类型数组在 C/C++中都用`jobjectArray`类型表示。

当使用 JNI 处理 C/C++代码时，您会遇到另一种称为`jvalue`的类型。它是在 C/C++中定义的联合类型，如下所示:

`typedef union jvalue {`

`jboolean z;`

`jbyte    b;`

`jchar    c;`

`jshort  s;`

`jint    i;`

`jlong    j;`

`jfloat  f;`

`jdouble  d;`

`jobject  l;`

`} jvalue`

请注意，`jvalue`联合类型在 Java 中没有对等的类型。通常，`jvalue`类型被定义为内置函数中的参数类型，这些内置函数是 JNI API 的一部分。

## 在 C/C++中使用 JNI 函数

JNI 函数允许您访问本机代码中的 JVM 数据结构和对象。有时，它们允许您将数据转换成在 Java 和本地环境之间传递的特定格式。所有本地函数都有自己的第一个参数，这个参数总是指向`JNIEnv`的指针，而这个指针又指向一个包含所有 JNI 函数指针的表。

总有两个版本的函数可以在类型`JNIEnv:`上调用，一个用于 C，一个用于 C++。该函数的 C 版本接受一个指向`JNIEnv`的指针作为第一个参数，而 C++不会有那个第一个参数。相同方法的两个版本，C 和 C++，被不同地调用。下面的代码片段展示了在 C 和 C++中调用 JNI 函数的区别，假设`FuncXxx`是函数名，`env`是指向`JNIEnv`类型的指针:

`// C style`

`(*env)->FuncXxx(env, list-of-arguments...);`

`// C++ style`

`env->FuncXxx(list-of-arguments...);`

本章使用 C++方式调用 JNI 函数。通过使用上面的代码片段作为参考，您可以轻松地将代码转换为 C 风格。

作为一个具体的例子，下面是`GetStringUTFChars()` JNI 函数的函数签名，它允许你将 Java 字符串转换成 UTF-8 字符串格式:

`// C Version of the GetStringUTFChars() JNI function`

`const char * GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy);`

`// C++ Version of the GetStringUTFChars() JNI function`

`const char * GetStringUTFChars(jstring string, jboolean *isCopy);`

如果您想在 C 或 C++中调用这个函数，您的代码将如下所示:

`// C Code`

`const char *utfMsg = (*env)->GetStringUTFChars(env, msg, iscopy);`

`// C++ Code`

`const char *utfMsg = env->GetStringUTFChars(msg, iscopy);`

## 使用字符串

Java 和 C/C++中字符串的表示方式不同。在 Java 中，字符串被表示为 16 位 Unicode 字符序列，而在 C/C++中，字符串是指向以空字符结尾的字符序列的指针。本机代码中的`jstring`引用类型表示`java.lang.String`类的一个实例，它是一个 16 位 Unicode 字符序列。JNI 具有将 Java 字符串转换成本地字符串的功能，反之亦然。一组字符串函数处理 UTF-8 字符串，另一组处理 Unicode 字符串。当 Java 将一个字符串传递给本机代码时，在使用它之前，必须将本机代码中的字符串转换为本机格式(UTF-8 或 Unicode)。同样的逻辑也适用于将字符串从本机代码返回到 Java。您必须将原生字符串转换为`jstring`的实例，然后才能将其返回到 Java。

让我们从一个例子开始，在这个例子中，你将把一个字符串从 Java 代码传递给 C/C++代码。C/C++代码会将 Java 字符串转换成原生的 UTF 8 格式，并使用`printf()`函数将其打印在标准输出上。Java 中的本地方法声明如下:

*   `public native void printMsg(String msg);`
*   `public native String getMsg();`

`printMsg()`方法接受一个 Java 字符串，它的本地函数将把它打印在标准输出上。`getMsg()`方法将一个本地字符串返回给 Java，Java 将在标准输出中打印它。清单 8-6 包含了声明这两个本地方法的 Java 代码。注意，静态 initialize 加载了您在上一节中创建的名为`beginningjava`的共享库。这一次，您将需要在共享库中包含新的本机方法的 C++代码。

清单 8-6。将字符串从 Java 传递到本机函数，反之亦然

`// JNIStringTest.java`

`package com.jdojo.jni;`

`public class JNIStringTest {`

`static {`

`System.loadLibrary("beginningjava");`

`}`

`public native void printMsg(String msg);`

`public native String getMsg();`

`public static void main(String[] args) {`

`JNIStringTest stringTest = new JNIStringTest();`

`String javaMsg = "Hello from Java to JNI";`

`stringTest.printMsg(javaMsg);`

`String nativeMsg = stringTest.getMsg();`

`System.out.println(nativeMsg);`

`}`

`}`

以下是 C/C++中`printMsg()`和`getMsg()`的本机函数声明:

*   `JNIEXPORT void JNICALL Java_com_jdojo_jni_JNIStringTest_printMsg(JNIEnv *env, jobject obj, jstring msg);`
*   `JNIEXPORT jstring JNICALL Java_com_jdojo_jni_JNIStringTest_getMsg(JNIEnv *env, jobject obj);`

注意，本地函数中的前两个参数是类型`JNIEnv`和`jobject`。`printMsg()`函数包含类型为`jstring`的第三个参数，其返回类型为`void`。`getMsg()`函数只包含两个标准参数，它返回一个`jstring`。

要将`jstring`转换成 UTF-8 原生字符串，需要使用`GetStringUTFChars()` JNI 函数，可以通过使用`JNIEnv`引用来访问该函数。`GetStringUTFChars()` JNI 函数有两个版本:一个用于 C，一个用于 C++。

`GetStringUTFChars()`函数将 Java 字符串(在 C/C++代码的`jstring`中)转换成 UTF 8 格式，并返回一个指向转换后的 UTF 8 字符串的指针。如果失败，它返回`NULL`。`GetStringUTFChars()`函数可能需要在内存中复制原始的 Java 字符串对象，以便将其转换为 UTF-8 格式。函数的`isCopy`参数是一个指向`boolean`变量的指针，可以用来检查这个函数是否必须复制原始的 Java 字符串。如果`isCopy`不是`NULL`，如果复制了 Java 字符串，则它被设置为`JNI_TRUE`。否则设置为`JNI_FALSE`。一旦处理完这个函数的返回值，就必须调用`ReleaseStringUTFChars()`方法来释放内存。此方法的 C 和 C++样式签名如下:

`// C Style`

`void ReleaseStringUTFChars(JNIEnv *env, jstring string, const char *utf);`

`// C++ Style`

`void ReleaseStringUTFChars(jstring string, const char *utf);`

清单 8-7 包含了 C++中本地方法`printMsg()`和`getMsg()`的实现。代码在本书源代码的`jnistringtest.cpp`文件中。`getMsg()`的代码很简单。它使用`NewStringUTF()` JNI 函数从本地字符串中获取一个 Java 字符串。

清单 8-7。jnistringtest.cpp 文件的内容

`// jnistringtest.cpp`

`#include <stdio.h>`

`#include <jni.h>`

`#include "com_jdojo_jni_JNIStringTest.h"`

`JNIEXPORT void JNICALL Java_com_jdojo_jni_JNIStringTest_printMsg`

`(JNIEnv *env, jobject obj, jstring msg) {`

`const char *utfMsg;`

`jboolean *iscopy = NULL;`

`// Get the UTF string`

`utfMsg = env->GetStringUTFChars(msg, iscopy);`

`if (utfMsg == NULL) {`

`printf("Could not convert Java string to UTF-8 string.\n");`

`return;`

`}`

`// Print the message on the standard output`

`printf("%s\n", utfMsg);`

`// Release the memory`

`env->ReleaseStringUTFChars(msg, utfMsg);`

`}`

`JNIEXPORT jstring JNICALL Java_com_jdojo_jni_JNIStringTest_getMsg`

`(JNIEnv *env, jobject obj) {`

`const char *utfMsg = "Hello from JNI to Java";`

`jstring javaString = env->NewStringUTF(utfMsg);`

`return javaString;`

`}`

运行`JNIStringTest`类的`javah`命令来创建`com_jdojo_jni_JNIStringTest.h` C++头文件。

`javah com.jdojo.jni.JNIStringTest`

要在同一个名为`beginningjava`的共享库中包含`hellojni.cpp`和`jnistringtest.cpp`文件的 C++内容，需要将这两个文件作为源文件传递给 g+=命令。下面是 Windows 上的命令，假设您已经将两个源文件的头文件放在了`C:\dll`目录中。

`C:\> g++ -Wl,--kill-at -shared`

`-IC:/java8/include -IC:/java8/include/win32 -IC:/dll`

`-o C:/dll/beginningjava.dll`

`C:/dll/hellojni.cpp C:/dll/jnistringtest.cpp`

请参考“在 Linux 上创建共享库”一节，在 Linux 上用两个 C++源文件创建共享库。

现在你已经准备好运行清单 8-6 中列出的`JNIStringTest`类了。它将生成以下输出:

`Hello from JNI to Java`

`Hello from Java to JNI`

您可以使用`GetStringUTFLength(jstring string)` JNI 函数来获得以字节为单位的`jstring`的长度，以 UTF-8 格式表示它。JNI 也有让您使用 Unicode 原生字符串的功能。Unicode 字符串函数被命名为不带单词“UTF”的 UTF 字符串函数。例如，要用 Unicode 字符获得一个`jstring`的长度，您需要一个`GetStringLength()`函数，而不是`GetStringUTFLength()`函数。为了从 Unicode 字符构造一个新的 Java `String` (a `jstring`)，我们有一个`NewString()` JNI 函数，而不是`NewStringUTF()` JNI 函数，后者从 UTF 8 本地字符串创建一个 Java 字符串。有时您可能需要将`jstring`中的 Java `String`转换成本地编码，反之亦然。您可以使用`java.lang.String`类，它有一组丰富的构造函数和方法，允许您将一种编码的字符串转换为字节数组，反之亦然。我将在后面的章节中介绍如何在本机代码中访问 Java 类。

## 使用数组

JNI 允许您将一组原语或引用类型从 Java 传递到本机代码，反之亦然。您不能在本机代码中直接访问或使用 Java 数组。您将需要使用 JNI 函数在本机代码中处理 Java 数组。JNI 为原始数组和引用数组提供了一组不同的函数。有些函数是两种类型共有的。本节中使用的所有与数组相关的方法都使用 C++版本。给它们加上`JNIEnv *env`作为第一个参数，得到对应的 C 版本。

`GetArrayLength()`方法返回基元或引用类型的数组长度。它的宣言是

`jsize GetArrayLength(jarray array)`

您可以使用`New<Xxx>Array()`方法创建一个原始类型的数组，其中`<Xxx>`是`Boolean`、`Byte`、`Double`、`Float`、`Int`、`Long`或`Short`的原始类型之一。您需要将基本类型数组的长度作为参数传递给该方法。如果无法创建数组，它将返回`NULL`。以下代码片段创建了一个长度均为 10 的`int`数组和一个`double`数组:

`jintArray iArray = env->NewIntArray(10);`

`jdoubleArray dArray = env->NewDoubleArray(10);`

您可以使用`Get<Xxx>ArrayElements()`来获取原始数组的内容，其中`<Xxx>`是`Boolean`、`Byte`、`Char`、`Double`、`Float`、`Int`、`Long`或`Short`的原始类型之一。兹声明如下:

`<RRR> *Get<Xxx>ArrayElements(<AAA> array, jboolean *isCopy)`

`Here, <RRR>`为 JNI 原生数据类型，如`jint`或`jdouble`,`<AAA>`为 JNI 数组类型，如`jintArray`、`jdoubleArray`等。`isCopy`参数指示返回的数组元素是否是原始数组的副本。如果`isCopy`不是`NULL`，如果复制了原始数组，则设置为`JNI_TRUE`。如果没有复制原始数组，则设置为`JNI_FALSE`。您还可以对本机代码中的数组元素进行更改，这些更改将反映到原始数组中。您需要释放元素，这些元素是在您使用完之后通过这个方法获得的。您需要使用`Release<Xxx>ArrayElements()`方法来释放数组元素，声明如下:

`void Release<Xxx>ArrayElements(<AAA> array, <RRR> *elems, jint mode)`

`Release<Xxx>ArrayElements()`函数中的最后一个参数`mode`指示如何释放在本机代码中用于数组元素的缓冲区。其值可以是 0、`JNI_COMMIT`或`JNI_ABORT`。0 表示复制回内容并释放`elems`缓冲区；`JNI_COMMIT`表示复制回内容，但不释放`elems`缓冲区；而`JNI_ABORT`意味着释放缓冲区而不复制回可能的更改。下面的代码片段用本机代码访问一个`int` Java 数组，并在标准输出中打印它的所有元素值:

`jintArray num = get a Java array...;`

`const jsize count = env->GetArrayLength(num);`

`jboolean isCopy;`

`jint *intNum = env->GetIntArrayElements(num, &isCopy);`

`for (jsize i = 0; i < count; i++) {`

`printf("%i\n", intNum[i]);`

`}`

`// Release the intNum buffer without copying back any changes made to the array elements`

`env->ReleaseIntArrayElements(num, intNum, JNI_ABORT);`

本机代码中的引用类型 Java 数组被区别对待。你可以使用`NewObjectArray()`函数创建一个新的引用类型数组。该方法声明如下:

`jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement)`

请注意，您需要使用数组元素的类类型对象来创建一个引用数组。最后一个参数是初始化数组所有元素的初始元素。

与基元类型数组不同，您不需要获取引用类型数组的数组元素来访问它们。您可以使用`GetObjectArrayElement()`功能一次访问一个元素。您可以使用`SetObjectArrayElement()`函数来设置引用类型的数组元素的值。这些方法声明如下:

*   `jobject GetObjectArrayElement(jobjectArray array, jsize index)`
*   `void SetObjectArrayElement(jobjectArray array, jsize index, jobject value)`

让我们看看在 JNI 应用程序中使用数组的例子。清单 8-8 包含使用数组声明三个本地方法的 Java 代码。

清单 8-8。在本机代码中访问和操作数组的示例

`// JNIArrayTest.java`

`package com.jdojo.jni;`

`import java.util.Arrays;`

`public class JNIArrayTest {`

`static {`

`System.loadLibrary("beginningjava");`

`}`

`// Three native method declarations`

`public native int sum(int[] num);`

`public native String concat(String[] str);`

`public native int[] increment(int[] num, int incrementBy);`

`public static void main(String[] args) {`

`JNIArrayTest test = new JNIArrayTest();`

`int[] num = {1, 2, 3, 4, 5};`

`String[] str = {"One", "Two", "Three", "Four", "Five" } ;`

`System.out.println("Original Number Array: " + Arrays.toString(num));`

`System.out.println("Original String Array: " + Arrays.toString(str));`

`int sum = 0;`

`sum = test.sum(num);`

`System.out.println("Sum: " + sum);`

`String concatenatedStr = test.concat(str);`

`System.out.println("Concatenated String: " + concatenatedStr);`

`int increment = 5;`

`int[] incrementedNum = test.increment(num, increment);`

`System.out.println("Increment By: " + increment);`

`System.out.println("Incremented Number Arrays: " +`

`Arrays.toString(incrementedNum));`

`}`

`}`

`sum()`本地方法接受一个`int`数组，并返回其所有元素的总和作为`int`。当您调用`sum()`方法时，注意不要在`int`数组中传递大的数字。否则，结果可能会溢出。`concat()`本地方法接受一个`String`数组。它连接数组中的所有元素并返回一个`String`对象。`increment()`本地方法接受一个`int`数组和一个`int`数字。它返回一个新的`int`数组，该数组包含原数组中按指定数字递增的所有元素。`main()`方法包含测试三个本地方法的代码。

运行`JNIArrayTest`类的`javah`命令来创建`com_jdojo_jni_JNIArrayTest.h` C++头文件。

`javah com.jdojo.jni.JNIArrayTest`

清单 8-9 包含了`jniarraytest.cpp`文件中三个本地方法的 C++实现。`concat()`方法的实现假设`String`数组中所有元素的长度不会超过 500 字节。请参考上一节关于如何在共享库中包含 C+=源文件的内容。

清单 8-9。jniarraytest.cpp 文件的内容，带有 sum()、concat()和 increment()本机方法的 C++实现

`// jniarraytest.cpp`

`#include <jni.h>`

`#include <cstring>`

`#include "com_jdojo_jni_JNIArrayTest.h"`

`JNIEXPORT jint JNICALL Java_com_jdojo_jni_JNIArrayTest_sum`

`(JNIEnv *env, jobject obj, jintArray num) {`

`jint sum = 0;`

`const jsize count = env->GetArrayLength(num);`

`jboolean isCopy;`

`jint *intNum = env->GetIntArrayElements(num, &isCopy);`

`for (jsize i = 0; i < count; i++) {`

`sum += intNum[i];`

`}`

`// Release the intNum buffer without copying back any changes made to the array elements`

`env->ReleaseIntArrayElements(num, intNum, JNI_ABORT);`

`return sum;`

`}`

`JNIEXPORT jstring JNICALL Java_com_jdojo_jni_JNIArrayTest_concat`

`(JNIEnv *env, jobject obj, jobjectArray strArray) {`

`const int MAX_LENGTH = 500;`

`char dest[MAX_LENGTH];`

`for (int i = 0; i < MAX_LENGTH; i++) {`

`dest[i] = (char)NULL;`

`}`

`const jsize count = env->GetArrayLength(strArray);`

`for (jsize i = 0; i < count; i++) {`

`// Get the string object from the array`

`jstring strElement =`

`(jstring) env->GetObjectArrayElement(strArray, i);`

`const char *tempStr = env->GetStringUTFChars(strElement, NULL);`

`if (tempStr == NULL) {`

`printf("Could not convert Java string to UTF-8 string.\n");`

`return NULL;`

`}`

`// Concatenate tempStr to dest`

`strcat(dest, tempStr);`

`// Release the memory used by tempStr`

`env->ReleaseStringUTFChars(strElement, tempStr);`

`// Delete the local reference of jstring`

`env->DeleteLocalRef(strElement);`

`}`

`jstring returnStr = env->NewStringUTF(dest);`

`return returnStr;`

`}`

`JNIEXPORT jintArray JNICALL Java_com_jdojo_jni_JNIArrayTest_increment`

`(JNIEnv *env, jobject obj, jintArray num, jint incrementBy) {`

`const jsize count = env->GetArrayLength(num);`

`jboolean isCopy;`

`jint *intNum = env->GetIntArrayElements(num, &isCopy);`

`jintArray modifiedNumArray = env->NewIntArray(count);`

`jboolean isNewArrayCopy;`

`jint *modifiedNumElements =`

`env->GetIntArrayElements(modifiedNumArray, &isNewArrayCopy);`

`for (jint i = 0; i < count; i++) {`

`modifiedNumElements[i] = intNum[i] + incrementBy;`

`}`

`if (isCopy == JNI_TRUE) {`

`env -> ReleaseIntArrayElements(num, intNum, JNI_COMMIT);`

`}`

`if (isNewArrayCopy == JNI_TRUE) {`

`env -> ReleaseIntArrayElements(modifiedNumArray,`

`modifiedNumElements,`

`JNI_COMMIT);`

`}`

`return modifiedNumArray;`

`}`

运行清单 8-8 所示的`JNIArrayTest`类将产生以下输出:

`Original Number Array: [1, 2, 3, 4, 5]`

`Original String Array: [One, Two, Three, Four, Five]`

`Sum: 15`

`Concatenated String: OneTwoThreeFourFive`

`Increment By: 5`

`Incremented Number Arrays: [6, 7, 8, 9, 10]`

## 在本机代码中访问 Java 对象

您可以以不同的方式在本机代码中使用 Java 对象:您可以

*   用本机代码创建 Java 对象。
*   从本机代码访问 JVM 中存在的 Java 对象和类。
*   访问/修改本机代码中 Java 对象的字段。
*   从本机代码中调用 Java 实例和 Java 对象的静态方法。

以下部分描述了在本机代码中使用 Java 对象所需的步骤。

### 获取类引用

`jclass`类型的实例表示本机代码中的类对象。如果你调用一个本地函数，在 Java 类中声明为`static`和`native`，你的本地函数总是获得类对象的引用作为第二个参数。有时你可能有一个 Java 对象的引用在`jobject`类型中，你想得到它的类对象引用。您需要使用`GetObjectClass()` JNI 函数来获取 Java 对象的类对象的引用，如下所示:

`jobject obj = get the reference to a Java object;`

`jclass cls = env->GetObjectClass(obj);`

使用`FindClass()` JNI 函数通过类名获得类对象的引用。您需要在`FindClass()`方法中使用类的完全限定名，方法是用正斜杠替换包名中的点。如果您试图获取数组的类对象的引用，您需要使用数组类签名。为了获得对`java.lang.String`类的类对象的引用，您需要使用`java/lang/String`作为类名。要获得`int[]`的类对象引用，需要使用`[I`作为类名。要知道数组类型的类的正确签名，可以在该数组类型的类中声明一个字段，并使用带有`–s`和`–private`选项的`javap`命令。以下代码片段演示了如何获取某些 Java 引用类型的类对象的引用:

`jclass cls;`

`// Get the reference of the java.lang.String class object`

`cls = env->FindClass("java/lang/String");`

`// Get the reference of the int[] array class object`

`cls = env->FindClass("[I");`

`// Get the reference of the int[][] array class object`

`cls = env->FindClass("[[I");`

`// Get the reference of the String[] array class object. Note a semi-colon in signature`

`cls = env->FindClass("[Ljava/lang/String;");`

### 访问 Java 对象/类的字段和方法

在访问本地代码中的 Java 对象/类的字段之前，必须获得字段 ID。您需要使用`GetFieldID()` JNI 函数获取实例字段的字段 ID，使用`GetStaticFieldID()` JNI 函数获取静态字段的字段 ID。这两种方法的签名如下:

*   `jfieldID GetFieldID(jclass cls, const char *name, const char *sig)`
*   `jfieldID GetStaticFieldID(jclass cls, const char *name, const char *sig)`

`cls`参数是类对象的引用，定义了实例/静态字段。`name`参数是字段的名称。`sig`参数是字段的签名。您需要使用带有`–s`和`–private`选项的`javap`命令来获取类中定义的字段的签名。

您需要使用`Get<Xxx>Field()` JNI 函数来获取实例字段的值，使用`GetStatic<Xxx>Field()` JNI 函数来获取静态字段的值，其中`<Xxx>`是字段的类型，其值可以是`Boolean`、`Byte`、`Char`、`Double`、`Float`、`Int`、`Long`、`Short`或`Object`。`Set<Xxx>Field()`和`SetStatic<Xxx>Field()` JNI 函数允许您分别设置实例和静态字段的值。这些方法的声明如下，其中`<RRR>`是本地数据类型，例如，如果`<Xxx>`是`int`，则`<RRR>`是`jint`:

*   `<RRR> Get<Xxx>Field(jobject obj, jfieldID fieldID)`
*   `<RRR> GetStatic<Xxx>Field(jclass clazz, jfieldID fieldID)`
*   `void Set<Xxx>Field(jobject obj, jfieldID fieldID, <RRR> value)`
*   `void SetStatic<Xxx>Field(jclass clazz, jfieldID fieldID, <RRR> value)`

假设`obj`是`jobject`的一个实例(即一个 Java 对象引用)`cls`是它的类引用。在由`cls`表示的类中有两个类型为`int`的字段`num`和`count`。`num`字段是实例字段，而`count`字段是静态字段。以下代码片段显示了如何在本机代码中访问这两个字段并将它们的值递增 1:

`// Get the field ID of num and count fields`

`jfieldID numFieldId = env->GetFieldID(cls, "num", "I");`

`jfieldID countFieldId = env->GetStaticFieldID(cls, "count", "I");`

`// Get the field values`

`jint numValue = env->GetIntField(obj, numFieldId);`

`jint countValue = env->GetStaticIntField(cls, countFieldId);`

`// Increment the values by 1 and set them back to the fields`

`numValue = numValue + 1;`

`countValue = countValue + 1;`

`env->SetIntField(obj, numFieldId, numValue);`

`env->SetStaticIntField(cls, countFieldId, countValue);`

在本机代码中使用 Java 对象/类的方法的步骤类似于使用它们的字段。在访问方法之前，您需要获取方法的方法 ID。您可以使用`GetMethodID()`和`GetStaticMethodID(`JNI 函数来分别获取实例方法和静态方法的方法 ID。他们的声明如下:

*   `jmethodID GetMethodID(jclass clazz, const char *name, const char *sig)`
*   `jmethodID GetStaticMethodID(jclass clazz, const char *name, const char *sig)`

该方法的`name`是它的简单名称，可以使用带有`–s`和`–private`选项的`javap`命令来获得它的签名。下面的代码片段展示了如何从一个 Java 类的几个方法中获取方法 ID，假设`cls`表示类对象引用:

`jmethodID methodID`

`// Method is "void objectCallBack()"`

`methodID = env->GetMethodID(cls, "objectCallBack", "()V");`

`// Method is "static void classCallBack()"`

`methodID = env->GetStaticMethodID(cls, "classCallBack", "()V");`

`// Method is "int getLength(String str)"`

`methodID = env->GetMethodID(cls, "getLength", "(Ljava/lang/String;)I");`

`// Method is "int[] increment(int[], int)"`

`methodID = env->GetMethodID(cls, "increment", "([II)[I");`

调用实例或`static`方法很容易。您需要使用对象/类、方法 ID 和方法参数(如果有的话)来调用方法。您可以使用以下任何方法来调用对象的实例方法:

*   `<RRR> Call<Xxx>Method(jobject obj, jmethodID methodID, arg1, arg2...)`
*   `<RRR> Call<Xxx>MethodA(jobject obj, jmethodID methodID, const jvalue *args)`
*   `<RRR> Call<Xxx>MethodV(jobject obj, jmethodID methodID, va_list args)`

这里，方法名中的`<Xxx>`是该方法的返回类型，可以是`Boolean`、`Byte`、`Char`、`Double`、`Float`、`Int`、`Long`、`Short`、`Object`或`Void`。`<RRR>`是方法的返回类型，根据对应的`<Xxx>`值，可以是`jboolean`、`jbyte`、`jchar`、`jdouble`、`jfloat`、`jint`、`jlong`、`jshort, jobject`或`void`。`Call<Xxx>Method()`、`Call<Xxx>MethodA()`和`Call<Xx>MethodV()`之间的区别在于您希望如何将参数传递给方法。`Call<Xxx>Method()`方法允许您将参数作为逗号分隔的列表传递给方法。`Call<Xxx>MethodA()`方法允许您将参数作为`jvalue`类型的数组传递给方法。`Call<Xxx>MethodV()`方法允许您将参数作为`va_list`传递给一个方法。以下代码片段显示了如何调用实例方法，假设`obj`是`jobject`类型的引用，方法 ID 是`methodID`:

`// Method is "void m1()"`

`env->CallVoidMethod(obj, methodID);`

`// Method is "void m2(int a)"`

`env->CallVoidMethod(obj, methodID, 109);`

`// Method is "int m2(double a)"`

`jint value = env->CallIntMethod(obj, methodID, 109.23);`

调用静态方法类似于调用实例方法。你需要使用一个类对象引用来调用一个静态方法。您需要使用下列 JNI 函数之一来调用静态方法。注意，用于调用`static`方法的 JNI 函数名包含单词`Static`。

*   `<RRR> CallStatic<Xxx>Method(jclass cls, jmethodID methodID, arg1, arg2...)`
*   `<RRR> CallStatic<Xxx>MethodA(jclass cls, jmethodID methodID, jvalue *args)`
*   `<RRR> CallStatic<Xxx>MethodV(jclass cls, jmethodID methodID, va_list args)`

JNI 允许您从对象的类层次结构中的任何类调用对象的实例方法。当你使用一个`Call<Xxx>Method()`函数时，它使用对象的类来调用方法。考虑以下类层次结构:

`// A.java`

`package com.jdojo.jni;`

`public class A {`

`public int m1() {`

`return 1;`

`}`

`}`

`// B.java`

`package com.jdojo.jni;`

`public class B extends A {`

`@Override`

`public int m1() {`

`return 3;`

`}`

`}`

`// C.java`

`package com.jdojo.jni;`

`public class C extends B {`

`@Override`

`public int m1() {`

`return 3;`

`}`

`}`

类`B`和`C`覆盖了`m1()`方法。如果您使用`CallIntMethod()`调用类`C`的对象的`m1()`方法，它将调用类`C`中的`m1()`方法并返回 3。JNI 允许您使用类`C`的对象调用类`A`或类`B`中的`m1()`方法。要从超类中调用对象的方法，需要使用以下 JNI 方法之一:

*   `<RRR> CallNonvirtual<Xxx>Method(jobject obj, jclass cls, jmethodID methodID, arg1, arg2...)`
*   `<RRR> CallNonvirtual<Xxx>MethodA(jobject obj, jclass cls, jmethodID methodID, const jvalue *args)`
*   `<RRR> CallNonvirtual<Xxx>MethodV(jobject obj, jclass cls, jmethodID methodID, va_list args)`

您需要在这些版本的方法中使用对象及其类的引用。必须使用需要调用该方法的类来获取`methodID`。例如，下面的代码片段在类`C`的对象上调用类`B`的`m1()`方法。代码还创建了一个`C`类的对象。

`// Get the class references for B and C`

`jclass bCls = env->FindClass("com/jdojo/jni/B");`

`jclass cCls = env->FindClass("com/jdojo/jni/C");`

`// Get method ID for the constructor of class C`

`jmethodID cConstrctorID = env->GetMethodID(cCls, "<init>", "()V");`

`// Create an object of class C`

`jobject cObject = env->NewObject(cCls, cConstrctorID);`

`// Get the method ID for the m1() method in class B`

`jmethodID bMethodID = env->GetMethodID(bCls, "m1", "()I");`

`// Call the m1() method in class B using an object of class C`

`jint h = env->CallNonvirtualIntMethod(cObject, bCls, bMethodID);`

`// will print 2, which is returned from m1() in class B`

`printf("%i\n", h);`

让我们来看一个在本地代码中访问 Java 对象的字段和方法的完整示例。清单 8-10 包含 Java 代码，其中一个名为`JNIJavaObjectAccessTest`的类包含两个名为`num`和`count`的字段。它还包含两个名为`objectCallBack()`和`classCallBack()`的方法。您将访问本机代码中的字段和方法。它有一个名为`callBack()`的本地方法。`callBack() native`方法将`num`和`count`字段增加 1，并调用`objectCallBack() and classCallBack()`方法。在运行`JNIJavaObjectAccessTest`类之前，您需要生成`com_jdojo_jni_JNIJavaObjectAccessTest.h` C++头文件和共享库，包括来自`jnijavaobjectaccesstest.cpp`文件的内容，如清单 8-11 所示。

清单 8-10。从本机代码访问 Java 对象/类的字段和方法

`// JNIJavaObjectAccessTest.java`

`package com.jdojo.jni;`

`public class JNIJavaObjectAccessTest {`

`static {`

`System.loadLibrary("beginningjava");`

`}`

`private int num = 10;`

`private static int count = 1001;`

`public void objectCallBack() {`

`System.out.println("Inside objectCallBack() method.");`

`}`

`public static void classCallBack() {`

`System.out.println("Inside classCallBack() method.");`

`}`

`public native void callBack();`

`public int hashCode() {`

`return -9999;`

`}`

`public static void main(String[] args) {`

`JNIJavaObjectAccessTest test = new JNIJavaObjectAccessTest();`

`System.out.println("Before calling native method...");`

`System.out.println("num = " + test.num);`

`System.out.println("count = " + count);`

`// Call native method`

`test.callBack();`

`System.out.println("After calling native method...");`

`System.out.println("num = " + test.num);`

`System.out.println("count = " + count);`

`}`

`}`

`Before calling native method...`

`num = 10`

`count = 1001`

`Inside objectCallBack() method.`

`Inside classCallBack() method.`

`After calling native method...`

`num = 11`

`count = 1002`

清单 8-11。jnijavaobjectsaccesstest.cpp 文件的内容，该文件包含 JNIJavaObjectAccessTest 类中声明的 callBack()本机方法的 C++实现

`// jnijavaobjectaccesstest.cpp`

`#include <stdio.h>`

`#include <jni.h>`

`#include "com_jdojo_jni_JNIJavaObjectAccessTest.h"`

`JNIEXPORT void JNICALL Java_com_jdojo_jni_JNIJavaObjectAccessTest_callBack`

`(JNIEnv *env, jobject obj) {`

`jclass cls;`

`// Get the class reference for the object`

`cls = env->GetObjectClass(obj);`

`if (cls == NULL) {`

`return;`

`}`

`// Access the fields`

`jfieldID numFieldId = env->GetFieldID(cls, "num", "I");`

`jfieldID countFieldId = env->GetStaticFieldID(cls, "count", "I");`

`jint numValue = env->GetIntField(obj, numFieldId);`

`jint countValue = env->GetStaticIntField(cls, countFieldId);`

`numValue = numValue + 1;`

`countValue = countValue + 1;`

`env->SetIntField(obj, numFieldId, numValue);`

`env->SetStaticIntField(cls, countFieldId, countValue);`

`// Call the instance method`

`jmethodID instanceMethodID = env->GetMethodID(cls,`

`"objectCallBack",`

`"()V");`

`if (instanceMethodID != 0) {`

`env->CallVoidMethod(obj, instanceMethodID);`

`}`

`// Call the static method`

`jmethodID staticMethodID = env->GetStaticMethodID(cls,`

`"classCallBack",`

`"()V");`

`if (staticMethodID != 0) {`

`env->CallStaticVoidMethod(cls, staticMethodID);`

`}`

`return;`

`}`

### 创建 Java 对象

JNI 允许您在不调用任何构造函数或调用特定构造函数的情况下，用本机代码创建 Java 对象。您需要使用`AllocObject()` JNI 函数为一个 Java 对象分配内存，而不需要调用它的任何构造函数。请注意，根据数据类型，所有实例字段都有默认值。使用`AllocObject()` JNI 函数时，实例字段不会被初始化，也不会调用实例初始化器。下面是用 Java 为一个类的对象分配内存的代码片段:

`jclass cls = get the class reference;`

`jobject obj = env->AllocObject(cls);`

`if (obj == NULL) {`

`// The object could not be created. Handle the error condition.`

`}`

通过使用下列 JNI 函数之一调用 Java 类的特定构造函数，可以创建 Java 对象。这些函数的不同之处仅在于如何传递构造函数的参数。

*   `jobject NewObject(jclass clazz, jmethodID methodID, arg1, arg2...)`
*   `jobject NewObjectA(jclass clazz, jmethodID methodID, const jvalue *args)`
*   `jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)`

`methodID`参数是您想要调用的构造函数的方法 ID。当您想要获取类的构造函数的方法 ID 时，有一个特殊的字符串用于方法名。你需要使用`<init>`或`$init$`作为构造函数的方法名。考虑清单 8-12 所示的名为`IntWrapper`的类的代码。

清单 8-12。一个用本地代码演示 Java 对象创建的示例类

`// IntWrapper.java`

`package com.jdojo.jni;`

`public class IntWrapper {`

`private int value = -1;`

`public IntWrapper() {`

`}`

`public IntWrapper(int value) {`

`this.value = value;`

`}`

`public int getValue() {`

`return value;`

`}`

`}`

您可以在本机 C++代码中获取对`IntWrapper`类的引用，如下所示:

`jclass wrapperCls = env->FindClass("com/jdojo/jni/IntWrapper");`

以下 C++代码在不调用构造函数的情况下为一个`IntWrapper`对象分配内存:

`jobject wrapperObject = env->AllocObject(wrapperCls);`

此时，`wrapperObject`存在于内存中，其实例字段`value`仍然具有默认值 0。如果您在此时调用`wrapperObject`上的`getValue()`方法，它将返回 0 而不是–1，正如您所料。

如果你想通过调用一个构造函数来创建一个 Java 类的对象，你需要使用`NewObject()` JNI 函数。下面的代码片段通过调用无参数构造函数创建了一个`IntWrapper`类的对象。构造函数的签名取决于它接受的参数的数量和类型。对于无参数构造函数，签名是`()V`。如果构造函数接受一个`int`参数，它的签名将是`(I)V`。您可以通过使用带有`–s`选项的`javap`命令来获得一个类的构造函数的签名。如果您还想包含`private`成员的签名，请使用带有`javap`的`–private`选项。

`// Get the method ID for the default constructor of class IntWrapper`

`jmethodID mid = env->GetMethodID(wrapperCls, "<init>", "()V");`

`// Create an object of class IntWrapper using the default constructor`

`jobject wrapperObject = env->NewObject(wrapperCls, mid);`

此时，如果在`wrapperObject`上调用`getValue()`方法，它将返回-1，这是`value`实例字段的初始值。当调用构造函数时，所有实例字段都被初始化。

下面的代码片段调用了第二个版本的`IntWrapper`类的构造函数，它接受一个`int`参数。它将 999 作为构造函数`IntWrapper(int value)`的参数值进行传递。

`// Get the method ID for the constructor for class IntWrapper`

`jmethodID wrapperConstrctorID = env->GetMethodID(wrapperCls, "<init>","(I)V");`

`// Create an object of class IntWrapper passing 999 to the constructor`

`jobject wrapperObject = env->NewObject(wrapperCls, wrapperConstrctorID, 999);`

此时，如果你调用`abcObject`上的`getValue()`方法，它将返回 999，这个值是在它创建的时候在它的构造函数中设置的。

Tip

`AllocObject()`和`NewObject()` JNI 函数只能用于创建非数组引用类型的对象。你需要使用`NewObjectArray()` JNI 函数来创建一个特定类型的数组。

## 异常处理

JNI 允许您处理本机代码中的异常。本机代码可以检测和处理由于调用 JNI 函数而在 JVM 中引发的异常。本机代码也可以抛出异常，该异常可以传播到 Java 代码。本机代码中的异常处理机制不同于 Java 代码。当 Java 代码中抛出异常时，控制权会立即转移到最近的能够处理异常的`catch`块。如果在本机代码执行过程中引发异常，本机代码将继续执行，异常将保持挂起状态，直到控制权返回给 Java 代码。一旦异常挂起，除了释放本机资源的函数之外，不应该执行任何其他 JNI 函数。有两种方法可以检测本机代码中的 JNI 函数调用是否导致了异常:

*   通过检查函数的特殊返回值
*   通过检查函数返回后是否出现异常

如果出现异常，一些 JNI 函数会返回一个特殊值。举个例子，如果你调用了`FindClass()` JNI 函数，没有找到类，那么可能会抛出四个异常中的任何一个:`ClassFormatError`、`ClassCircularityError`、`NoClassDefFoundError`或者`OutOfMemoryError`。如果抛出了四个异常中的任何一个，`FindClass()` JNI 函数将返回`NULL`作为特殊值。您应该在调用`FindClass()` JNI 函数后立即检查`NULL`的返回值，并编写代码来处理该异常。通常，您将控件返回给调用方，以便调用方可以处理异常，如下所示:

`jclass cls = env->FindClass("abc/xyz/NonExistentClass");`

`if (cls == NULL) {`

`/* Here, free up any resources you had held and return. Exception is pending at            this time. It will be thrown when the control returns to the Java code.`

`*/`

`return;`

`}`

在某些情况下，不可能从 JNI 函数返回一个特殊值来指示异常已经发生。假设您正在用本机代码访问一个 Java 数组，并且已经超出了该数组的边界。在这种情况下，JVM 抛出一个类型为`ArrayIndexOutOfBoundsException`的异常。你可以调用一个发生异常的 Java 对象的方法。在这种情况下，你需要在 JNI 函数调用后立即使用`ExceptionOccurred()`或`ExceptionCheck()` JNI 函数来检查是否有异常发生。这些函数具有以下特征:

*   `jthrowable ExceptionOccurred()`
*   `jboolean ExceptionCheck()`

如果在函数调用过程中发生异常，函数将返回该异常对象的引用。否则，它返回`NULL`。如果在函数调用过程中出现异常，`ExceptionCheck()`函数返回`JNI_TRUE`。否则返回`JNI_FALSE`。下面的代码片段演示了如何使用这些函数。你只需要使用两个功能中的一个，而不是同时使用两个。

`// Using method ExceptionOccurred()`

`// Call a JNI function, which may throw an exception`

`jthrowable e = env->ExceptionOccurred();`

`if (e != NULL) {`

`/* Free up any resources that you had held and return. Exception is pending at this`

`time. It will be thrown when the control returns to the Java code.`

`*/`

`return;`

`}`

`// Using method ExceptionCheck()`

`// Call a JNI function, which may throw an exception`

`jboolean gotException = env->ExceptionCheck();`

`if (gotException) {`

`/* Free up any resources that you had held and return. Exception is pending at`

`this time. It will be thrown when the control returns to the Java code.`

`*/`

`return;`

`}`

一旦检测到本机代码中发生的异常，您有三种选择:

*   清除异常并在本机代码中处理它。
*   将控制返回给 Java 代码，让 Java 代码处理异常。
*   清除异常，在本机代码中处理它，并从本机代码中抛出一个 Java 代码可以处理的新异常。

以下部分解释了处理异常的三种方式。

### 在本机代码中处理异常

您可以清除异常并在本机代码中处理异常情况。使用`ExceptionClear()` JNI 函数清除挂起的异常，如图所示:

`// Call a JNI function, which may throw an exception`

`jboolean gotException = env->ExceptionCheck();`

`if (gotException) {`

`// Clear the exception`

`env->ExceptionClear();`

`// Write some code to take care of the exceptional condition`

`}`

一旦清除了异常，该异常就不再处于挂起状态。

### 在 Java 代码中处理异常

您可以使用语句将控件返回给调用方，并让调用方处理异常，如下所示:

`// Call a JNI function, which may throw an exception`

`jboolean gotException = env->ExceptionCheck();`

`if (gotException) {`

`/* Free up any resources that you had held and return. Exception  is pending at this time. It will be thrown when the control returns to the caller.`

`*/`

`return;`

`}`

### 从本机代码引发新的异常

您可以在本机代码中处理该异常，清除该异常，并引发新的异常。请注意，从本机代码抛出异常并不会将控制权转移回 Java 代码。您必须编写代码，比如一个`return`语句，将控制权转移回 Java 代码，所以您抛出的异常是用 Java 处理的。您可以使用以下两个 JNI 函数之一在本机代码中引发异常。两个函数成功时返回零，失败时返回负整数。

*   `jint Throw(jthrowable obj)`
*   `jint ThrowNew(jclass clazz, const char *message)`

`Throw()`函数接受一个`jthrowable`对象。该函数接受异常的类引用和一条消息。下面的代码片段展示了如何使用`ThrowNew()`函数抛出一个`java.lang.Exception`:

`if (someErrorConditionIsTrue) {`

`jclass cls = env->FindClass("java/lang/Exception");`

`// Check for exception here (omitted)`

`env->ThrowNew(cls, "your error message goes here");`

`return;`

`}`

Tip

如果你想打印本机代码中异常的栈跟踪，你可以使用`ExceptionDescribe()` JNI 函数。它在标准错误上打印异常栈跟踪。如果想从本机代码中引发致命错误，可以使用`FatalError(const char *msg)` JNI 函数。函数不会返回，JVM 也不会从这个错误中恢复。Java 代码中声明的本机方法也可以像 Java 非本机方法一样使用`throws`子句。以下是 Java 类中有效的本机方法声明:

`public native int myMethod() throws Exception;`

## 创建 JVM 的实例

到目前为止，您已经看到了使用本机代码的 Java 应用程序。现在你可以看到相反的情况了。即使用 Java 代码的本机应用程序。为什么要使用本地应用程序中的 Java 代码？出于以下原因，您可能希望使用本机应用程序中的 Java 代码:

*   您可能已经有了一个用 Java 编写的应用程序，并且想要使用现有的代码。
*   Java 提供了一套丰富的类库。您可能希望在本机应用程序中利用 Java 类库。

JNI API 中允许您用本机代码创建和加载 JVM 的部分称为。JNI 允许您在本地应用程序中嵌入 JVM。也就是说，您可以从本地应用程序创建 JVM，并像在 Java 应用程序中一样使用 Java 类。用本机代码创建一个 JVM 只需要几行代码。您所需要做的就是准备要传递给 JVM 的初始参数，并调用`JNI_CreateJavaVM()`调用 API 函数来创建 JVM。

传递给 JVM 的初始参数是一个`JavaVMInitArgs`结构，定义如下:

`typedef struct JavaVMInitArgs {`

`jint version;`

`jint nOptions;`

`JavaVMOption *options;`

`jboolean ignoreUnrecognized;`

`} JavaVMInitArgs;`

`version`字段表示 JNI 版本，并且必须至少设置为 JNI 版本 1 2。`nOptions`字段被设置为您想要传递给 JVM 的选项的数量。选项字段是一个`JavaVMOption`结构的数组，定义如下:

`typedef struct JavaVMOption {`

`char *optionString;`

`void *extraInfo;`

`} JavaVMOption;`

如果`ignoreUnrecognized`设置为`JNI_TRUE`，则`JNI_CreateJavaVM()`功能将忽略未识别的选项。如果设置为`JNI_FALSE`，`JNI_CreateJavaVM()`函数一遇到未识别的选项就会返回`JNI_ERR`。

`JavaVMOption`结构中的`optionString`字段是一个字符串，它是默认平台编码中 JVM 选项的值。

`extraInfo`字段用于特殊类型的 JVM 参数。它代表一个用于重定向 JVM 消息的函数挂钩、一个 JVM 退出挂钩或一个 JVM 中止挂钩。`extraInfo`字段代表的挂钩类型取决于`optionString`字段的值。如果`optionString`字段的值为`vfprintf`、`exit`或`abort`，则`extraInfo`字段分别表示 JVM 消息重定向挂钩、JVM 退出挂钩或 JVM 中止挂钩。注意`vfprintf`钩子只将 JVM 消息重定向到钩子。它不会将`System.out`和`System.err`消息重定向到钩子。如果您在本机代码中设置了一个`vsprintf`钩子，并在 Java 代码中使用了`System.out/System.err`的`print()/println()`方法之一，那么这些消息将不会被重定向到您的`vfprintf`钩子。您需要使用`System`类的`setOut()`和`setErr()`方法来重定向`System.out`和`System.err`消息。JVM 的退出钩子在 JVM 正常终止时被调用，比如通过在 Java 代码中调用`System.exit(int exitCode)`方法。JVM 的中止钩子在 JVM 异常终止时被调用。下面的代码片段展示了如何用不同的 VM 钩子填充`extraInfo`字段。首先，定义三个函数作为三种类型的钩子。请注意，函数必须具有相同的签名，如以下代码片段所示:

`jint JNICALL jvmMsgRedirection_hook(FILE *stream, const char *format, va_list args) {`

`// You can log the VM message here.`

`// Let us just print the VM message on the standard output.`

`return vfprintf(stdout, format, args);`

`}`

`void JNICALL jvmExit_hook(jint code) {`

`// You can do some cleanup work here`

`printf("VM exited with exit code %i\n", code);`

`}`

`void JNICALL jvmAbort_hook() {`

`printf("VM was aborted\n");`

`}`

`JavaVMOption jvmOption[3];`

`// Add JVM hooks`

`options[0].optionString = "vfprintf";`

`options[0].extraInfo = jvmMsgRedirection_hook;`

`options[1].optionString = "exit";`

`options[1].extraInfo = jvmExit_hook;`

`options[2].optionString = "abort";`

`options[2].extraInfo = jvmAbort_hook;`

下面的代码片段展示了如何用 JVM 的初始参数填充一个`JavaVMInitArgs`结构。它只设置了两个参数，`java.class.path`和`java.lib.path`。如果需要，可以设置更多的 JVM 参数。

`// Populate the JVM options in JavaVMOption structure`

`const jint MAX_OPTIONS = 2; // will pass two arguments to the JVM`

`JavaVMOption options[MAX_OPTIONS];`

`// Our first argument is java.class.path (CLASSPATH for JVM)`

`options[0].optionString = "-Djava.class.path=.;c:\\myjni\\classes";`

`// Our second argument is java.library.path (PATH to find a shared library)`

`options[1].optionString = "-Djava.library.path=c:\\myjni\\libs";`

`// Populate JavaVMInitArgs structure with options details`

`JavaVMInitArgs vm_args;`

`vm_args.version  = JNI_VERSION_1_2;`

`vm_args.nOptions = MAX_OPTIONS;`

`vm_args.options  = options;`

`vm_args.ignoreUnrecognized = true;`

一旦在一个`JavaVMInitArgs`结构中准备好了 JVM 参数，就只需要一次 JNI 函数调用，就可以用本机代码创建一个 JVM 了。`JNI_CreateJavaVM()` JNI 函数接受三个参数。第一个参数是一个指向代表 JVM 的`JavaVM`结构的指针。第二个参数是一个指向`JNIEnv`结构的指针，它是 JNI 接口。第三个参数是 JVM 的初始参数。下面的代码片段展示了如何用本机代码创建 JVM。您需要检查`JNI_CreateJavaVM()`函数可能返回的任何错误。如果不能创建 JVM，它返回`JNI_ERR`。

`JNIEnv *env;`

`JavaVM *jvm;`

`long status;`

`status = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);`

`if (status == JNI_ERR) {`

`printf("Could not create VM. Exiting application...\n");`

`return 1;`

`}`

一旦获得了`JNIEnv`结构，就可以用它来查找一个类，创建该类的一个对象，并对该对象执行任何方法。事实上，它允许您使用 JNI 访问整个 JVM。

在使用完 JVM 之后，您需要销毁它。

`// Destroy JVM`

`jvm->DestroyJavaVM();`

清单 8-13 包含了一个带有静态方法`printMsg()`的`EmbeddedJVMJNI`类的代码，用于在标准输出中打印一条消息。稍后，您将使用本机代码创建一个 JVM，并调用`printMsg()`方法。

清单 8-13。嵌入式 JVMJNI Java 类

`// EmbeddedJVMJNI.java`

`package com.jdojo.jni;`

`public class EmbeddedJVMJNI {`

`public static void printMsg(String msg) {`

`System.out.println(msg);`

`}`

`}`

清单 8-14 中列出的 C++控制台应用程序创建一个 JVM 并调用`EmbeddedJVMJNI`类的`printMsg()`方法。本书的源代码包含了`createjvm.cpp`文件中的 C++代码。该程序允许您将类路径指定为命令行参数。如果不指定类路径，它将使用当前目录作为类路径。

清单 8-14。在本地应用程序中创建 jvm 的 createjvm.cpp 文件的内容

`// createjvm.cpp`

`#include <jni.h>`

`#include <iostream>`

`#include <string>`

`int main(int argc, char **argv) {`

`std::string classpath("");`

`if (argc < 2) {`

`std::cout << "You did not pass the classpath."`

`<< " Using the current directory as the classpath.\n";`

`classpath = ".";`

`}`

`else {`

`classpath = argv[1];`

`}`

`std::string classpathOption("-Djava.class.path=");`

`classpathOption = classpathOption + classpath;`

`// Pass the classpath as an argument to the JVM`

`const jint MAX_OPTIONS = 1;`

`JavaVMOption options[MAX_OPTIONS];`

`options[0].optionString = (char *)(classpathOption.c_str());;`

`// Prepare the JVM initial arguments`

`JavaVMInitArgs vm_args;`

`vm_args.version = JNI_VERSION_1_2;`

`vm_args.nOptions = MAX_OPTIONS;`

`vm_args.options = options;`

`vm_args.ignoreUnrecognized = true;`

`// Create the JVM`

`JavaVM *jvm;`

`JNIEnv *env;`

`long status = JNI_CreateJavaVM(&jvm, (void**) &env, &vm_args);`

`if (status == JNI_ERR) {`

`std::cout << "Could not create VM. Exiting application...\n";`

`return 1;`

`}`

`const char *className = "com/jdojo/jni/EmbeddedJVMJNI";`

`jclass cls = env->FindClass(className);`

`if (cls == NULL) {`

`// Print exception stack trace and destroy the JVM`

`env->ExceptionDescribe();`

`jvm->DestroyJavaVM();`

`return 1;`

`}`

`if (cls != NULL) {`

`jmethodID mid = env->GetStaticMethodID(cls, "printMsg",`

`"(Ljava/lang/String;)V");`

`if (mid != NULL) {`

`jstring m = env->NewStringUTF("Hello from C++...\n");`

`env->CallStaticVoidMethod(cls, mid, m);`

`if (env->ExceptionCheck()) {`

`env->ExceptionDescribe();`

`env->ExceptionClear();`

`}`

`}`

`}`

`// Destroy JVM`

`jvm->DestroyJavaVM();`

`return 0;`

`}`

您需要将`createjvm.cpp`文件编译成可执行文件。当你编译这个程序的时候，你需要提供`jvm.lib`文件的路径，这个文件安装在 Windows 的`JAVA_HOME\lib`目录下。假设您已经在 Windows 上的`C:\java8`中安装了 JDK，您可以使用下面的命令在 Windows 上创建`createjvm.exe`文件:

`C:> g++ -IC:/java8/include -IC:/java8/include/win32`

`-o createjvm`

`createjvm.cpp`

`C:/java8/lib/jvm.lib`

该命令在一行中输入，但为了便于阅读，它显示在多行中。该命令的前两行与您之前用来创建共享库的行相同。`–o`选项用于指定可执行输出文件名，在本例中是`createjvm`。最后一个选项是需要静态链接的名为`jvm.lib`的库的路径。

下面的命令将在 Linux 上创建一个`createjvm`可执行文件，假设您已经在`/home/ksharan/java8`目录中安装了 JDK:

`$ g++ -I/home/ksharan/java8/include -I/home/ksharan/java8/include/linux`

`-o createjvm`

`createjvm.cpp`

`/home/ksharan/java8/jre/lib/i386/client/libjvm.so`

在 Windows 上，当你运行`createjvm.exe`应用程序时，它会寻找`jvm.dll`共享库，这个库在`JRE_HOME\bin\client`目录中。您需要在`PATH`环境变量中包含包含`jvm.dll`文件的目录。

`C:\> SET PATH=C:\java8\bin\client;%PATH%`

`C:\> createjvm C:\myclasses`

`Hello from C++...`

当您运行`createjvm.exe`文件时，您可能会得到以下错误:

`Exception in thread "main" java.lang.NoClassDefFoundError: com/jdojo/jni/EmbeddedJVMJNI`

`Caused by: java.lang.ClassNotFoundException: com.jdojo.jni.EmbeddedJVMJNI`

`...`

该错误表明类路径设置不正确，JVM 无法找到`EmbeddedJVMJNI`类。使用上面的命令，在`C:\myclasses`目录中搜索该类。要修复这个错误，要么使用正确的类路径参数运行`createjvm`应用程序，要么将`com\jdojo\jni\EmbeddedJVMJNI.class`文件移动到`C:\myclasses`目录中。

在 Linux 上，您需要设置`LD_LIBRARY_PATH`，这样当 createjvm 应用程序运行时，就会加载`libjvm.so`文件。您可以按如下方式进行设置:

`$ export LD_LIBRARY_PATH=/home/ksharan/java8/jre/lib/i386/client`

现在，您已经准备好运行 createjvm 应用程序，如下所示:

`$ ./createjvm /home/ksharan/myclasses`

`Hello from C++...`

该命令将在`/home/ksharan/myclasses`目录中搜索`com/jdojo/jni/EmbeddedJVMJNI.class`。

## 本机代码中的同步

JNI 提供了两个名为`MonitorEnter()`和`MonitorExit()`的函数，用于在多线程环境中同步对本地代码的访问。这些函数被串联使用，它们的使用等同于在 Java 代码中使用`synchronized`关键字。这些函数声明如下:

*   `jint MonitorEnter(jobject obj)`
*   `jint MonitorExit(jobject obj)`

如果成功，两个函数都返回 0 ( `JNI_OK`在`jni.h`头文件中被定义为 0)，如果失败，则返回负数。您必须检查它们的返回值，以正确处理代码同步。下面是使用同步的 Java 代码示例:

`Object someObject = get the reference of a java object;`

`// Other logic goes here`

`synchronized(someObject) {`

`// Synchronized code goes here`

`}`

等效的本机代码如下:

`jobject someObject = get the reference of a java object;`

`// Other logic goes here`

`jint enterStatus = env->MonitorEnter(someObject);`

`if (enterStatus != JNI_OK) {`

`// Handle the error condition here`

`}`

`// Synchronized code goes here`

`jint exitStatus = env->MonitorExit(someObject);`

`if (exitStatus != JNI_OK ) {`

`// Handle the error condition here`

`}`

Java `wait()`和`notify()`没有对等的 JNI 函数来帮助线程同步。然而，您总是可以从本机代码中调用这两个 Java 方法。

## 摘要

Java 本地接口(Java Native Interface，JNI)是一种编程接口，它有助于 Java 程序与用 C、C++、FORTRAN 等本地语言编写的程序之间的交互。JNI 使得在 Java 代码中使用一个方法并在本地语言(如 C 或 C++)中实现该方法成为可能。JNI 还使得将 JVM 嵌入到可以访问 Java 类库的本地应用程序中成为可能。

在 Java 中使用但在本地语言中实现的方法称为本地方法，使用关键字`native`声明。Java 中的`native`方法没有主体。它的主体用分号表示。`native`方法的实现是用本地语言编写的，并被编译成一个共享库。使用`java.library.path` JVM 选项使共享库对 Java 运行时可用，或者它们位于 PATH 环境变量中。

`javah`命令用于生成本地语言所需的头文件。它将包含本机方法的类的完全限定类名作为参数。

JNI 定义了 Java 和本机代码中使用的数据类型之间的映射。比如`jboolean`、`jchar`、`jint`等。相当于本地的`boolean`、`char`、`int`等。Java 中的原始数据类型。本机代码中的`jclass`、`jobject`和`jstring`类型映射到 Java 中的`Class`、`Object`和`String`类。

JNI 提供了一些函数来促进字符串的 Java 表示和本机表示之间的转换。它还提供了特殊的函数来访问 Java 数组和数组元素的长度。

JNI 还允许您在本机代码中创建 Java 对象。您还可以访问本机代码中 Java 对象的字段和方法。

Java 中的`Throwable`类型被映射到本机代码中的类型`jthrowable`。JNI 允许您处理本机代码中的异常。本机代码可以检测和处理由于调用 JNI 函数而在 JVM 中引发的异常。本机代码也可以抛出异常，该异常可以传播到 Java 代码。如果在本机代码执行过程中引发异常，本机代码将继续执行，异常将保持挂起状态，直到控制权返回给 Java 代码。

JNI 允许您将 JVM 嵌入到本地应用程序中，从而为它们提供对丰富的 Java 类库的完全访问权。JNI API 中允许您用本机代码创建和加载 JVM 的部分称为调用 API。JVM 是使用调用 API 提供的`JNI_CreateJavaVM()`方法在本机代码中创建的。

在多线程环境中，可以通过使用两个名为`MonitorEnter()`和`MonitorExit()`的 JNI 函数来同步对本机代码中关键部分的访问。这些函数被串联使用，它们的使用等同于在 Java 代码中使用`synchronized`关键字。