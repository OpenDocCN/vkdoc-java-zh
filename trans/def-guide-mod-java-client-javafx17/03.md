# 3.属性和绑定

作者:韦琪高

> *天道之徒具有生命力和毅力。*

> *与此相对应的*

> *上位者不停地保持自己的生命力。*
> 
> —易经

前两章向您介绍了客户端 Java 的概况和 JavaFX 的基础知识。在本章中，我们将深入探讨绑定和属性框架，这是 JavaFX 的一部分，它与声明性 UI 语言 FXML 和可视化 UI 设计器场景生成器一起，使 JavaFX 桌面和移动客户端应用程序编写起来优雅而愉快。

`javafx.base`模块是 JavaFX 属性和绑定框架的主页。它导出以下包:

*   `javafx.beans`

*   `javafx.beans.binding`

*   `javafx.beans.property`

*   `javafx.beans.property.adapter`

*   `javafx.beans.value`

*   `javafx.collections`

*   `javafx.collections.transformation`

*   `javafx.event`

*   `javafx.util`

*   `javafx.util.converter`

我们将关注`javafx.beans`和`javafx.collections`包及其子包。

## 关键概念

属性和绑定 API 的核心是一组接口，它们赋予我们讨论的两个核心概念以生命:*属性*和*绑定*。图 [3-1](#Fig1) 显示了这些接口。

![../images/468104_2_En_3_Chapter/468104_2_En_3_Fig1_HTML.jpg](../images/468104_2_En_3_Chapter/468104_2_En_3_Fig1_HTML.jpg)

图 3-1

JavaFX 属性和绑定框架的关键接口

### 可观察和无效监听器

通过`Observable`接口，您可以将`InvalidationListener`注册到`Property`或`Binding`，这样当`Property`或`Binding`变为*无效*时，您将会收到通知。如果调用其`set()`或`setValue()`方法时使用的值不同于其当前保存的值，则`Property`会失效。当`Binding`的`invalidate()`方法被调用或其依赖项失效时，该`Binding`将失效。`InvalidationListener`中的回调方法具有以下签名，使您可以访问对`Observable`对象的引用:

```java
void invalidated(Observable observable);

```

Note

如果连续多次使用相同的值调用 setters，JavaFX 中的属性只会触发一次失效事件。

### ObservableValue 和 ChangeListener

`ObservableValue`接口允许您用`Property`或`Binding`注册`ChangeListener` s，这样当`Property`或`Binding`的值从一个值变为另一个值时，您会收到通知。通知以回调方法的形式出现在`ChangeListener`中，带有以下签名，允许您访问其值已更改的属性或绑定的引用，以及旧值和新值:

```java
void changed(ObservableValue<? extends T> observable,
             T oldValue, T newValue)

```

Note

`InvalidationListener`和`ChangeListener`的弱版本，以及本章后面介绍的一些其他监听器，有助于避免内存泄漏。

### 可写值和只读属性

`WritableValue`接口向一个`Property`提供了`setValue()`方法。`ReadOnlyProperty`接口向一个`Property`注入两个方法:一个`getBean()`方法返回属性的持有者，一个`getName()`方法返回属性的描述性名称。如果属性不是更大对象的一部分，或者描述性名称不重要，这两种方法都可能返回 null。

### JavaFX 属性

随着所有预备工作的结束，我们终于可以看看`Property`界面了。它提供了五种方法:

```java
void bind(ObservableValue<? extends T> observable);
void unbind();
boolean isBound();
void bindBidirectional(Property<T> other);
void unbindBidirectional(Property<T> other);

```

`bind()`方法在`Property`和`ObservableValue`之间建立了一个*单向绑定*。`unbind()`方法释放绑定。并且`isBound()`方法报告单向绑定是否有效。一旦生效，单向绑定将建立前者对后者的*依赖关系*。`Property`上的`set()`或`setValue()`方法会抛出一个`RuntimeException`，`get()`或`getValue()`方法会返回`ObservableValue`的值。

`bindBidirectional()`方法在两个`Property`对象之间建立了一个*双向绑定*。`unbindBidirectional()`方法释放它。一旦生效，在任一属性上调用`set()`或`setValue()`将导致两个对象的值都被更新。

Caution

每个`Property`一次最多可以有一个活动的单向绑定。它可以有任意多的双向绑定。`isBound()`方法只适用于单向绑定。用不同的`ObservableValue`第二次调用`bind()`会解除之前的绑定并用新的替换它。

总结一下我们到目前为止所讨论的内容，我们看到一个`Property`可以保存一个值，当它的值改变时可以通知其他人，并且可以绑定到其他人以反映绑定对象的值。清单 [3-1](#PC4) 展示了一个运行这些功能的愚蠢程序。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.InvalidationListener;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.value.ChangeListener;
public class PropertiesExample {
    private static IntegerProperty i1;
    public static void main(String[] args) {
        createProperty();
        addAndRemoveInvalidationListener();
        addAndRemoveChangeListener();
        bindAndUnbindOnePropertyToAnother();
    }
    private static void createProperty() {
        System.out.println();
        i1 = new SimpleIntegerProperty(1024);
        System.out.println("i1 = " + i1);
        System.out.println("i1.get() = " + i1.get());
        System.out.println("i1.getValue() = "
                + i1.getValue());
    }
    private static void addAndRemoveInvalidationListener() {
        System.out.println();
        final InvalidationListener invalidationListener =
                observable -> {
                    System.out.println(
                            "The observable has been " +
                                    "invalidated: " +
                                    observable + ".");
                };
        i1.addListener(invalidationListener);
        System.out.println("Added invalidation listener.");
        System.out.println("Calling i1.set(2048).");
        i1.set(2048);
        System.out.println("Calling i1.setValue(3072).");
        i1.setValue(3072);
        i1.removeListener(invalidationListener);
        System.out.println("Removed invalidation listener.");
        System.out.println("Calling i1.set(4096).");
        i1.set(4096);
    }
    private static void addAndRemoveChangeListener() {
        System.out.println();
        final ChangeListener<Number> changeListener =
                (observableValue,
                 oldValue,
                 newValue) -> {
                    System.out.println(
                            "The observableValue has " +
                                    "changed: oldValue = " +
                                    oldValue +
                                    ", newValue = " +
                                    newValue);
                };
        i1.addListener(changeListener);
        System.out.println("Added change listener.");
        System.out.println("Calling i1.set(5120).");
        i1.set(5120);
        i1.removeListener(changeListener);
        System.out.println("Removed change listener.");
        System.out.println("Calling i1.set(6144).");
        i1.set(6144);
    }

    private static void bindAndUnbindOnePropertyToAnother() {
        System.out.println();
        IntegerProperty i2 = new SimpleIntegerProperty(0);
        System.out.println("i2.get() = " + i2.get());
        System.out.println("Binding i2 to i1.");
        i2.bind(i1);
        System.out.println("i2.get() = " + i2.get());
        System.out.println("Calling i1.set(7168).");
        i1.set(7168);
        System.out.println("i2.get() = " + i2.get());
        System.out.println("Unbinding i2 from i1.");
        i2.unbind();
        System.out.println("i2.get() = " + i2.get());
        System.out.println("Calling i1.set(8192).");
        i1.set(8192);
        System.out.println("i2.get() = " + i2.get());
    }
}

Listing 3-1PropertiesExample.java

```

Note

本节的源代码可以在本书随附的源代码包的第 3 章中找到。它被组织成一个带有子项目的 Gradle 项目，每个子项目对应一个示例。

这个程序是不言自明的，你几乎可以在脑海中想象它是如何执行的。我们在程序中使用了一个抽象类`IntegerProperty`及其具体实现`SimpleIntegerProperty`。它保存一个原始的`int`值。

清单 [3-2](#PC5) 展示了工作中的双向绑定。

```java
package org.modernclients.propertiesandbindings;

import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
public class BidirectionalBindingExample {
    public static void main(String[] args) {
        System.out.println("Constructing two StringProperty" +
                " objects.");
        StringProperty prop1 = new SimpleStringProperty("");
        StringProperty prop2 = new SimpleStringProperty("");
        System.out.println("Calling bindBidirectional.");
        prop2.bindBidirectional(prop1);
        System.out.println("prop1.isBound() = " +
                prop1.isBound());
        System.out.println("prop2.isBound() = " +
                prop2.isBound());
        System.out.println("Calling prop1.set(\"prop1" +
                " says: Hi!\")");
        prop1.set("prop1 says: Hi!");
        System.out.println("prop2.get() returned:");
        System.out.println(prop2.get());
        System.out.println("Calling prop2.set(prop2.get()" +
                " + \"\\nprop2 says: Bye!\")");
        prop2.set(prop2.get() + "\nprop2 says: Bye!");
        System.out.println("prop1.get() returned:");
        System.out.println(prop1.get());
    }
}

Listing 3-2BidirectionalBindingExample.java

```

## 创建绑定

在上一节中，我们探讨了 JavaFX 属性和绑定框架的关键接口。我们还学习了关于`Property`物体的基础知识。在这一节中，我们拿起框架的另一半并检查`Binding` s。

### JavaFX 绑定

`Binding`接口提供了四种方法:

```java
boolean isValid();
void invalidate();
ObservableList<?> getDependencies();
void dispose();

```

一个`Binding`的*有效性*可以用`isValid()`方法查询，用`invalidate()`方法设置。它有一个可以通过`getDependencies()`方法获得的*依赖项*的列表。最后，`dispose()`方法发出信号表示`Binding`将不再被使用，它所使用的资源可以被清理。

因此，`Binding`表示具有多个依赖关系的*单向绑定。每个依赖都可以向`Binding`发送失效事件，使其失效。当通过`get()`或`getValue()`调用查询`Binding`的值时，如果它被无效，它的值将根据依赖关系的值重新计算。该值将被缓存并用于后续的值查询，直到`Binding`再次失效。这种懒惰的值评估是 JavaFX 属性和绑定框架高效的原因。附加一个`ChangeListener`强制急切评估。*

由于一个绑定可以用作另一个绑定的依赖项，因此可以构建复杂的绑定树。这是 JavaFX 属性和绑定框架强大功能的另一个来源。

Caution

与任何复杂的结构一样，必须小心避免性能下降和行为错误，尤其是在高负载的情况下。

与属性不同，框架不提供具体的绑定类。因此，所有绑定都是自定义绑定，有几种方法可以创建它们:

*   扩展一个抽象基类，比如`DoubleBinding`

*   在实用程序类`Bindings`中使用工厂方法

*   在属性和绑定类中使用 fluent API 方法

### 通过直接扩展创建绑定

清单 [3-3](#PC7) 展示了一个程序，它通过直接扩展`DoubleBinding`来创建一个绑定，并使用它来计算矩形的面积。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
public class DirectExtensionExample {
    public static void main(String[] args) {
        System.out.println("Constructing x with value 2.0.");
        final DoubleProperty x =
                new SimpleDoubleProperty(null, "x", 2.0);
        System.out.println("Constructing y with value 3.0.");
        final DoubleProperty y =
                new SimpleDoubleProperty(null, "y", 3.0);
        System.out.println("Creating binding area" +
                " with dependencies x and y.");
        DoubleBinding area = new DoubleBinding() {
            {
                super.bind(x, y);
            }
            @Override
            protected double computeValue() {
                System.out.println("computeValue()" +
                        " is called.");
                return x.get() * y.get();
            }
        };
        System.out.println("area.get() = " + area.get());
        System.out.println("area.get() = " + area.get());
        System.out.println("Setting x to 5");
        x.set(5);
        System.out.println("Setting y to 7");
        y.set(7);
        System.out.println("area.get() = " + area.get());
    }
}

Listing 3-3DirectExtensionExample.java

```

这里，我们通过覆盖其唯一的抽象方法`computeValue()`来扩展`DoubleBinding`类，以计算边长为`x`和`y`的矩形的面积。我们还调用超类的`bind()`方法来使属性`x`和`y`成为我们的依赖。

运行该程序会将以下内容打印到控制台:

```java
Constructing x with value 2.0.
Constructing y with value 3.0.
Creating binding area with dependencies x and y.
computeValue() is called.
area.get() = 6.0
area.get() = 6.0
Setting x to 5
Setting y to 7
computeValue() is called.
area.get() = 35.0

```

注意，当我们连续两次调用`area.get()`时，`computeValue()`只被调用一次。

## 特定于类型的专门化

在我们进入下一个创建绑定的方法之前，我们需要向您提供一些关于键接口的一般性质及其特定于类型的专门化的细节。

本章前面的例子包括像`IntegerProperty`、`StringProperty`和`DoubleBinding`这样的类。这些是通用类型`Property<T>`和`Bindings<T>`的专门类。由于 Java 的原始类型和引用类型二分法，直接使用泛型类型，比如`Property<Integer>`，同时处理原始值会导致装箱和拆箱效率低下。为了减少这种成本，泛型类型的特定于类型的专门化被构造为基元`boolean`、`int`、`long`、`float`和`double`值，以这样的方式，当它们的`get()`或`set()`方法被调用时，以及当进行内部计算时，基元类型从不被装箱和取消装箱。出于一致性原因，也为`String`和`Object`引用类型构建了类似的专门化。这说明了`BooleanProperty`、`IntegerProperty`、`LongProperty`、`FloatProperty`、`DoubleProperty`、`StringProperty`和`ObjectProperty`类的存在。

Caution

不要被名称`IntegerProperty`所迷惑，以为它是一个`Integer`对象的容器。真的不是。它是原始`int`价值观的容器。其他基于原语的类也是如此。

这些特定于类型的专门化的另一个方面是使用`Number`作为类型参数来派生数字原语类型的专门化。一个实际的结果是，任何数字属性都可以在任何其他数字属性或绑定上调用`bind()`。清单 [3-4](#PC9) 显示了一个说明这一点的程序。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.FloatProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.LongProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleFloatProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleLongProperty;
public class NumericPropertiesExample {
    public static void main(String[] args) {
        IntegerProperty i =
                new SimpleIntegerProperty(null, "i", 1024);
        LongProperty l =
                new SimpleLongProperty(null, "l", 0L);
        FloatProperty f =
                new SimpleFloatProperty(null, "f", 0.0F);
        DoubleProperty d =
                new SimpleDoubleProperty(null, "d", 0.0);
        System.out.println("Constructed numerical" +
                " properties i, l, f, d.");
        System.out.println("i.get() = " + i.get());
        System.out.println("l.get() = " + l.get());
        System.out.println("f.get() = " + f.get());
        System.out.println("d.get() = " + d.get());
        l.bind(i);
        f.bind(l);
        d.bind(f);
        System.out.println("Bound l to i, f to l, d to f.");
        System.out.println("i.get() = " + i.get());
        System.out.println("l.get() = " + l.get());
        System.out.println("f.get() = " + f.get());
        System.out.println("d.get() = " + d.get());
        System.out.println("Calling i.set(2048).");
        i.set(2048);
        System.out.println("i.get() = " + i.get());
        System.out.println("l.get() = " + l.get());
        System.out.println("f.get() = " + f.get());
        System.out.println("d.get() = " + d.get());
        d.unbind();
        f.unbind();
        l.unbind();
        System.out.println("Unbound l to i, f to l, d to f.");
        f.bind(d);
        l.bind(f);
        i.bind(l);
        System.out.println("Bound f to d, l to f, i to l.");
        System.out.println("Calling d.set(10000000000L).");
        d.set(10000000000L);
        System.out.println("d.get() = " + d.get());
        System.out.println("f.get() = " + f.get());
        System.out.println("l.get() = " + l.get());
        System.out.println("i.get() = " + i.get());
    }
}

Listing 3-4NumericPropertiesExample.java

```

运行此应用程序会产生以下输出:

```java
Constructed numerical properties i, l, f, d.
i.get() = 1024
l.get() = 0
f.get() = 0.0
d.get() = 0.0
Bound l to i, f to l, d to f.
i.get() = 1024
l.get() = 1024
f.get() = 1024.0
d.get() = 1024.0
Calling i.set(2048).
i.get() = 2048
l.get() = 2048
f.get() = 2048.0
d.get() = 2048.0
Unbound l to i, f to l, d to f.
Bound f to d, l to f, i to l.
Calling d.set(10000000000L).
d.get() = 1.0E10
f.get() = 1.0E10
l.get() = 10000000000
i.get() = 1410065408

```

## 绑定中的工厂方法

`Bindings`类包含 200 多个工厂方法，这些方法用现有的可观察值和常规值进行新的绑定。这些方法被重载以考虑参数类型的无数组合。

`add()`、`subtract()`、`multiply()`和`divide()`方法显而易见，用两个数值创建一个新的数值绑定，其中至少有一个是可观察的值。清单 [3-5](#PC11) 中的程序演示了它们的用法。它使用以下公式计算带有顶点(`x1`、`y1`、`x2`、`y2`、`x3`、`y3`)的三角形的面积

`area = (x1*y2 + x2*y3 + x3*y1 – x1*y3 – x2*y1 – x3*y2)/2`

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.NumberBinding;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
public class TriangleAreaExample {
    public static void main(String[] args) {
        IntegerProperty x1 = new SimpleIntegerProperty(0);
        IntegerProperty y1 = new SimpleIntegerProperty(0);
        IntegerProperty x2 = new SimpleIntegerProperty(0);
        IntegerProperty y2 = new SimpleIntegerProperty(0);
        IntegerProperty x3 = new SimpleIntegerProperty(0);
        IntegerProperty y3 = new SimpleIntegerProperty(0);
        final NumberBinding x1y2 = Bindings.multiply(x1, y2);
        final NumberBinding x2y3 = Bindings.multiply(x2, y3);
        final NumberBinding x3y1 = Bindings.multiply(x3, y1);
        final NumberBinding x1y3 = Bindings.multiply(x1, y3);
        final NumberBinding x2y1 = Bindings.multiply(x2, y1);
        final NumberBinding x3y2 = Bindings.multiply(x3, y2);
        final NumberBinding sum1 = Bindings.add(x1y2, x2y3);
        final NumberBinding sum2 = Bindings.add(sum1, x3y1);
        final NumberBinding diff1 =
                Bindings.subtract(sum2, x1y3);
        final NumberBinding diff2 =
                Bindings.subtract(diff1, x2y1);
        final NumberBinding determinant =
                Bindings.subtract(diff2, x3y2);
        final NumberBinding area =
                Bindings.divide(determinant, 2.0D);
        x1.set(0); y1.set(0);
        x2.set(6); y2.set(0);
        x3.set(4); y3.set(3);
        printResult(x1, y1, x2, y2, x3, y3, area);
        x1.set(1); y1.set(0);
        x2.set(2); y2.set(2);
        x3.set(0); y3.set(1);
        printResult(x1, y1, x2, y2, x3, y3, area);
    }
    private static void printResult(IntegerProperty x1,
                                    IntegerProperty y1,
                                    IntegerProperty x2,
                                    IntegerProperty y2,
                                    IntegerProperty x3,
                                    IntegerProperty y3,
                                    NumberBinding area) {
        System.out.println("For A(" +
                x1.get() + "," + y1.get() + "), B(" +
                x2.get() + "," + y2.get() + "), C(" +
                x3.get() + "," + y3.get() +
                "), the area of triangle ABC is " +
                area.getValue());
    }
}

Listing 3-5TriangleAreaExample.java

```

运行该程序会将以下内容打印到控制台:

```java
For A(0,0), B(6,0), C(4,3), the area of triangle ABC is 9.0
For A(1,0), B(2,2), C(0,1), the area of triangle ABC is 1.5

```

`Bindings`中的其他工厂方法包括逻辑运算符`and()`、`or()`和`not()`；数字运算符`min()`、`max()`、`negate()`；空测试操作符`isNull()`和`isNotNull()`；字符串运算符`length()`、`isEmpty()`和`isNotEmpty()`；以及关系运算符`equal()`、`equalIgnoreCase()`、`greaterThan()`、`graterThanOrEqual()`、`lessThan()`、`lessThanOrEqual()`、`notEqual()`、`notEqualIgnoreCase()`。那些方法的名字是自我描述的，它们都做你认为它们做的事情。例如，为了确保只有在选择了收件人并且输入的金额大于零时，才启用“汇款”按钮，我们可以编写

```java
sendBtn.disableProperty().bind(Bindings.not(
    Bindings.and(recipientSelected,
        Bindings.greaterThan(amount, 0.0))));

```

有一组名为`createDoubleBinding()`等的工厂方法，允许您从一个`Callable`和一组依赖项创建一个绑定。我们在清单 [3-3](#PC7) 中创建的`DoubleBinding`可以简化为

```java
DoubleBinding area = Bindings.createDoubleBinding(() -> {
      return x.get() * y.get();
}, x, y);

```

可以使用`convert()`、`concat()`和几个重载的`format()`方法将非字符串可观察值转换为可观察字符串值，将几个可观察字符串值连接在一起，并将可观察数值或日期值格式化为可观察字符串值。要在`Label`中显示温度值，我们可以使用以下绑定:

```java
tempLbl.textProperty().bind(Bindings.format("%2.1f \u00b0C", temperature));

```

随着 temperature 属性值的变化，温度的格式化字符串表示形式也随之变化。比如`temperature`为 37.5 时，标签会显示 37.5 C。

有一组名为`select()`和`selectInteger()`等的工厂方法作用于*JavaFX Bean*，这些 Java 类符合 Java FX Bean 约定。还有一些方法对*可观察集合*起作用，这些可观察集合不包含单个值，而是包含一个`List`、`Map`、`Set`或一个元素数组。我们将在本章后面的章节中介绍它们。

## 使用 Fluent API 创建绑定

流畅的 API 由一组协调的类组成，这些类的方法被设计成以这样一种方式链接在一起，即当大声读出方法链时，这些方法链以类似散文的句子描述它们做了什么。用于创建绑定的 fluent API 包含在`IntegerExpression`系列的类中。这些表达式类是属性类和绑定类的超类。因此，流畅的 API 方法很容易从熟悉的属性和绑定类中获得。通过浏览表达式类的 Javadocs，您可以对这些方法有所了解。总的来说，它们反映了`Bindings`类所能提供的。以下是使用 fluent API 构建的几个绑定示例:

```java
recipientSelected.and(amount.greaterThan(0.0)).not()
temperature.asString("%2.1f \u00b0C")

```

它们相当于我们在上一节中使用来自`Bindings`类的工厂方法构建的绑定。

这里值得指出的一个事实是，特定于类型的数值表达式的所有方法都是在返回类型为`NumberBinding`的`NumberExpression`基本接口中定义的，并且在具有相同参数签名但返回类型更特定的特定于类型的表达式类中被覆盖。这被称为*协变返回类型覆盖*，并且从 Java 5 开始就是 Java 语言的一个特性。这一事实的结果之一是，用 fluent API 构建的数字绑定比用`Bindings`类中的工厂方法构建的绑定有更多的特定类型。

清单 [3-6](#PC17) 显示了清单 [3-5](#PC11) 中三角形区域示例的流畅 API 版本。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.NumberBinding;
import javafx.beans.binding.StringExpression;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
public class TriangleAreaFluentExample {
    public static void main(String[] args) {
        IntegerProperty x1 = new SimpleIntegerProperty(0);
        IntegerProperty y1 = new SimpleIntegerProperty(0);
        IntegerProperty x2 = new SimpleIntegerProperty(0);
        IntegerProperty y2 = new SimpleIntegerProperty(0);
        IntegerProperty x3 = new SimpleIntegerProperty(0);
        IntegerProperty y3 = new SimpleIntegerProperty(0);
        final NumberBinding area = x1.multiply(y2)
                .add(x2.multiply(y3))
                .add(x3.multiply(y1))
                .subtract(x1.multiply(y3))
                .subtract(x2.multiply(y1))
                .subtract(x3.multiply(y2))
                .divide(2.0D);
        StringExpression output = Bindings.format(
                "For A(%d,%d), B(%d,%d), C(%d,%d)," +
                        " the area of triangle ABC is %3.1f",
                x1, y1, x2, y2, x3, y3, area);
        x1.set(0); y1.set(0);
        x2.set(6); y2.set(0);
        x3.set(4); y3.set(3);
        System.out.println(output.get());
        x1.set(1); y1.set(0);
        x2.set(2); y2.set(2);
        x3.set(0); y3.set(1);
        System.out.println(output.get());
    }
}

Listing 3-6TriangleAreaFluentExample.java

```

运行该程序会将以下内容打印到控制台:

```java
For A(0,0), B(6,0), C(4,3), the area of triangle ABC is 9.0
For A(1,0), B(2,2), C(0,1), the area of triangle ABC is 1.5

```

类`When`允许你在一个流畅的 API 中表达 if/then/else 逻辑。您可以使用构造函数或`Bindings`类中的`when()`工厂方法构造这个类的对象，并传入一个`ObservableBooleanValue`。在`When`对象上重载的`then()`方法返回一个嵌套的条件构建器类的对象，该类又重载了返回一个绑定对象的`otherwise()`方法。这允许您通过以下方式建立绑定:

```java
new When(condition).then(result).otherwise(alternative)

```

这里，`condition`是一个`ObservableBooleanValue`，`result`和`alternative`是类似的类型，可以是可观测的，也可以是不可观测的。最终绑定的类型类似于`result`和`alternative`的类型。

清单 [3-7](#PC21) 展示了这个 API 的使用示例。这里，我们使用 Heron 公式计算边长分别为`a`、`b`和`c`的三角形的面积

```java
area = sqrt(s * (s – a) * (s – b) * (s – c))

```

其中`s = (a + b + c) / 2`是半参数。回想一下，在三角形中，任何两条边的和都大于第三条边。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.When;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
public class HeronsFormulaExample {
    public static void main(String[] args) {
        DoubleProperty a = new SimpleDoubleProperty(0);
        DoubleProperty b = new SimpleDoubleProperty(0);
        DoubleProperty c = new SimpleDoubleProperty(0);
        DoubleBinding s = a.add(b).add(c).divide(2.0d);
        final DoubleBinding areaSquared = new When(
                a.add(b).greaterThan(c)
                        .and(b.add(c).greaterThan(a))
                        .and(c.add(a).greaterThan(b)))
                .then(s.multiply(s.subtract(a))
                        .multiply(s.subtract(b))
                        .multiply(s.subtract(c)))
                .otherwise(0.0D);
        a.set(3);
        b.set(4);
        c.set(5);
        System.out.printf("Given sides a = %1.0f," +
                        " b = %1.0f, and c = %1.0f," +
                        " the area of the triangle is" +
                        " %3.2f\n", a.get(), b.get(), c.get(),
                Math.sqrt(areaSquared.get()));
        a.set(2);
        b.set(2);
        c.set(2);
        System.out.printf("Given sides a = %1.0f," +
                        " b = %1.0f, and c = %1.0f," +
                        " the area of the triangle is" +
                        " %3.2f\n", a.get(), b.get(), c.get(),
                Math.sqrt(areaSquared.get()));
    }
}

Listing 3-7HeronsFormulaExample.java

```

运行该程序会将以下内容打印到控制台:

```java
Given sides a = 3, b = 4, and c = 5, the area of the triangle is 6.00
Given sides a = 2, b = 2, and c = 2, the area of the triangle is 1.73

```

应该注意的是，fluent API 有其局限性。随着关系变得更加复杂或者超出了可用的运算符，直接扩展方法是首选。清单 [3-8](#PC23) 展示了这样一个程序，它解决了与清单 [3-7](#PC21) 相同的问题。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
public class HeronsFormulaDirectExtensionExample {
    public static void main(String[] args) {
        final DoubleProperty a = new SimpleDoubleProperty(0);
        final DoubleProperty b = new SimpleDoubleProperty(0);
        final DoubleProperty c = new SimpleDoubleProperty(0);
        DoubleBinding area = new DoubleBinding() {
            {
                super.bind(a, b, c);
            }
            @Override
            protected double computeValue() {
                double a0 = a.get();
                double b0 = b.get();
                double c0 = c.get();
                if ((a0 + b0 > c0) && (b0 + c0 > a0) &&
                        (c0 + a0 > b0)) {
                    double s = (a0 + b0 + c0) / 2.0D;
                    return Math.sqrt(s * (s - a0) *
                            (s - b0) * (s - c0));
                } else {
                    return 0.0D;
                }
            }
        };
        a.set(3);
        b.set(4);
        c.set(5);
        System.out.printf("Given sides a = %1.0f," +
                        " b = %1.0f, and c = %1.0f," +
                        " the area of the triangle" +
                        " is %3.2f\n", a.get(), b.get(),
                c.get(), area.get());
        a.set(2);
        b.set(2);
        c.set(2);
        System.out.printf("Given sides a = %1.0f," +
                        " b = %1.0f, and c = %1.0f," +
                        " the area of the triangle" +
                        " is %3.2f\n", a.get(), b.get(),
                c.get(), area.get());
    }
}

Listing 3-8HeronsFormulaDirectExtensionExample.java

```

## 可观察的集合

JavaFX 在包`javafx.collections`和`javafx.collections.transformation`中提供了对可观察集合的支持。

他们引入了另外四个`Observable`的子接口，与我们在本章前面章节学习的`ObservableValue`接口一起。分别是`ObservableList`、`ObservableMap`、`ObservableSet`、`ObservableArray`。observable list、map 和 set 还分别扩展了`List`、`Map`和`Set` Java 集合的框架接口，因此可以像普通集合一样使用。因为它们只保存装箱的原始值，所以不需要特定于类型的专门化。另一方面，可观察数组在内部保存一个数组，并具有针对`int`和`float`类型的特定于类型的专门化。它们在 JavaFX 3D API 中使用。

这些接口的主要目的是允许您注册和取消注册变更监听器。除此之外，`ObservableList`接口还有额外的方法，以更有效的方式操作可观察列表。`ObservableMap`和`ObservableSet`接口没有附加的方法。带有`ObservableIntegerArray`和`ObservableFloatArray`子接口的`ObservableArray`接口拥有操纵可观察数组的方法。

### FXCollections 中的工厂和实用程序方法

`FXCollections`实用程序类包含创建可观察集合和数组的工厂方法。它们类似于`java.util.Collections`中的工厂方法，除了它们返回可观察的集合和数组。它们是创建系统提供的可观察集合和数组的唯一方法。

`FXCollections`实用程序类还提供了一些方法来操作它创建的`ObservableList`对象。这些方法包括`copy()`、`fill()`、`replaceAll()`、`reverse()`、`rotate()`、`shuffle()`和`sort()`方法。它们执行与它们的`java.util.Collections`对等物相同的功能，除了它们注意最小化生成的列表改变通知的数量。

清单 [3-9](#PC24) 显示了`FXCollections`方法的用法。

```java
package org.modernclients.propertiesandbindings;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableFloatArray;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.collections.ObservableSet;
import javafx.collections.SetChangeListener;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
public class FXCollectionsExample {
    public static void main(String[] args) {
        ObservableList<String> list =
                FXCollections.observableArrayList();
        ObservableMap<String, String> map =
                FXCollections.observableHashMap();
        ObservableSet<Integer> set =
                FXCollections.observableSet();
        ObservableFloatArray array =
                FXCollections.observableFloatArray();
        list.addListener((ListChangeListener<String>) c -> {
            System.out.println("\tlist = " +
                    c.getList());
        });
        map.addListener((MapChangeListener<String, String>) c -> {
            System.out.println("\tmap = " +
                    c.getMap());
        });
        set.addListener((SetChangeListener<Integer>) c -> {
            System.out.println("\tset = " +
                    c.getSet());
        });
        array.addListener((observableArray,
                           sizeChanged, from, to) -> {
            System.out.println("\tarray = " +
                    observableArray);
        });
        manipulateList(list);
        manipulateMap(map);
        manipulateSet(set);
        manipulateArray(array);
    }

    private static void manipulateList(
            ObservableList<String> list) {
        System.out.println("Calling list.addAll(\"Zero\"," +
                " \"One\", \"Two\", \"Three\"):");
        list.addAll("Zero", "One", "Two", "Three");
        System.out.println("Calling copy(list," +
                " Arrays.asList(\"Four\", \"Five\")):");
        FXCollections.copy(list,
                Arrays.asList("Four", "Five"));
        System.out.println("Calling replaceAll(list," +
                " \"Two\", \"Two_1\"):");
        FXCollections.replaceAll(list, "Two", "Two_1");
        System.out.println("Calling reverse(list):");
        FXCollections.reverse(list);
        System.out.println("Calling rotate(list, 2):");
        FXCollections.rotate(list, 2);
        System.out.println("Calling shuffle(list):");
        FXCollections.shuffle(list);
        System.out.println("Calling shuffle(list," +
                " new Random(0L)):");
        FXCollections.shuffle(list, new Random(0L));
        System.out.println("Calling sort(list):");
        FXCollections.sort(list);
        System.out.println("Calling sort(list, c)" +
                " with custom comparator: ");
        FXCollections.sort(list, new Comparator<String>() {
            @Override
            public int compare(String lhs, String rhs) {
                // Reverse the order
                return rhs.compareTo(lhs);
            }
        });
        System.out.println("Calling fill(list," +
                " \"Ten\"): ");
        FXCollections.fill(list, "Ten");
    }
    private static void manipulateMap(
            ObservableMap<String, String> map) {
        System.out.println("Calling map.put(\"Key\"," +
                " \"Value\"):");
        map.put("Key", "Value");
    }
    private static void manipulateSet(
            ObservableSet<Integer> set) {
        System.out.println("Calling set.add(1024):");
        set.add(1024);
    }

    private static void manipulateArray(
            ObservableFloatArray array) {
        System.out.println("Calling  array.addAll(3.14159f," +
                " 2.71828f):");
        array.addAll(3.14159f, 2.71828f);
    }
}

Listing 3-9FXCollectionsExample.java

```

在这里，我们使用`FXCollections`工厂方法创建了一个可观察列表、一个可观察映射、一个可观察集合和一个可观察数组，给它们附加了监听器，并以某种方式操纵它们，包括对列表使用`FXCollections`实用方法，对数组使用`ObservableFloatArray`方法。

运行该程序会将以下内容打印到控制台:

```java
Calling list.addAll("Zero", "One", "Two", "Three"):
        list = [Zero, One, Two, Three]
Calling copy(list, Arrays.asList("Four", "Five")):
        list = [Four, Five, Two, Three]
Calling replaceAll(list, "Two", "Two_1"):
        list = [Four, Five, Two_1, Three]
Calling reverse(list):
        list = [Three, Two_1, Five, Four]
Calling rotate(list, 2):
        list = [Five, Four, Three, Two_1]
Calling shuffle(list):
        list = [Five, Four, Two_1, Three]
Calling shuffle(list, new Random(0L)):
        list = [Three, Five, Four, Two_1]
Calling sort(list):
        list = [Five, Four, Three, Two_1]
Calling sort(list, c) with custom comparator:
        list = [Two_1, Three, Four, Five]
Calling fill(list, "Ten"):
        list = [Ten, Ten, Ten, Ten]
Calling map.put("Key", "Value"):
        map = {Key=Value}
Calling set.add(1024):
        set = [1024]
Calling  array.addAll(3.14159f, 2.71828f):
        array = [3.14159, 2.71828]

```

### 更改可观察集合的侦听器

`ObservableList`、`ObservableMap`、`ObservableSet`和`ObservableArray`接口提供了`addListener()`和`removeListener()`方法来注册和取消注册侦听器，以便在底层集合或数组发生变化时得到通知。对应的`ListChangeListener`、`MapChangeListener`和`SetChangeListener`接口都有一个`onChanged()`回调方法，其参数是一个嵌套的`Change`类。并且`ArrayChangeListener`接口有一个带显式参数的`onChanged()`回调方法。

清单 [3-10](#PC26) 显示了一个程序，其中一个`ObservableList<String>`被操纵，相应的`Change`对象在一个作为 lambda 实现的附加`ListChangeListener`中被查询。

```java
package org.modernclient.propertiesandbindings;

import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import static javafx.collections.ListChangeListener.Change;
public class ObservableListExample {
    public static void main(String[] args) {
        ObservableList<String> strings =
                FXCollections.observableArrayList();
        strings.addListener((Observable observable) -> {
            System.out.println("\tlist invalidated");
        });
        strings.addListener((Change<? extends String> change) -> {
            System.out.println("\tstrings = " +
                    change.getList());
        });
        System.out.println("Calling add(\"First\"): ");
        strings.add("First");
        System.out.println("Calling add(0, \"Zeroth\"): ");
        strings.add(0, "Zeroth");
        System.out.println("Calling addAll(\"Second\"," +
                " \"Third\"): ");
        strings.addAll("Second", "Third");
        System.out.println("Calling set(1," +
                " \"New First\"): ");
        strings.set(1, "New First");
        final List<String> list =
                Arrays.asList("Second_1", "Second_2");
        System.out.println("Calling addAll(3, list): ");
        strings.addAll(3, list);
        System.out.println("Calling remove(2, 4): ");
        strings.remove(2, 4);
        final Iterator<String> iterator =
                strings.iterator();
        while (iterator.hasNext()) {
            final String next = iterator.next();
            if (next.contains("t")) {
                System.out.println("Calling remove()" +
                        " on iterator: ");
                iterator.remove();
            }
        }
        System.out.println("Calling removeAll(" +
                "\"Third\", \"Fourth\"): ");
        strings.removeAll("Third", "Fourth");
    }
}

Listing 3-10ObservableListExample.java

```

运行该程序会将以下内容打印到控制台:

```java
Calling add("First"):
        list invalidated
        strings = [First]
Calling add(0, "Zeroth"):
        list invalidated
        strings = [Zeroth, First]
Calling addAll("Second", "Third"):
        list invalidated
        strings = [Zeroth, First, Second, Third]
Calling set(1, "New First"):
        list invalidated
        strings = [Zeroth, New First, Second, Third]
Calling addAll(3, list):
        list invalidated
        strings = [Zeroth, New First, Second, Second_1, Second_2, Third]
Calling remove(2, 4):
        list invalidated
        strings = [Zeroth, New First, Second_2, Third]
Calling remove() on iterator:
        list invalidated
        strings = [New First, Second_2, Third]
Calling remove() on iterator:
        list invalidated

        strings = [Second_2, Third]
Calling removeAll("Third", "Fourth"):
        list invalidated
        strings = [Second_2]

```

#### ListChangeListener 中的更改事件

在上一节中，我们只查询了`ListChangeListener.Change`对象的`list`属性，该属性引用了被观察的列表。这个对象保存了更多关于底层列表变化的信息。它代表一个或多个离散的变更，每个变更都可以是添加元素、删除元素、替换元素或置换元素。变更界面为您提供了查询变更各个方面的方法。

`next()`和`reset()`方法控制遍历离散变化的游标。当调用`onChanged()`时，光标位于第一个离散变化之前。一旦光标位于一个有效的离散变更上，`wasAdded()`、`wasRemoved()`、`wasReplaced()`和`wasPermuted()`方法会告诉您这是哪种离散变更。

一旦知道了光标所在的离散变化，就可以调用其他方法来获得有关离散变化的更多细节。对于添加的元素，您可以获得`from`(含)和`to`(不含)索引、`addedSize`和`addedSubList`。对于删除的元素，您可以获得删除元素的`from`和`to`(同`from`)索引、`removedSize`和`removed`列表。对于被替换的元素，可以认为是先删除后添加，应检查与添加和删除相关的信息。对于元素置换，`getPermutation(int i)`方法将 before 索引映射到 after 索引。

清单 [3-11](#PC28) 显示了一个带有漂亮的打印实现`ListChangeListener`的程序，当一个变更事件被触发时，它打印出`Change`对象的细节。

```java
package org.modernclients.propertiesandbindings;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
public class ListChangeEventExample {
    public static void main(String[] args) {
        ObservableList<String> strings =
                FXCollections.observableArrayList();
        strings.addListener(new MyListener());
        System.out.println("Calling addAll(\"Zero\"," +
                " \"One\", \"Two\", \"Three\"): ");
        strings.addAll("Zero", "One", "Two", "Three");
        System.out.println("Calling" +
                " FXCollections.sort(strings): ");
        FXCollections.sort(strings);
        System.out.println("Calling set(1, \"Three_1\"): ");
        strings.set(1, "Three_1");
        System.out.println("Calling setAll(\"One_1\"," +
                " \"Three_1\", \"Two_1\", \"Zero_1\"): ");
        strings.setAll("One_1", "Three_1", "Two_1", "Zero_1");
        System.out.println("Calling removeAll(\"One_1\"," +
                " \"Two_1\", \"Zero_1\"): ");
        strings.removeAll("One_1", "Two_1", "Zero_1");
    }
    private static class MyListener implements
            ListChangeListener<String> {
        @Override
        public void onChanged(
                Change<? extends String> change) {
            System.out.println("\tlist = " +
                    change.getList());
            System.out.println(prettyPrint(change));
        }
        private String prettyPrint(
                Change<? extends String> change) {
            StringBuilder sb =
                    new StringBuilder("\tChange event data:\n");
            int i = 0;
            while (change.next()) {
                sb.append("\t\tcursor = ")
                        .append(i++)
                        .append("\n");
                final String kind =
                        change.wasPermutated() ? "permutated" :
                        change.wasReplaced() ? "replaced" :
                        change.wasRemoved() ? "removed" :
                        change.wasAdded() ? "added" :
                        "none";
                sb.append("\t\tKind of change: ")
                        .append(kind)
                        .append("\n");
                sb.append("\t\tAffected range: [")
                        .append(change.getFrom())
                        .append(", ")
                        .append(change.getTo())
                        .append("]\n");
                if (kind.equals("added") ||
                        kind.equals("replaced")) {
                    sb.append("\t\tAdded size: ")
                            .append(change.getAddedSize())
                            .append("\n");
                    sb.append("\t\tAdded sublist: ")
                            .append(change.getAddedSubList())
                            .append("\n");
                }

                if (kind.equals("removed") ||
                        kind.equals("replaced")) {
                    sb.append("\t\tRemoved size: ")
                            .append(change.getRemovedSize())
                            .append("\n");
                    sb.append("\t\tRemoved: ")
                            .append(change.getRemoved())
                            .append("\n");
                }
                if (kind.equals("permutated")) {
                    StringBuilder permutationSB =
                            new StringBuilder("[");
                    int from = change.getFrom();
                    int to = change.getTo();
                    for (int k = from; k < to; k++) {
                        int permutation =
                                change.getPermutation(k);
                        permutationSB.append(k)
                                .append("->")
                                .append(permutation);
                        if (k < change.getTo() - 1) {
                            permutationSB.append(", ");
                        }
                    }
                    permutationSB.append("]");
                    String permutation =
                            permutationSB.toString();
                    sb.append("\t\tPermutation: ")
                            .append(permutation).append("\n");
                }
            }
            return sb.toString();
        }
    }
}

Listing 3-11ListChangeEventExample.java

```

运行该程序会将以下内容打印到控制台:

```java
Calling addAll("Zero", "One", "Two", "Three"):
        list = [Zero, One, Two, Three]
        Change event data:
                cursor = 0
                Kind of change: added
                Affected range: [0, 4]
                Added size: 4
                Added sublist: [Zero, One, Two, Three]
Calling FXCollections.sort(strings):
        list = [One, Three, Two, Zero]
        Change event data:
                cursor = 0
                Kind of change: permutated
                Affected range: [0, 4]
                Permutation: [0->3, 1->0, 2->2, 3->1]
Calling set(1, "Three_1"):
        list = [One, Three_1, Two, Zero]
        Change event data:
                cursor = 0
                Kind of change: replaced
                Affected range: [1, 2]
                Added size: 1
                Added sublist: [Three_1]
                Removed size: 1
                Removed: [Three]
Calling setAll("One_1", "Three_1", "Two_1", "Zero_1"):
        list = [One_1, Three_1, Two_1, Zero_1]
        Change event data:
                cursor = 0

                Kind of change: replaced
                Affected range: [0, 4]
                Added size: 4
                Added sublist: [One_1, Three_1, Two_1, Zero_1]
                Removed size: 4
                Removed: [One, Three_1, Two, Zero]
Calling removeAll("One_1", "Two_1", "Zero_1"):
        list = [Three_1]
        Change event data:
                cursor = 0
                Kind of change: removed
                Affected range: [0, 0]
                Removed size: 1
                Removed: [One_1]
                cursor = 1
                Kind of change: removed
                Affected range: [1, 1]
                Removed size: 2
                Removed: [Two_1, Zero_1]

```

#### MapChangeListener 中的更改事件

`MapChangeListener.Change`事件比其对应的可观察列表要简单得多，因为它只反映一个键的变化。因此，没有`next()`也没有`reset()`方法是必要的。如果多个键受到影响，将触发多个更改事件。

`wasAdded()`和`wasRemoved()`方法指示是否添加或移除一个键。你总能找到受变化影响的`key`。而如果加了一个键，就可以在`valueAdded`得到；如果一把钥匙被拿掉，你就可以拿到`valueRemoved`。

清单 [3-12](#PC30) 显示了一个操纵可观察地图并记录生成的变更事件的程序。

```java
package org.modernclients.propertiesandbindings;
import javafx.collections.FXCollections;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableMap;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
public class MapChangeEventExample {
    public static void main(String[] args) {
        ObservableMap<String, Integer> map =
                FXCollections.observableHashMap();
        map.addListener(new MyListener());
        System.out.println("Calling put(\"First\", 1): ");
        map.put("First", 1);
        System.out.println("Calling put(\"First\", 100): ");
        map.put("First", 100);
        Map<String, Integer> anotherMap = new HashMap<>();
        anotherMap.put("Second", 2);
        anotherMap.put("Third", 3);
        System.out.println("Calling putAll(anotherMap): ");
        map.putAll(anotherMap);
        Iterator<Map.Entry<String, Integer>> entryIterator =
                map.entrySet().iterator();
        while (entryIterator.hasNext()) {
            final Map.Entry<String, Integer> next =
                    entryIterator.next();
            if (next.getKey().equals("Second")) {
                System.out.println("Calling remove on" +
                        " entryIterator: ");
                entryIterator.remove();
            }
        }
        final Iterator<Integer> valueIterator =
                map.values().iterator();
        while (valueIterator.hasNext()) {
            final Integer next = valueIterator.next();
            if (next == 3) {
                System.out.println("Calling remove on" +
                        " valueIterator: ");
                valueIterator.remove();
            }
        }
    }

    private static class MyListener implements
            MapChangeListener<String, Integer> {
        @Override
        public void onChanged(
                Change<? extends String, ? extends Integer>
                        change) {
            System.out.println("\tmap = " + change.getMap());
            System.out.println(prettyPrint(change));
        }

        private String prettyPrint(
                Change<? extends String, ? extends Integer>
                        change) {
            StringBuilder sb =
                    new StringBuilder("\tChange event" +
                            " data:\n");
            sb.append("\t\tWas added: ")
                    .append(change.wasAdded())
                    .append("\n");
            sb.append("\t\tWas removed: ")
                    .append(change.wasRemoved())
                    .append("\n");
            sb.append("\t\tKey: ")
                    .append(change.getKey())
                    .append("\n");
            sb.append("\t\tValue added: ")
                    .append(change.getValueAdded())
                    .append("\n");
            sb.append("\t\tValue removed: ")
                    .append(change.getValueRemoved())
                    .append("\n");
            return sb.toString();
        }
    }
}

Listing 3-12MapChangeEventExample.java

```

#### SetChangeListener 中的更改事件

`SetChangeListener.Change`事件甚至比可观察地图的事件更简单，因为当可观察集合被修改时不涉及任何值。

清单 [3-13](#PC31) 显示了一个操纵一个可观察集合并记录生成的变更事件的程序。

```java
package org.modernclients.propertiesandbindings;
import javafx.collections.FXCollections;
import javafx.collections.ObservableSet;
import javafx.collections.SetChangeListener;
import java.util.Arrays;
public class SetChangeEventExample {
    public static void main(String[] args) {
        ObservableSet<String> set =
                FXCollections.observableSet();
        set.addListener(new MyListener());
        System.out.println("Calling add(\"First\"): ");
        set.add("First");
        System.out.println("Calling addAll(" +
                "Arrays.asList(\"Second\", \"Third\")): ");
        set.addAll(Arrays.asList("Second", "Third"));
        System.out.println("Calling remove(" +
                "\"Third\"): ");
        set.remove("Third");
    }
    private static class MyListener
            implements SetChangeListener<String> {
        @Override
        public void onChanged(Change<? extends String>
                                      change) {
            System.out.println("\tset = " +
                    change.getSet());
            System.out.println(prettyPrint(change));
        }
        private String prettyPrint(
                Change<? extends String> change) {
            StringBuilder sb =
                    new StringBuilder("\tChange" +
                            " event data:\n");
            sb.append("\t\tWas added: ")
                    .append(change.wasAdded())
                    .append("\n");
            sb.append("\t\tWas removed: ")
                    .append(change.wasRemoved())
                    .append("\n");
            sb.append("\t\tElement added: ")
                    .append(change.getElementAdded())
                    .append("\n");
            sb.append("\t\tElement removed: ")
                    .append(change.getElementRemoved())
                    .append("\n");
            return sb.toString();
        }
    }
}

Listing 3-13SetChangeEventExample.java

```

#### 更改 ArrayChangeListener 中的事件

`ArrayChangeListener`中的`onChanged()`方法具有以下签名:

```java
public void onChanged(T observableArray,
    boolean sizeChanged, int from, int to);

```

正如许多管理器类的数组一样，`ObservableArray`有一个*容量*和一个*大小*。容量是底层支持数组的长度，大小是包含应用程序数据的元素的数量。大小总是小于或等于容量。`ensureCapacity()`方法将容量设置为指定的值，并在必要时重新分配底层数组。`resize()`方法改变大小。如果新容量大于旧容量，则容量会增加。如果新的大小大于旧的大小，多余的元素用零填充。如果新的大小小于旧的大小，后备数组不会收缩，但丢失的元素会用零填充。`trimToSize()`方法将容量缩小到大小。`clear()`方法将可观察数组的大小调整为零。`size()`方法返回可观察数组的当前大小。

`ObservableArray`、`ObservableIntegerArray,`和`ObservableFloatArray`的特定类型专门化重载了以特定类型方式操作底层数组的方法。`get()`方法获取指定索引处的值。`set()`方法在指定的索引处设置一个值或一组值。`addAll()`方法将附加元素添加到可观察数组中。`setAll()`方法替换可观察数组中的元素。`toArray()`方法返回一个填充了可观察数组内容的原始数组。`get()`和`set()`方法可能会抛出`ArrayIndexOutOfBoundsException`。

清单 [3-14](#PC33) 显示了一个操纵`ObservableIntegerArray`并显示变更通知的程序。

```java
package org.modernclients.propertiesandbindings;
import javafx.collections.FXCollections;
import javafx.collections.ObservableIntegerArray;
public class ArrayChangeEventExample {
    public static void main(String[] args) {
        final ObservableIntegerArray ints =
                FXCollections.observableIntegerArray(10, 20);
        ints.addListener((array,
                          sizeChanged, from, to) -> {
            StringBuilder sb =
                    new StringBuilder("\tObservable Array = ")
                            .append(array)
                            .append("\n")
                            .append("\t\tsizeChanged = ")
                            .append(sizeChanged).append("\n")
                            .append("\t\tfrom = ")
                            .append(from).append("\n")
                            .append("\t\tto = ")
                            .append(to)
                            .append("\n");
            System.out.println(sb.toString());
        });
        ints.ensureCapacity(20);
        System.out.println("Calling addAll(30, 40):");
        ints.addAll(30, 40);
        final int[] src = {50, 60, 70};
        System.out.println("Calling addAll(src, 1, 2):");
        ints.addAll(src, 1, 2);
        System.out.println("Calling set(0, src, 0, 1):");
        ints.set(0, src, 0, 1);
        System.out.println("Calling setAll(src):");
        ints.setAll(src);
        ints.trimToSize();
        final ObservableIntegerArray ints2 =
                FXCollections.observableIntegerArray();
        ints2.resize(ints.size());
        System.out.println("Calling copyTo(0, ints2," +
                " 0, ints.size()):");
        ints.copyTo(0, ints2, 0, ints.size());
        System.out.println("\tDestination = " + ints2);
    }
}

Listing 3-14ArrayChangeEventExample.java

```

此应用程序的输出如下所示:

```java
Calling addAll(30, 40):
        Observable Array = [10, 20, 30, 40]
                sizeChanged = true
                from = 2
                to = 4
Calling addAll(src, 1, 2):
        Observable Array = [10, 20, 30, 40, 60, 70]
                sizeChanged = true
                from = 4
                to = 6
Calling set(0, src, 0, 1):
        Observable Array = [50, 20, 30, 40, 60, 70]
                sizeChanged = false
                from = 0
                to = 1
Calling setAll(src):
        Observable Array = [50, 60, 70]
                sizeChanged = true
                from = 0
                to = 3
Calling copyTo(0, ints2, 0, ints.size()):
        Destination = [50, 60, 70]

```

### 为可观察集合创建绑定

`Bindings`实用程序类包括从可观察集合中创建绑定的工厂方法。

重载方法`valueAt()`、`booleanValueAt()`、`integerValueAt()`、`longValueAt()`、`floatValueAt()`、`doubleValueAt()`和`stringValueAt()`从相同类型的可观察集合和适当类型的索引或键(可观察的或不可观察的)中创建适当类型的绑定。

例如，如果`authorizations`是一个代表`Person`对象授权状态的`ObservableMap<Person, Boolean>`，而`user`是一个`ObjectProperty<Person>`对象，那么`booleanValueAt(authorizations, user)`就是一个代表用户授权状态的`BooleanBinding`。

重载的`bindContent()`方法将不可观察集合绑定到同类的可观察集合，确保不可观察集合与可观察集合具有相同的内容。`unbindContent()`方法删除了这样的内容绑定。重载的`bindContentBidirectional()`方法绑定两个同类的可观察集合，确保它们有相同的内容。`unbindContentBidirectional()`方法删除了这样的双向内容绑定。

## JavaFX Beans

在前面的小节中，我们研究了单独的 JavaFX 属性和可观察集合。现在我们研究如何将它们组合成更大的单元，以形成更有意义的软件组件。

Java Beans 的概念几乎从一开始就存在。它引入了三个架构概念:*属性*、*事件*和*方法*。Java 中的方法很简单。事件是通过侦听器接口和事件对象提供的，JavaFX 控件仍在使用这些接口和对象。属性是使用现在非常熟悉的公共 getter 和 setter 方法提供的。

JavaFX 引入了 *JavaFX Bean* 概念，其中除了 getter 和 setter，JavaFX Bean 属性还有一个*属性 getter* 。对于类型为`double`的名为`height`的属性，有以下三种方法:

```java
public final double getHeight();
public final void setHeight(double height);
public DoubleProperty heightProperty();

```

正如传统的属性通常使用相同类型的支持字段来实现一样，JavaFX Bean 属性通常使用适当的`Property`类型的支持字段来实现。由于这些属性是引用类型，对于具有许多属性的 JavaFX Bean，可能会创建许多额外的对象。根据使用模式，可以使用不同的策略来实现这些属性。

Note

只读 JavaFX Bean 属性可以用一个 getter 和一个返回 JavaFX 属性的只读版本的属性 getter 来定义。

### 急切实例化的属性

实现 JavaFX Bean 属性的最简单策略是*急切实例化属性*策略。每个属性都由在构造时实例化的适当属性类型支持。getter 和 setter 简单地调用后台属性的`get()`和`set()`方法。属性 getter 返回支持属性本身。清单 [3-15](#PC36) 显示了一个具有`int`、`String`和`Color`属性的 JavaFX Bean。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.property.*;
import javafx.scene.paint.Color;
public class JavaFXBeanModelExample {
    private IntegerProperty i =
            new SimpleIntegerProperty(this, "i", 0);
    private StringProperty str =
            new SimpleStringProperty(this, "str", "Hello");
    private ObjectProperty<Color> color =
            new SimpleObjectProperty<Color>(this, "color",
                    Color.BLACK);
    public final int getI() {
        return i.get();
    }
    public final void setI(int i) {
        this.i.set(i);
    }
    public IntegerProperty iProperty() {
        return i;
    }
    public final String getStr() {
        return str.get();
    }
    public final void setStr(String str) {
        this.str.set(str);
    }
    public StringProperty strProperty() {
        return str;
    }
    public final Color getColor() {
        return color.get();
    }
    public final void setColor(Color color) {
        this.color.set(color);
    }
    public ObjectProperty<Color> colorProperty() {
        return color;
    }
}

Listing 3-15JavaFXBeanModelExample.java

```

注意，我们使用了具有完整上下文的属性构造函数，包括 bean、属性名和初始化属性的初始值。

### 半延迟实例化属性

如果 setter 和属性 getter 从未被调用，getter 将总是返回一个属性的默认值；你不需要一个属性实例来知道这一点。这是*半懒惰实例化*策略的基础。在这种策略中，只有在使用不同于默认值的值调用 setter 或调用属性 getter 时，属性才会被实例化。这种策略最适合具有许多属性的 JavaFX Beans，其中只有少数属性被设置。

清单 [3-16](#PC37) 展示了这种策略的一个例子。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
public class JavaFXBeanModelHalfLazyExample {
    private static final String DEFAULT_STR = "Hello";
    private StringProperty str;
    public final String getStr() {
        if (str != null) {
            return str.get();
        } else {
            return DEFAULT_STR;
        }
    }
    public final void setStr(String str) {
        if ((this.str != null) ||
                !(str.equals(DEFAULT_STR))) {
            strProperty().set(str);
        }
    }
    public StringProperty strProperty() {
        if (str == null) {
            str = new SimpleStringProperty(this,
                    "str", DEFAULT_STR);
        }
        return str;
    }
}

Listing 3-16JavaFXBeanModelHalfLazyExample.java

```

### 完全延迟实例化的属性

深入思考半懒惰实例化策略，我们会问自己，“当调用 setter 时，我们真的需要实例化属性吗？”答案当然是否定的，如果我们有地方放它，就像过去一样。这就产生了*全懒惰实例化*策略。在这种策略中，只有在调用属性 getter 时，属性才会被实例化。只有当属性对象已经被实例化时，getter 和 setter 才会检查它；否则，它们会通过一个单独的支持字段。

清单 [3-17](#PC38) 展示了这种策略的一个例子。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
public class JavaFXBeanModelFullLazyExample {
    private static final String DEFAULT_STR = "Hello";
    private StringProperty str;
    private String _str = DEFAULT_STR;
    public final String getStr() {
        if (str != null) {
            return str.get();
        } else {
            return _str;
        }
    }
    public final void setStr(String str) {
        if (this.str != null) {
            this.str.set(str);
        } else {
            _str = str;
        }
    }
    public StringProperty strProperty() {
        if (str == null) {
            str = new SimpleStringProperty(this,
                    "str", DEFAULT_STR);
        }
        return str;
    }
}

Listing 3-17JavaFXBeanModelFullLazyExample.java

```

### 选择绑定

现在我们已经理解了 JavaFX Bean 的概念，我们可以回到`Bindings`实用程序类，学习`select()`和`selectInteger()`方法等等。他们有如下签名:

```java
selectInteger(Object root, String... steps);

```

这些选择操作符允许您创建观察深度嵌套的 JavaFX Bean 属性的绑定。这里，`root`是作用域中的对象引用，每个`step`是手边对象的属性，指向下一个对象，依此类推。

最好用一个例子来说明这个概念。考虑类`Lighting`(在`javafx.scene.effect`中)。它有一个名为`light`的属性，类型为`Light`。并且`Light`有一个名为`color`的`Color`类型的属性(在`javafx.scene.paint`中)。清单 [3-18](#PC40) 显示了一个构建选择绑定的程序，该绑定到达`root`对象的`light`的`color`。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.ObjectBinding;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.scene.effect.Light;
import javafx.scene.effect.Lighting;
import javafx.scene.paint.Color;
public class SelectBindingExample {
    public static void main(String[] args) {
        ObjectProperty<Lighting> root =
                new SimpleObjectProperty<>();
        final ObjectBinding<Color> colorBinding =
                Bindings.select(root, "light", "color");
        colorBinding.addListener((o, oldValue, newValue) ->
                System.out.println("\tThe color changed:\n" +
                        "\t\told color = " + oldValue +
                        ",\n\t\tnew color = " + newValue));
        System.out.println("firstLight is black.");
        Light firstLight = new Light.Point();
        firstLight.setColor(Color.BLACK);
        System.out.println("secondLight is white.");
        Light secondLight = new Light.Point();
        secondLight.setColor(Color.WHITE);
        System.out.println("firstLighting has firstLight.");
        Lighting firstLighting = new Lighting();
        firstLighting.setLight(firstLight);
        System.out.println("secondLighting has secondLight.");
        Lighting secondLighting = new Lighting();
        secondLighting.setLight(secondLight);
        System.out.println("Making root observe" +
                " firstLighting.");
        root.set(firstLighting);
        System.out.println("Making root observe" +
                " secondLighting.");
        root.set(secondLighting);
        System.out.println("Changing secondLighting's" +
                " light to firstLight");
        secondLighting.setLight(firstLight);
        System.out.println("Changing firstLight's" +
                " color to red");
        firstLight.setColor(Color.RED);
    }
}

Listing 3-18SelectBindingExample.java

```

运行该程序会将以下内容打印到控制台:

```java
firstLight is black.
secondLight is white.
firstLighting has firstLight.
secondLighting has secondLight.
Making root observe firstLighting.
        The color changed:
                old color = null,
                new color = 0x000000ff
Making root observe secondLighting.
        The color changed:
                old color = 0x000000ff,
                new color = 0xffffffff
Changing secondLighting's light to firstLight
        The color changed:
                old color = 0xffffffff,
                new color = 0x000000ff
Changing firstLight's color to red
        The color changed:
                old color = 0x000000ff,
                new color = 0xff0000ff

```

### 改编 Java Beans

对于多年来编写的许多老式 Java Bean，JavaFX 在`javafx.beans.property.adapter`包中提供了一组适配器类，将 Java Bean 属性转换为 JavaFX 属性。

回想一下，如果在属性改变时触发了一个`PropertyChange`事件，那么 Java Bean 属性就是一个*绑定属性*。如果一个`VetoableChange`事件在被改变时被触发，那么它就是一个*约束属性*。如果一个注册的监听器抛出一个`PropertyVetoException`，这个改变不会生效。

清单 [3-19](#PC42) 显示了一个具有普通属性`name`、绑定属性`address`和约束属性`phoneNumber`的`Person` bean。

```java
package org.modernclients.propertiesandbindings;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyVetoException;
import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;
public class Person {
    private PropertyChangeSupport propertyChangeSupport;
    private VetoableChangeSupport vetoableChangeSupport;
    private String name;
    private String address;
    private String phoneNumber;
    public Person() {
        propertyChangeSupport =
                new PropertyChangeSupport(this);
        vetoableChangeSupport =
                new VetoableChangeSupport(this);
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getAddress() {
        return address;
    }
    public void setAddress(String address) {
        String oldAddress = this.address;
        this.address = address;
        propertyChangeSupport.firePropertyChange("address",
                oldAddress, this.address);
    }
    public String getPhoneNumber() {
        return phoneNumber;
    }
    public void setPhoneNumber(String phoneNumber)
            throws PropertyVetoException {
        String oldPhoneNumber = this.phoneNumber;
        vetoableChangeSupport.fireVetoableChange("phoneNumber",
                oldPhoneNumber, phoneNumber);
        this.phoneNumber = phoneNumber;
        propertyChangeSupport.firePropertyChange("phoneNumber",
                oldPhoneNumber, this.phoneNumber);
    }
    public void addPropertyChangeListener(PropertyChangeListener l) {
        propertyChangeSupport.addPropertyChangeListener(l);
    }
    public void removePropertyChangeListener(PropertyChangeListener l) {
        propertyChangeSupport.removePropertyChangeListener(l);
    }
    public PropertyChangeListener[] getPropertyChangeListeners() {
        return propertyChangeSupport.getPropertyChangeListeners();
    }
    public void addVetoableChangeListener(VetoableChangeListener l) {
        vetoableChangeSupport.addVetoableChangeListener(l);
    }
    public void removeVetoableChangeListener(VetoableChangeListener l) {
        vetoableChangeSupport.removeVetoableChangeListener(l);
    }
    public VetoableChangeListener[] getVetoableChangeListeners() {
        return vetoableChangeSupport.getVetoableChangeListeners();
    }
}

Listing 3-19Person.java

```

类型为`String`的 Java Bean 属性可以通过使用`JavaBeanStringPropertyBuilder`被改编成`JavaBeanStringProperty`:

```java
JavaBeanStringPropertyBuilder.create()
        .bean(person)
        .name("name")
        .build();

```

这遵循熟悉的构建器模式:您调用静态的`create()`方法来获得构建器的实例，然后调用构建器实例上的`bean()`和`name()`方法来配置构建器，告诉它要适应哪个 bean 和哪个属性。最后，您调用构建器上的`build()`方法来获得修改后的 JavaFX 属性。

builder 类有更多的方法可以用来处理更深奥的情况，例如，当 getter 或 setter 不遵循熟悉的命名约定，而是使用元数据指定时。

清单 [3-20](#PC44) 显示了一个将`Person`类的三个 Java Bean 属性改编成`JavaBeanStringProperty`对象的程序。

```java
package org.modernclients.propertiesandbindings;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.adapter.JavaBeanStringProperty;
import javafx.beans.property.adapter.JavaBeanStringPropertyBuilder;
import java.beans.PropertyVetoException;
public class JavaBeanPropertiesExample {
    public static void main(String[] args)
            throws NoSuchMethodException {
        adaptJavaBeansProperty();
        adaptBoundProperty();
        adaptConstrainedProperty();
    }
    private static void adaptJavaBeansProperty()
            throws NoSuchMethodException {
        Person person = new Person();
        JavaBeanStringProperty nameProperty =
                JavaBeanStringPropertyBuilder.create()
                        .bean(person)
                        .name("name")
                        .build();
        nameProperty.addListener((observable, oldValue, newValue) -> {
            System.out.println("JavaFX property " +
                    observable + " changed:");
            System.out.println("\toldValue = " +
                    oldValue + ", newValue = " + newValue);
        });
        System.out.println("Setting name on the" +
                " JavaBeans property");
        person.setName("Weiqi Gao");
        System.out.println("Calling fireValueChange");
        nameProperty.fireValueChangedEvent();
        System.out.println("nameProperty.get() = " +
                nameProperty.get());
        System.out.println("Setting value on the" +
                " JavaFX property");
        nameProperty.set("Johan Vos");
        System.out.println("person.getName() = " +
                person.getName());
    }
    private static void adaptBoundProperty()
            throws NoSuchMethodException {
        System.out.println();
        Person person = new Person();
        JavaBeanStringProperty addressProperty =
                JavaBeanStringPropertyBuilder.create()
                        .bean(person)
                        .name("address")
                        .build();
        addressProperty.addListener((observable, oldValue, newValue) -> {
            System.out.println("JavaFX property " +
                    observable + " changed:");
            System.out.println("\toldValue = " +
                    oldValue + ", newValue = " + newValue);
        });
        System.out.println("Setting address on the" +
                " JavaBeans property");
        person.setAddress("12345 main Street");
    }

    private static void adaptConstrainedProperty()
            throws NoSuchMethodException {
        System.out.println();
        Person person = new Person();
        JavaBeanStringProperty phoneNumberProperty =
                JavaBeanStringPropertyBuilder.create()
                        .bean(person)
                        .name("phoneNumber")
                        .build();
        phoneNumberProperty.addListener((observable,
                                         oldValue, newValue) -> {
            System.out.println("JavaFX property " +
                    observable + " changed:");
            System.out.println("\toldValue = " +
                    oldValue + ", newValue = " + newValue);
        });
        System.out.println("Setting phoneNumber on the" +
                " JavaBeans property");
        try {
            person.setPhoneNumber("800-555-1212");
        } catch (PropertyVetoException e) {
            System.out.println("A JavaBeans property" +
                    " change is vetoed.");
        }
        System.out.println("Bind phoneNumberProperty" +
                " to another property");
        SimpleStringProperty stringProperty =
                new SimpleStringProperty("866-555-1212");
        phoneNumberProperty.bind(stringProperty);
        System.out.println("Setting phoneNumber on the" +
                " JavaBeans property");
        try {
            person.setPhoneNumber("888-555-1212");
        } catch (PropertyVetoException e) {
            System.out.println("A JavaBeans property" +
                    " change is vetoed.");
        }
        System.out.println("person.getPhoneNumber() = " +
                person.getPhoneNumber());
    }
}

Listing 3-20JavaBeanPropertiesExample.java

```

注意，因为`name`不是一个绑定属性，所以调用`person.setName()`不会自动将新值传播给改编后的`nameProperty`。我们必须呼吁`nameProperty`上的`fireValueChangedEvent()`来实现这一点。对于绑定属性`address`，调用`person.setAddress()`会自动将新值传播到`addressProperty`。对于受约束的属性`phoneNumber`，在我们将适配的`phoneNumberProperty`绑定到另一个`stringProperty`之后，调用`person.setPhoneNumber()`会抛出一个`PropertyVetoException`，新值被拒绝。

运行该程序会将以下内容打印到控制台:

```java
Setting name on the JavaBeans property
Calling fireValueChange
JavaFX property StringProperty [bean: org.modernclients.propertiesand
bindings.Person@5a8e6209, name: name, value: Weiqi Gao] changed:
        oldValue = null, newValue = Weiqi Gao
nameProperty.get() = Weiqi Gao
Setting value on the JavaFX property
JavaFX property StringProperty [bean: org.modernclients.propertiesand
bindings.Person@5a8e6209, name: name, value: Johan Vos] changed:
        oldValue = Weiqi Gao, newValue = Johan Vos
person.getName() = Johan Vos
Setting address on the JavaBeans property
JavaFX property StringProperty [bean: org.modernclients.propertiesand
bindings.Person@1f36e637, name: address, value: 12345 main Street] changed:
        oldValue = null, newValue = 12345 main Street
Setting phoneNumber on the JavaBeans property
JavaFX property StringProperty [bean: org.modernclients.propertiesand
bindings.Person@35d176f7, name: phoneNumber, value: 800-555-1212] changed:
        oldValue = null, newValue = 800-555-1212
Bind phoneNumberProperty to another property
JavaFX property StringProperty [bean: org.modernclients.propertiesand
bindings.Person@35d176f7, name: phoneNumber, value: 866-555-1212] changed:
        oldValue = 800-555-1212, newValue = 866-555-1212
Setting phoneNumber on the JavaBeans property
A JavaBeans property change is vetoed.
person.getPhoneNumber() = 866-555-1212

```

## 摘要

在本章中，您学习了 JavaFX 属性和绑定框架的基础知识。现在，您应该了解以下重要原则:

*   JavaFX 属性和绑定保存值并向附加的侦听器触发事件。

*   当值无效时，将触发一个无效事件。并且在重新计算该值时触发一个 change 事件，这可能是延迟的。

*   对于`boolean`、`int`、`long`、`float`、`double`、`String`和`Object`类型，存在通用键接口的类型特定的专门化。对于原始类型，它们避免装箱和取消装箱。

*   将`ChangeListener`附加到一个属性会强制进行急切评估。

*   可以通过直接扩展、使用`Bindings`中的工厂方法或者使用 fluent API 来创建新的绑定。

*   对于`List`、`Map`、`Set`、`int`和`float`数组，存在可观察集合。它们的变化事件比可观察值更复杂。

*   可观察的集合和数组是使用`FXCollections`实用程序类中的工厂方法创建的。

*   JavaFX Bean 属性由一个 getter、一个 setter 和一个属性 getter 定义。

*   JavaFX Bean 属性可以通过急切实例化、半懒惰实例化和全懒惰实例化策略来实现。

*   旧式的 Java Bean 属性可以很容易地适应 JavaFX 属性。

## 资源

以下是使用本章内容的有用资源:

*   马丁·福勒关于流畅接口 API 的文章: [`www.martinfowler.com/bliki/FluentInterface.html`](http://www.martinfowler.com/bliki/FluentInterface.html) 。

*   JavaFX 框架的 Javadoc 托管在 [`https://openjfx.io/javadoc/17/`](https://openjfx.io/javadoc/17/) 。

*   我们利用格雷尔建立了源。下面是它的文档站点: [`https://docs.gradle.org/current/userguide/userguide.html`](https://docs.gradle.org/current/userguide/userguide.html) 。

*   JavaFX Gradle 插件在管理 JavaFX 依赖关系方面帮助很大: [`https://github.com/openjfx/javafx-gradle-plugin`](https://github.com/openjfx/javafx-gradle-%25C2%25ADplugin) 。

*   我们使用 Gradle 模块插件将源码组织成 Java 模块: [`https://github.com/java9-modularity/gradle-modules-plugin`](https://github.com/java9-modularity/gradle-%25C2%25ADmodules-%25C2%25ADplugin) 。