乔希·朱诺号 2017

乔希·朱诺号，Java 9 食谱，10.1007/978-1-4842-1976-8_13

# 13.使用数据库

乔希·朱诺号

(一)美国伊利诺伊州辛克利

几乎所有重要的应用程序都包含某种数据库。一些应用程序使用内存数据库，而其他应用程序使用传统的关系数据库管理系统(RDBMSs)。无论是哪种情况，每个 Java 开发人员都必须掌握一些使用数据库的技能。多年来，Java 数据库连接(JDBC) API 已经有了很大的发展，在过去的几个版本中已经有了一些重大的进步。

本章讲述了使用 JDBC 处理数据库的基础知识。您将学习如何执行所有标准的数据库操作，以及一些操作数据的高级技术。您还将了解如何使用 API 中的一些最新进展来创建安全的数据库应用程序并节省开发时间。最终，您将能够开发与 Oracle 数据库、PostgreSQL 和 MySQL 等传统 RDBMSs 一起工作的 Java 应用程序。

###### 注意

要遵循本章中的示例，请运行 create_user.sql 脚本来创建数据库用户模式。然后，在刚刚创建的数据库模式中运行 create_database.sql 脚本。

本书中的数据库示例是为 Apache Derby 或 Oracle 数据库量身定制的，但是它们可以修改为适用于任何关系数据库。

## 13-1.连接到数据库

### 问题

您希望从桌面 Java 应用程序中创建一个到数据库的连接。

### 解决方案 1

使用 JDBC 连接对象来获取连接。为此，创建一个新的连接对象，然后加载您需要用于特定数据库供应商的驱动程序。一旦连接对象准备就绪，就调用它的 getConnection()方法。下面的代码演示了如何根据指定的驱动程序获得到 Oracle 或 Apache Derby 数据库的连接。

```java
public Connection getConnection() throws SQLException {
    Connection conn = null;
    String jdbcUrl;
    if(driver.equals("derby")){
        jdbcUrl = "jdbc:derby://" + this.hostname + ":" +
                    this.port  + "/" + this.database;
    } else  {
        jdbcUrl = "jdbc:oracle:thin:@" + this.hostname + ":" +
                    this.port  + ":" + this.database;
    }
    System.out.println(jdbcUrl);
    conn = DriverManager.getConnection(jdbcUrl, username, password);
    System.out.println("Successfully connected");
    return conn;
}
```

本例中描述的方法返回一个准备好用于数据库访问的连接对象。

### 解决方案 2

使用数据源创建连接池。DataSource 对象必须已经正确实现并部署到应用服务器环境中。在实现和部署 DataSource 对象之后，应用程序可以使用它来获得到数据库的连接。以下代码显示了可用于通过 DataSource 对象获取数据库连接的代码:

```java
public Connection getDSConnection() {
    Connection conn = null;
    try {
        Context ctx = new InitialContext();
        DataSource ds = (DataSource)ctx.lookup("jdbc/myOracleDS");
        conn = ds.getConnection();

    } catch (NamingException | SQLException ex) {
        ex.printStackTrace();
    }
    return conn;
}
```

注意，DataSource 实现中唯一需要的信息是有效 DataSource 对象的名称。获得数据库连接所需的所有信息都在应用服务器中管理。

### 它是如何工作的

在 Java 应用程序中，有几种不同的方法可以创建到数据库的连接。如何做到这一点取决于您正在编写的应用程序的类型。如果一个应用程序是独立的或者是一个桌面应用程序，那么经常使用 DriverManager。基于 Web 和 intranet 的应用程序通常依靠应用服务器通过 DataSource 对象为应用程序提供连接。

创建 JDBC 连接需要几个步骤。首先，您需要确定您将需要哪个数据库驱动程序。在确定了需要哪个驱动程序之后，下载包含该驱动程序的 JAR 文件，并将其放入类路径中。对于这个菜谱，要么建立 Oracle 数据库连接，要么建立 Apache Derby 连接。每个数据库供应商都将提供不同的 JDBC 驱动程序，这些驱动程序打包在具有不同名称的 JAR 文件中；有关更多信息，请参考特定数据库的文档。一旦获得了适合您的数据库的 JAR 文件，就将它包含在您的应用程序类路径中。接下来，使用 JDBC 驱动程序管理器获得到数据库的连接。从 4.0 版开始，类路径中包含的驱动程序被自动加载到 DriverManager 对象中。如果您使用的是 4.0 之前的 JDBC 版本，则必须手动加载驱动程序。

要使用 DriverManager 获得到数据库的连接，需要向它传递一个包含 JDBC URL 的字符串。JDBC URL 由数据库供应商名称、托管数据库的服务器名称、数据库名称、数据库端口号以及可以访问您要使用的模式或数据库对象的有效数据库用户名和口令组成。很多时候，用于创建 JDBC URL 的值都是从属性文件中获取的，因此如果需要的话，可以很容易地对它们进行更改。要了解更多关于使用属性文件存储连接值的信息，请参阅配方 13-5。用于为解决方案 1 创建 Oracle 数据库 JDBC URL 的代码如下所示:

```java
String jdbcUrl = "jdbc:oracle:thin:@" + this.hostname + ":" +
                    this.port  + ":" + this.database;
```

一旦所有的变量都被替换到字符串中，它将看起来像下面这样:

```java
jdbc:oracle:thin:@hostname:1521:database
```

类似地，Apache Derby URL 字符串如下所示:

```java
jdbc:derby://hostname:1521/database
```

一旦创建了 JDBC URL，就可以将它传递给 DriverManager.getConnection()方法以获得 java.sql.Connection 对象。如果向 getConnection()方法传递了不正确的信息，将引发 Java . SQL . sqlexception；否则，将返回有效的连接对象。

获得数据库连接的首选方法是在应用服务器上运行时使用数据源，或者访问 Java 命名和目录接口(JNDI)服务。要使用 DataSource 对象，您需要有一个应用服务器将它部署到。任何兼容的 Java 应用服务器如 GlassFish、Oracle Weblogic、Payara 或 WildFly 都可以工作。大多数应用服务器都包含一个 web 接口，可以用来轻松部署 DataSource 对象。但是，您可以使用类似如下的代码来手动部署 DataSource 对象:

```java
org.java9recipes.chapter13.recipe13_01.FakeDataSourceDriver ds =
        new org.java9recipes.chapter13.recipe13_1.FakeDataSourceDriver();
ds.setServerName("my-server");
ds.setDatabaseName("JavaRecipes");
ds.setDescription("Database connection for Java 9 Recipes");
```

这段代码实例化一个新的 DataSource 驱动程序类，然后根据您想要注册的数据库设置属性。在应用服务器中注册数据源或访问 JNDI 服务器时，通常会使用这里演示的数据源代码。如果您使用基于 web 的管理工具来部署数据源，应用服务器通常在幕后完成这项工作。大多数数据库供应商都会提供一个数据源驱动程序以及他们的 JDBC 驱动程序，所以如果正确的 JAR 驻留在应用程序或服务器类路径中，它应该可以被识别并可供使用。一旦实例化和配置了数据源，下一步就是向 JNDI 命名服务注册数据源。

以下代码演示了向 JNDI 注册数据源的过程:

```java
try {
    Context ctx = new InitialContext();
    DataSource ds =
            (DataSource) ctx.bind("java9recipesDB");
} catch (NamingException ex) {
    ex.printStackTrace();
}
```

一旦部署了数据源，部署到同一应用服务器的任何应用程序都可以访问它。使用 DataSource 对象的美妙之处在于，您的应用程序代码不需要了解数据库的任何信息；它只需要知道数据源的名称。通常，数据源的名称以 jdbc/前缀开头，后面跟一个标识符。为了查找 DataSource 对象，使用了 InitialContext。InitialContext 查看应用程序服务器中所有可用的数据源，如果找到，则返回有效的数据源；否则会抛出 java.naming.NamingException 异常。在解决方案 2 中，您可以看到 InitialContext 返回一个必须转换为 DataSource 的对象。

```java
Context ctx = new InitialContext();
DataSource ds = (DataSource)ctx.lookup("jdbc/myOracleDS");
```

如果数据源是连接池缓存，当应用程序请求时，它将发送连接池中的一个可用连接。以下代码行从数据源返回一个连接对象:

```java
conn = ds.getConnection();
```

当然，如果不能获得有效的连接，就会抛出 java.sql.SQLException。DataSource 技术优于 DriverManager，因为数据库连接信息只存储在一个地方:应用服务器。一旦部署了有效的数据源，它就可以被许多应用程序使用。

在您的应用程序获得一个有效的连接之后，就可以使用它来处理数据库了。要了解有关使用连接对象处理数据库的更多信息，请参见方法 13-2 和 13-4。

## 13-2.处理连接和 SQL 异常

### 问题

应用程序中的数据库活动引发了异常。您需要处理 SQL 异常，以便您的应用程序不会崩溃。

### 解决办法

使用 try-catch 块来捕获和处理由 JDBC 连接或 SQL 查询引发的任何 SQL 异常。下面的代码演示了如何实现 try-catch 块来捕获 SQL 异常:

```java
try {
    // perform database tasks
} catch (java.sql.SQLException){
   // perform exception handling
}
```

### 它是如何工作的

标准的 try-catch 块可用于捕获 java.sql.Connection 或 java.sql.SQLException 异常。如果不处理这些异常，您的代码将无法编译，为了防止您的应用程序在这些异常之一被抛出时崩溃，适当地处理它们是一个好主意。几乎所有针对 java.sql.Connection 对象执行的工作都需要包含错误处理，以确保正确处理数据库异常。事实上，通常需要嵌套的 try-catch 块来处理所有可能的异常。您需要确保一旦完成工作并且不再使用连接对象，就关闭连接。同样，关闭 java.sql.Statement 对象来清理内存分配也是一个好主意。

因为需要关闭语句和连接对象，所以经常会看到使用 try-catch-finally 块来确保所有资源都被按需使用。您很可能会看到类似以下样式的旧 JDBC 代码:

```java
try {
    // perform database tasks
} catch (java.sql.SQLException ex) {
    // perform exception handling
} finally {
    try {
        // close Connection and Statement objects
    } catch (java.sql.SQLException ex){
        // perform exception handling
    }
}
```

应该编写新的代码来利用 try-with-resources 语句，该语句允许将资源管理卸载到 Java，而不是执行手动关闭。下面的代码演示如何使用 try-with-resources 打开连接，创建语句，然后在完成后关闭连接和语句。

###### 注意

示例中的 createConn 对象抽象出了获取数据库连接的细节，这些细节可以通过调用 getConnection()方法返回。

```java
try (Connection conn = createConn.getConnection();
        Statement stmt = conn.createStatement();) {
    ResultSet rs = stmt.executeQuery(qry);
    while (rs.next()) {
        // PERFORM SOME WORK
    }
} catch (SQLException e) {
    e.printStackTrace();
}
```

如前面的伪代码所示，为了清理未使用的资源，经常需要嵌套的 try-catch 块。适当的异常处理有时会使 JDBC 代码编写起来相当费力，但它也将确保需要数据库访问的应用程序不会失败，从而导致数据丢失。

## 13-3.查询数据库和检索结果

### 问题

应用程序中的一个进程需要查询数据库表中的数据。

### 解决办法

使用方法 13-1 中描述的技术之一获得一个 JDBC 连接，然后使用 java.sql.Connection 对象创建一个语句对象。java.sql.Statement 对象包含 executeQuery()方法，该方法解析文本字符串并使用它来查询数据库。一旦执行了查询，就可以将查询结果检索到 ResultSet 对象中。以下示例查询名为 RECIPES 的数据库表并打印结果:

```java
String qry = "select recipe_num, name, description from recipes";
try (Connection conn = createConn.getConnection();
        Statement stmt = conn.createStatement();) {
    ResultSet rs = stmt.executeQuery(qry);
    while (rs.next()) {
        String recipe = rs.getString("RECIPE_NUM");
        String name = rs.getString("NAME");
        String desc = rs.getString("DESCRIPTION");

        System.out.println(recipe + "\t" + name + "\t" + desc);
    }
} catch (SQLException e) {
    e.printStackTrace();
}
```

如果您使用本章中包含的数据库脚本执行此代码，您将收到以下结果:

```java
13-1    Connecting to a Database         DriverManager and DataSource Implementations
13-2    Querying a Database and Retrieving Results      Obtaining and Using Data from a DBMS
13-3    Handling SQL Exceptions Using SQLException
```

### 它是如何工作的

对数据库最常执行的操作之一是查询。使用 JDBC 执行数据库查询非常容易，尽管每次执行查询时都需要使用一些样板代码。首先，您需要为您想要运行查询的数据库和模式获取一个连接对象。你可以通过使用配方 13-1 中的一个解决方案来完成。接下来，您需要形成一个查询并以字符串格式存储它。然后，连接对象用于创建语句。您的查询字符串将被传递给语句对象的 executeQuery()方法，以便实际查询数据库。在这里，您可以看到不使用 try-with-resources 进行资源管理时的情况。

```java
String qry = "select recipe_num, name, description from recipes";
Connection conn;
Statement stmt = null;

try {
    conn = createConn.getConnection()
    stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(qry);
...
```

相同的代码可以更有效地编写如下:

```java
try (Connection conn = createConn.getConnection();
        Statement stmt = conn.createStatement();) {
    ResultSet rs = stmt.executeQuery(qry);
...
```

如您所见，语句对象的 executeQuery()方法接受一个字符串并返回一个 ResultSet 对象。ResultSet 对象使处理查询结果变得容易，因此您可以按任何顺序获得所需的信息。如果您看一下示例中的下一行代码，就会发现在 ResultSet 对象上创建了一个 while 循环。这个循环将继续调用 ResultSet 对象的 next()方法，获得每次迭代从查询中返回的下一行。在这种情况下，ResultSet 对象被命名为 rs，因此当 rs.next()返回 true 时，循环将继续被处理。一旦处理完所有返回的行，rs.next()将返回一个 false，表示没有要处理的行了。

在 while 循环中，处理每个返回的行。对 ResultSet 对象进行解析，以获得每次传递的给定列名的值。请注意，如果希望列返回一个字符串，则必须调用 ResultSet getString()方法，以字符串格式传递列名。类似地，如果希望该列返回一个 int，您可以调用 ResultSet getInt()方法，以字符串格式传递列名。其他数据类型也是如此。这些方法将返回相应的列值。在这个配方的解决方案的例子中，这些值被存储到局部变量中。

```java
String recipe = rs.getString("RECIPE_NUM");
String name = rs.getString("NAME");
String desc = rs.getString("DESCRIPTION");
```

一旦获得了列值，您就可以对存储在局部变量中的值做您想做的事情。在这种情况下，它们是使用 System.out()方法打印出来的。

```java
System.out.println(recipe + "\t" + name + "\t" + desc);
```

尝试查询数据库时可能会引发 java.sql.SQLException(例如，如果没有正确获取连接对象，或者如果您尝试查询的数据库表不存在)。在这些情况下，您必须提供异常处理来处理错误。因此，所有数据库处理代码都应该放在 try 块中。catch 块然后处理一个 SQLException，因此如果抛出一个，将使用 catch 块中的代码处理该异常。听起来很简单，对吧？是的，但是每次执行数据库查询时都必须这样做。很多样板代码。

如果语句和连接是打开的，关闭它们总是一个好主意。使用 try-with-resources 构造是最有效的资源管理解决方案。完成后关闭资源将有助于确保系统可以根据需要重新分配资源，并尊重数据库。尽快关闭连接以便其他进程可以使用它们是很重要的。

## 13-4.执行 CRUD 操作

### 问题

您需要能够在应用程序中执行标准的数据库操作。也就是说，您需要创建、检索、更新和删除(CRUD)数据库记录的能力。

### 解决办法

使用配方 13-1 中提供的解决方案之一创建一个连接对象并获得一个数据库连接；然后使用从 java.sql.Connection 对象获得的 java.sql.Statement 对象执行 CRUD 操作。将用于这些操作的数据库表具有以下格式:

```java
RECIPES (
    id              int not null,
    recipe_number   varchar(10) not null,
    recipe_name     varchar(100) not null,
    description     varchar(500),
    text            clob,
    constraint recipes_pk primary key (id) enable
);
```

以下代码摘录演示了如何使用 JDBC 执行每个 CRUD 操作:

```java
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import org.java9recipes.chapter13.recipe13_01.CreateConnection;

public class CrudOperations {

    static CreateConnection createConn;
    public static void main(String[] args) {

            createConn = new CreateConnection();
            performCreate();
            performRead();
            performUpdate();
            performDelete();
            System.out.println("-- Final State --");
            performRead();

    }

    private static void performCreate(){
        String sql = "INSERT INTO RECIPES VALUES(" +
                     "next value for recipes_seq, " +
                     "'13-4', " +
                     "'Performing CRUD Operations', " +
                     "'How to perform create, read, update, delete functions', " +
                     "'Recipe Text')";

        try (Connection conn = createConn.getConnection();
                Statement stmt = conn.createStatement();) {
            // Returns row-count or 0 if not successful
            int result = stmt.executeUpdate(sql);
            if (result == 1{
                System.out.println("-- Record created --");
            } else {
                System.err.println("!! Record NOT Created !!");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

    }

    private static void performRead(){
        String qry = "select recipe_number, recipe_name, description from recipes";

        try (Connection conn = createConn.getConnection();
                Statement stmt = conn.createStatement();) {
            ResultSet rs = stmt.executeQuery(qry);
            while (rs.next()) {
                String recipe = rs.getString("RECIPE_NUMBER");
                String name = rs.getString("RECIPE_NAME");
                String desc = rs.getString("DESCRIPTION");

                System.out.println(recipe + "\t" + name + "\t" + desc);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

    }

    private static void performUpdate(){
        String sql = "UPDATE RECIPES " +
                     "SET RECIPE_NUMBER = '13-5' " +
                     "WHERE RECIPE_NUMBER = '13-4'";

        try (Connection conn = createConn.getConnection();
                Statement stmt = conn.createStatement();) {
            int result = stmt.executeUpdate(sql);
            if (result > 0){
                System.out.println("-- Record Updated --");
            } else {
                System.out.println("!! Record NOT Updated !!");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

    }

    private static void performDelete(){
        String sql = "DELETE FROM RECIPES WHERE RECIPE_NUMBER = '13-5'";

        try (Connection conn = createConn.getConnection();
                Statement stmt = conn.createStatement();) {
            int result = stmt.executeUpdate(sql);
            if (result > 0){
                System.out.println("-- Record Deleted --");
            } else {
                System.out.println("!! Record NOT Deleted!!");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

}
```

下面是运行代码的结果:

```java
Successfully connected
-- Record created --
13-1    Connecting to a Database―DriverManager and DataSource Implementations
13-2    Querying a Database and Retrieving Results      Obtaining and Using Data from a DBMS
13-3    Handling SQL Exceptions Using SQLException
13-4    Performing CRUD Operations      How to Perform Create, Read, Update, Delete Functions
-- Record Updated --
-- Record Deleted --
-- Final State --
13-1    Connecting to a Database        DriverManager and DataSource Implementations
13-2    Querying a Database and Retrieving Results       Obtaining and Using Data from a DBMS
13-3    Handling SQL Exceptions Using SQLException
```

### 它是如何工作的

几乎每个数据库任务都使用相同的基本代码格式。格式如下:

1.  获取到数据库的连接。

2.  根据连接创建一个语句。

3.  使用语句执行数据库任务。

4.  对数据库任务的结果做一些事情。

5.  关闭语句(如果使用完了，还要关闭数据库连接)。

使用 JDBC 执行查询和使用数据操作语言(DML)执行查询的主要区别在于，根据要执行的操作，您将对语句对象调用不同的方法。要执行查询，需要调用语句 executeQuery()方法。为了执行插入、更新和删除等 DML 任务，请调用 executeUpdate()方法。

这个配方的解决方案中的 performCreate()方法演示了将记录插入数据库的操作。要在数据库中插入记录，请构造一个字符串格式的 SQL INSERT 语句。要执行插入，请将 SQL 字符串传递给语句对象的 executeUpdate()方法。如果执行插入，将返回一个 int 值，指定已插入的行数。如果插入操作未成功执行，将返回零或引发 SQLException，表明语句或数据库连接有问题。

这个配方的解决方案中的 performRead()方法演示了查询数据库的操作。要执行查询，请调用语句对象的 executeQuery()方法，以字符串格式传递 SQL 语句。结果将是一个 ResultSet 对象，然后可以用它来处理返回的数据。有关执行查询的更多信息，请参见配方 13-3。

这个配方的解决方案中的 performUpdate()方法演示了在数据库表中更新记录的操作。首先，构造一个字符串格式的 SQL UPDATE 语句。接下来，为了执行更新操作，将 SQL 字符串传递给语句对象的 executeUpdate()方法。如果更新成功执行，将返回一个 int 值，该值指定更新的记录数。如果更新操作没有成功执行，将返回零或引发 SQLException，表明语句或数据库连接有问题。

需要介绍的最后一个数据库操作是删除操作。这个配方的解决方案中的 performDelete()方法演示了从数据库中删除记录的操作。首先，构造一个字符串格式的 SQL DELETE 语句。接下来，为了执行删除，将 SQL 字符串传递给语句对象的 executeUpdate()方法。如果删除成功，将返回一个指定删除行数的 int 值。否则，如果删除失败，将返回零或引发 SQLException，表明语句或数据库连接有问题。

几乎每个数据库应用程序都会在某个时候使用至少一个 CRUD 操作。如果您在 Java 应用程序中使用数据库，这是需要知道的基本 JDBC。即使您不会直接使用 JDBC API，了解这些基础知识也是有好处的。

## 13-5.简化连接管理

### 问题

您的应用程序需要使用数据库，为了使用数据库，您需要为每个交互打开一个连接。您不需要在每次需要访问数据库时编写逻辑来打开数据库连接，而是希望使用单个类来执行该任务。

### 解决办法

编写一个类来处理应用程序中的所有连接管理。这样做将允许您调用该类来获得连接，而不是在每次需要访问数据库时设置一个新的连接对象。执行以下步骤为您的 JDBC 应用程序设置连接管理环境:

1.  创建一个名为 CreateConnection.java 的类，它将封装应用程序的所有连接逻辑。

2.  创建一个属性文件来存储连接信息。将该文件放在类路径中的某个位置，以便 CreateConnection 类可以加载它。

3.  使用 CreateConnection 类获取数据库连接。

以下代码列出了可用于集中式连接管理的 CreateConnection 类:

```java
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

public class CreateConnection {

    static Properties props = new Properties();

    String hostname = null;
    String port = null;
    String database = null;
    String username = null;
    String password = null;
    String driver = null;
    String jndi = null;

    public CreateConnection() {
        // Looks for properties file in the root of the src directory in Netbeans project
        try (InputStream in = Files.newInputStream(FileSystems.getDefault().
                getPath(System.getProperty("user.dir") + File.separator + "db_props.properties"));) {
            props.load(in);
            in.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
        loadProperties();
    }

    public final void loadProperties() {
        hostname = props.getProperty("host_name");
        port = props.getProperty("port_number");
        database = props.getProperty("db_name");
        username = props.getProperty("username");
        password = props.getProperty("password");
        driver = props.getProperty("driver");
        jndi = props.getProperty("jndi");

    }

    /**
     * Demonstrates obtaining a connection via DriverManager
     *
     * @return
     * @throws SQLException
     */
    public Connection getConnection() throws SQLException {
        Connection conn = null;
        String jdbcUrl;
        if (driver.equals("derby")) {
            jdbcUrl = "jdbc:derby://" + this.hostname + ":"
                    + this.port + "/" + this.database;
        } else {
            jdbcUrl = "jdbc:oracle:thin:@" + this.hostname + ":"
                    + this.port + ":" + this.database;
        }
        conn = DriverManager.getConnection(jdbcUrl, username, password);
        System.out.println("Successfully connected");
        return conn;
    }

    /**
     * Demonstrates obtaining a connection via a DataSource object
     *
     * @return
     */
    public Connection getDSConnection() {
        Connection conn = null;
        try {
            Context ctx = new InitialContext();
            DataSource ds = (DataSource) ctx.lookup(this.jndi);
            conn = ds.getConnection();
        } catch (NamingException | SQLException ex) {
            ex.printStackTrace();
        }
        return conn;
    }
}
```

接下来，下面几行文本是属性文件中应该包含的内容的示例，该属性文件用于获取到数据库的连接。对于本例，属性文件被命名为 db_props.properties:

```java
host_name=your_db_server_name
db_name=your_db_name
username=db_username
password=db_username_password
port_number=db_port_number
#driver = derby or oracle
driver=db_driver
jndi=jndi_connection_String
```

最后，使用 CreateConnection 类获取应用程序的连接。下面的代码演示了这个概念:

```java
CreateConnection createConn = new CreateConnection();
try(Connection conn = createConn.getConnection()) {
    performDbTask();
} catch (java.sql.SQLException ex) {
    ex.printStackTrace();
}
```

这段代码使用 try-with-resources 在完成数据库任务后自动关闭连接。

### 它是如何工作的

在数据库应用程序中获取连接可能需要大量代码。此外，如果每次需要获得连接时都要重新键入代码，这个过程很容易出错。通过将数据库连接逻辑封装在单个类中，您可以在每次需要连接到数据库时重用相同的连接代码。这提高了您的工作效率，减少了输入错误的机会，也增强了可管理性，因为如果您必须进行更改，它可以在一个地方而不是在几个不同的位置发生。

创建一个战略连接方法对你和其他将来可能需要维护你的代码的人是有益的。虽然在使用应用程序服务器或 JNDI 时，数据源是管理数据库连接的首选技术，但是这个方法的解决方案演示了使用标准的 JDBC 驱动程序管理器连接。使用 DriverManager 的一个安全问题是，您需要将数据库凭证存储在某个地方，供应用程序使用。将这些凭证以纯文本的形式存储在任何地方都是不安全的，将它们嵌入到应用程序代码中也是不安全的，因为应用程序代码将来可能会被反编译。如解决方案所示，磁盘上的属性文件用于存储数据库凭证。假设这个属性文件在部署到服务器之前会被加密，并且应用程序能够处理解密。

如解决方案所示，代码从属性文件中读取数据库凭证、主机名、数据库名和端口号。然后将这些信息拼凑起来形成一个 JDBC URL，DriverManager 可以使用它来获得到数据库的连接。一旦获得，该连接可以在任何地方使用，然后关闭。类似地，如果使用已经部署到应用服务器的数据源，属性文件可以用来存储 JNDI 连接。这是使用数据源连接到数据库所需的唯一信息。对于使用 connection 类的开发人员来说，这两种类型的连接之间的唯一区别是为了获得 Connection 对象而调用的方法名。

您可以开发一个 JDBC 应用程序，这样用于获得连接的代码就需要从头到尾都是硬编码的。相反，这种解决方案使获取连接的所有代码都被一个类封装起来，这样开发人员就不需要担心了。这种技术还允许代码变得更易于维护。例如，如果应用程序最初是使用 DriverManager 部署的，但是后来有了使用数据源的能力，那么只需要修改很少的代码。

## 13-6.防范 SQL 注入

### 问题

您的应用程序执行数据库任务。为了减少 SQL 注入攻击的机会，您需要确保没有未经过滤的文本字符串被附加到 SQL 语句中并针对数据库执行。

###### 小费

尽管准备好的语句是解决这一问题的方法，但它们不仅仅可以用来防范 SQL 注入病毒。它们还提供了集中和更好地控制应用程序中使用的 SQL 的方法。例如，您可以将查询创建一次，作为一个准备好的语句，然后从代码中的许多不同位置调用它，而不是创建同一个查询的多个可能不同的版本。对查询逻辑的任何更改只需要在准备语句时进行。

### 解决办法

使用 PreparedStatements 执行数据库任务。PreparedStatements 将预编译的 SQL 语句而不是字符串发送到 DBMS。以下代码演示如何使用 java.sql.PreparedStatement 对象执行数据库查询和数据库更新。

在下面的代码示例中，PreparedStatement 用于查询数据库中的给定记录。假设配方编号的字符串[]作为一个变量被传递给这个代码。

```java
private static void queryDbRecipe(String[] recipeNumbers) {
    String sql = "SELECT ID, RECIPE_NUMBER, RECIPE_NAME, DESCRIPTION "
            + "FROM RECIPES "
            + "WHERE RECIPE_NUMBER = ?";

    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
        for (String recipeNumber : recipeNumbers) {
            pstmt.setString(1, recipeNumber);
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                System.out.println(rs.getString(2) + ": " + rs.getString(3)
                        + " - " + rs.getString(4));
            }
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
    }

}
```

下一个示例演示了如何使用 PreparedStatement 将记录插入数据库。假设 recipeNumber、title、description 和 text 字符串作为变量传递给了这段代码。

```java
String sql = "INSERT INTO RECIPES VALUES(" +
             "NEXT VALUE FOR RECIPES_SEQ, ?,?,?,?)";
try(PreparedStatement pstmt = conn.prepareStatement(sql);) {
    pstmt.setString(1, recipeNumber);
    pstmt.setString(2, title);
    pstmt.setString(3, description);
    pstmt.setString(4, text);
    pstmt.executeUpdate();
    System.out.println("Record successfully inserted.");
} catch (SQLException ex){
    ex.printStackTrace();
}
```

在最后一个示例中，PreparedStatement 用于从数据库中删除记录。同样，假设 recipeNumber 字符串作为变量传递给这段代码。

```java
String sql = "DELETE FROM RECIPES WHERE " +
             "RECIPE_NUMBER = ?";
try(PreparedStatement pstmt = conn.prepareStatement(sql);) {
    pstmt.setString(1, recipeNumber);
    pstmt.executeUpdate();
    System.out.println("Recipe " + recipeNumber + " successfully deleted.");
} catch (SQLException ex){
    ex.printStackTrace();
}
```

如您所见，PreparedStatement 与标准的 JDBC 语句对象非常相似，但它将预编译的 SQL 而不是文本字符串发送到 DBMS。

### 它是如何工作的

虽然标准的 JDBC 语句可以完成工作，但残酷的现实是，它们有时不安全，使用起来很麻烦。例如，如果使用动态 SQL 语句来查询数据库，并且将用户接受的字符串赋给变量并与预期的 SQL 字符串连接，就会发生不好的事情。在大多数情况下，用户接受的字符串将被连接起来，SQL 字符串将按预期用于查询数据库。然而，攻击者可以决定将恶意代码放入字符串中(也称为 SQL 注入)，然后使用标准语句对象将恶意代码无意中发送到数据库。使用 PreparedStatements 可以防止此类恶意字符串连接成 SQL 字符串并传递到 DBMS，因为它们使用不同的方法。PreparedStatements 使用替代变量而不是串联来使 SQL 字符串动态化。它们也是预编译的，这意味着在 SQL 被发送到 DBMS 之前就形成了有效的 SQL 字符串。此外，PreparedStatements 可以帮助您的应用程序更好地执行，因为如果同一个 SQL 必须运行多次，它只需编译一次。之后，替代变量是可互换的，但是整个 SQL 可以由 PreparedStatement 非常快速地执行。

让我们看看 PreparedStatement 在实践中是如何工作的。如果您查看这个配方的解决方案中的第一个示例，您可以看到数据库表 RECIPES 正在被查询，传递一个 RECIPE_NUMBER 并检索匹配记录的结果。SQL 字符串如下所示:

```java
String sql = "SELECT ID, RECIPE_NUMBER, RECIPE_NAME, DESCRIPTION " +
             "FROM RECIPES " +
             "WHERE RECIPE_NUM = ?";
```

除了问号(？)在字符串的末尾。在 SQL 字符串中放置一个问号表示在执行 SQL 时将使用一个替代变量来代替这个问号。使用 PreparedStatement 的下一步是声明 PreparedStatement 类型的变量。这可以从下面一行代码中看出:

```java
PreparedStatement pstmt = null;
```

PreparedStatement 实现 AutoCloseable，因此可以在 try-with-resources 块的上下文中使用它。一旦声明了 PreparedStatement，就可以使用它了。但是，使用 PreparedStatement 可能不会导致引发异常。因此，在不使用 try-with-resources 的情况下，应该在 try-catch 块中出现 PreparedStatement，以便可以优雅地处理任何异常。例如，如果数据库连接由于某种原因不可用，或者 SQL 字符串无效，就会出现异常。最好在 catch 块中明智地处理异常，而不是因为这些问题而导致应用程序崩溃。下面的 try-catch 块包含将 SQL 字符串发送到数据库并检索结果所需的代码:

```java
try(PreparedStatement pstmt = conn.prepareStatement(sql);) {
    pstmt.setString(1, recipeNumber);
    ResultSet rs = pstmt.executeQuery();
    while(rs.next()){
        System.out.println(rs.getString(2) + ": " + rs.getString(3) +
                        " - " + rs.getString(4));
    }
} catch (SQLException ex) {
    ex.printStackTrace();
}
```

首先，可以看到 Connection 对象用于实例化一个 PreparedStatement 对象。SQL 字符串在创建时被传递给 PreparedStatement 对象的构造函数。由于 PreparedStatement 是在 try-with-resources 构造中实例化的，因此当它不再使用时将自动关闭。接下来，PreparedStatement 对象用于为已经放入 SQL 字符串中的任何替代变量设置值。如您所见，示例中使用了 PreparedStatement setString()方法将位置 1 处的替换变量设置为 recipeNumber 变量的内容。替代变量的位置与问号(？)放在 SQL 字符串中。字符串中的第一个问号被分配给第一个位置，第二个问号被分配给第二个位置，依此类推。如果要分配多个替代变量，将会有多个针对 PreparedStatement 的调用，分配每个变量，直到每个变量都被考虑在内。PreparedStatements 可以接受许多不同数据类型的替代变量。例如，如果一个 int 值被赋给一个替代变量，调用 setInt(position，variable)方法是合适的。有关可用于使用 PreparedStatement 对象分配替代变量的完整方法集，请参见联机文档或 IDE 的代码完成。

一旦所有变量都被赋值，就可以执行 SQL 字符串了。PreparedStatement 对象包含一个 executeQuery()方法，该方法用于执行表示查询的 SQL 字符串。executeQuery()方法返回一个 ResultSet 对象，该对象包含为特定 SQL 查询从数据库中获取的结果。接下来，可以遍历 ResultSet 以获取从数据库中检索的值。同样，通过调用 ResultSet 对象的相应 getter 方法并传递您想要获取的列值的位置，位置赋值用于检索结果。位置由列名在 SQL 字符串中出现的顺序决定。在该示例中，第一个位置对应于 RECIPE_NUMBER 列，第二个位置对应于 RECIPE_NAME 列，依此类推。如果 recipeNumber 字符串变量等于“13-1”，则在示例中执行查询的结果将如下所示:

```java
13-1: Connecting to a Database - DriverManager and DataSource Implementations
```

当然，如果替代变量设置不正确或者 SQL 字符串有问题，就会抛出异常。这将导致包含在 catch 块中的代码被执行。您还应该确保在使用 PreparedStatements 后进行清理，方法是在使用完语句后关闭该语句。如果没有使用 try-with-resources 构造，最好将所有清理代码放在 finally 块中，以确保即使抛出异常，PreparedStatement 也能正确关闭。在该示例中，finally 块如下所示:

```java
finally {
    if (pstmt != null){
        try {
            pstmt.close();
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
    }
}
```

可以看到，已实例化的 PreparedStatement 对象 pstmt 被检查是否为 NULL。如果没有，则通过调用 close()方法关闭它。

通过研究这个配方的解决方案中的代码，您可以看到类似的代码用于处理数据库插入、更新和删除语句。这两种情况的唯一区别是调用了 PreparedStatement executeUpdate()方法，而不是 executeQuery()方法。executeUpdate()方法将返回一个 int 值，表示受 SQL 语句影响的行数。

PreparedStatement 对象的使用优于 JDBC 语句对象。这是因为它们更安全，性能更好。它们还可以使您的代码更容易遵循和维护。

## 13-7.执行交易

### 问题

构建应用程序的方式需要任务的顺序处理。一个任务依赖于另一个任务，每个进程执行不同的数据库操作。如果其中一个任务失败，已经发生的数据库处理需要被逆转。

### 解决办法

将连接对象自动提交设置为 false，然后执行要完成的事务。一旦成功地执行了每个事务，手动提交连接对象；否则，回滚已发生的每个事务。下面的代码示例演示事务管理。如果您查看 TransactionExample 类的 main()方法，您将看到 Connection 对象的 autoCommit()首选项已被设置为 false，因此数据库语句被组合在一起形成一个事务。如果事务内的所有语句都成功，则通过调用 commit()方法手动提交连接对象；否则，通过调用 rollback()方法回滚所有语句。默认情况下，autoCommit 设置为 true，这将自动将每个语句视为单个事务。

```java
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import org.java9recipes.chapter13.recipe13_01.CreateConnection;

public class TransactionExample {
    public static Connection conn = null;

    public static void main(String[] args) {
        boolean successFlag = false;
        try {
            CreateConnection createConn = new CreateConnection();
            conn = createConn.getConnection();
            conn.setAutoCommit(false);
            queryDbRecipes();
            successFlag = insertRecord(
                    "13-6",
                    "Simplifying and Adding Security with Prepared Statements",
                    "Working with Prepared Statements",
                    "Recipe Text");

            if (successFlag == true){

                successFlag = insertRecord(
                        "13-6B",
                        "Simplifying and Adding Security with Prepared Statements",
                        "Working with Prepared Statements",
                        "Recipe Text");
            }

            // Commit Transactions
            if (successFlag == true)
                conn.commit();  
            else
                conn.rollback();

            conn.setAutoCommit(true);
            queryDbRecipes();
        } catch (java.sql.SQLException ex) {
            System.out.println(ex);
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }

    }

    private static void queryDbRecipes(){
        String sql = "SELECT ID, RECIPE_NUMBER, RECIPE_NAME, DESCRIPTION " +
                     "FROM RECIPES";

        try(PreparedStatement pstmt = conn.prepareStatement(sql);) {
            ResultSet rs = pstmt.executeQuery();
            while(rs.next()){
                System.out.println(rs.getString(2) + ": " + rs.getString(3) +
                                " - " + rs.getString(4));
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        }

    }

    private static boolean insertRecord(String recipeNumber,
                              String title,
                              String description,
                              String text){
        String sql = "INSERT INTO RECIPES VALUES(" +
                     "NEXT VALUE FOR RECIPES_SEQ, ?,?,?,?)";
        boolean success = false;
        try(PreparedStatement pstmt = conn.prepareStatement(sql);) {
            pstmt.setString(1, recipeNumber);
            pstmt.setString(2, title);
            pstmt.setString(3, description);
            pstmt.setString(4, text);
            pstmt.executeUpdate();
            System.out.println("Record successfully inserted.");
            success = true;
        } catch (SQLException ex){
            success = false;
            ex.printStackTrace();
        }
        return success;

    }

}
```

最后，如果任何语句失败，所有事务都将回滚。但是，如果所有语句都正确执行，所有内容都将被提交。

### 它是如何工作的

事务管理在应用程序中扮演着重要的角色。对于执行相互依赖的不同任务的应用程序来说尤其如此。在许多情况下，如果在一个事务中执行的任务之一失败，那么整个事务失败要比只完成一部分要好。例如，假设您正在向应用程序数据库添加数据库用户记录。现在，假设为您的应用程序添加一个用户需要修改几个不同的数据库表，可能是一个角色表，等等。如果第一个表修改正确，第二个表修改失败，会发生什么？您将得到一个部分完成的应用程序用户添加，并且您的用户很可能无法像预期的那样访问应用程序。在这种情况下，如果其中一个更新失败，最好回滚所有已经完成的数据库修改，这样数据库就处于干净的状态，可以再次尝试事务。

默认情况下，会设置一个连接对象，以便打开自动提交。这意味着每个数据库插入、更新或删除语句都会被立即提交。通常，这是您希望应用程序运行的方式。但是，在您有许多相互依赖的数据库语句的情况下，关闭自动提交以便可以一次提交所有语句是很重要的。为此，调用连接对象的 setAutoCommit()方法并传递一个 false 值。正如您在这个配方的解决方案中所看到的，setAutoCommit()方法被称为传递假值，数据库语句被执行。这样做将导致所有数据库语句更改都是临时的，直到调用连接对象的 commit()方法。这为您提供了在发出 commit()之前确保所有语句正确执行的能力。看一下这个配方的解决方案中 TransactionExample 类的 main()方法中包含的事务管理代码:

```java
boolean successFlag = false;
...
CreateConnection createConn = new CreateConnection();
conn = createConn.getConnection();
conn.setAutoCommit(false);
queryDbRecipes();
successFlag = insertRecord(
                    "13-6",
                    "Simplifying and Adding Security with Prepared Statements",
                    "Working with Prepared Statements",
                    "Recipe Text");

if (successFlag == true){

    successFlag = insertRecord(
        null,
        "Simplifying and Adding Security with Prepared Statements",
        "Working with Prepared Statements",
        "Recipe Text");
}
// Commit Transactions
if (successFlag == true)
    conn.commit();  
else
     conn.rollback();

conn.setAutoCommit(true);
```

请注意，只有在成功处理了所有事务语句的情况下，才会调用 commit()方法。如果其中任何一个失败，successFlag 等于 false，这将导致调用 rollback()方法。在这个配方的解决方案中，对 insertRecord()的第二次调用试图向配方中插入一个空值。ID 列，这是不允许的。因此，该插入会失败，所有内容(包括前一次插入)都会回滚。

## 13-8.创建可滚动的结果集

### 问题

您已经查询了数据库并获得了一些结果。您希望将这些结果存储在一个对象中，该对象将允许您在结果中向前和向后遍历，并根据需要更新值。

### 解决办法

创建一个可滚动的 ResultSet 对象，然后您将能够读取下一条、第一条记录、最后一条和上一条记录。使用可滚动的 ResultSet 允许从任何方向获取查询结果，以便可以根据需要检索数据。下面的示例方法演示了如何创建可滚动的 ResultSet 对象:

```java
private static void queryDbRecipes(){
    String sql = "SELECT ID, RECIPE_NUMBER, RECIPE_NAME, DESCRIPTION " +
                 "FROM RECIPES";

    try(PreparedStatement pstmt =conn.prepareStatement(sql,
            ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
        ResultSet rs = pstmt.executeQuery()) {

        rs.first();
        System.out.println(rs.getString(2) + ": " + rs.getString(3) +
                        " - " + rs.getString(4));
        rs.next();
        System.out.println(rs.getString(2) + ": " + rs.getString(3) +
                        " - " + rs.getString(4));
        rs.previous();
        System.out.println(rs.getString(2) + ": " + rs.getString(3) +
                        " - " + rs.getString(4));
        rs.last();
        System.out.println(rs.getString(2) + ": " + rs.getString(3) +
                        " - " + rs.getString(4));
    } catch (SQLException ex) {
        ex.printStackTrace();
    }

}
```

使用最初为本章加载的数据，执行此方法将产生以下输出:

```java
Successfully connected
13-1: Connecting to a Database - DriverManager and DataSource Implementations - More to Come
13-2: Querying a Database and Retrieving Results - Obtaining and Using Data from a DBMS
13-1: Connecting to a Database - DriverManager and DataSource Implementations - More to Come
13-3: Handling SQL Exceptions - Using SQLException
```

### 它是如何工作的

普通的 ResultSet 对象允许向前提取结果。也就是说，应用程序可以从检索到的第一条记录到最后一条记录处理默认的 ResultSet 对象。有时候，在遍历结果集时，应用程序需要更多的功能。例如，假设您想编写一个应用程序，允许某人显示检索到的第一条或最后一条记录，或者在结果中向前或向后翻页。使用一个标准的结果集，你不可能很容易地做到这一点。但是，通过创建一个可滚动的结果集，您可以轻松地在结果中前后移动。

若要创建可滚动的结果集，必须首先创建能够创建可滚动结果集的语句或 PreparedStatement 的实例。也就是说，在创建语句时，必须将 ResultSet 滚动类型常量值传递给 Connection 对象的 createStatement()方法。同样，在使用 PreparedStatement 时，必须将滚动类型常量值传递给连接对象的 prepareStatement()方法。有三种滚动类型常量可供使用。表 [13-1](#Tab1) 显示了这三个常数。

###### 表 13-1。结果集滚动类型常量

<colgroup class="calibre15"><col class="calibre16"> <col class="calibre16"></colgroup> 
| 

常数

 | 

描述

 |
| --- | --- |
| 结果集。仅转发类型 | 默认类型，仅允许向前移动。 |
| 结果集。TYPE _ SCROLL _ 不敏感 | 允许向前和向后移动。对结果集更新不敏感。 |
| 结果集。类型 _ 滚动 _ 敏感 | 允许向前和向后移动。对结果集更新敏感。 |

您还必须传递一个 ResultSet 并发常量，以告知 ResultSet 是否是可更新的。默认值为 ResultSet。CONCUR_READ_ONLY，这意味着结果集不可更新。另一种并发类型是 ResultSet。CONCUR_UPDATABLE，表示可更新的结果集对象。

在该配方的解决方案中，使用了一个 PreparedStatement 对象，创建一个能够生成可滚动结果集的 PreparedStatement 对象的代码如下所示:

```java
pstmt = conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE,
                                                           ResultSet.CONCUR_READ_ONLY);
```

这样创建 PreparedStatement 后，将返回一个可滚动的 ResultSet。您可以使用可滚动的 ResultSet 在多个方向上遍历，方法是调用 ResultSet 方法来指示您想要移动的方向或想要的位置。以下代码行将检索结果集中的第一条记录:

```java
ResultSet rs = pstmt.executeQuery();
rs.first();
```

这个配方的解决方案演示了几种不同的滚动方向。具体来说，您可以看到调用 ResultSet first()、next()、last()和 previous()方法是为了移动到 ResultSet 中的不同位置。有关 ResultSet 对象的完整参考，请参见位于[http://docs . Oracle . com/javase/8/docs/API/Java/SQL/ResultSet . html](http://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html)的在线文档。

可滚动的 ResultSet 对象在应用程序开发中有一席之地。当你需要它们的时候，它们是那些美好事物中的一种，但它们也是你可能不经常需要的东西。

## 13-9.创建可更新的结果集

### 问题

一个应用程序任务查询了数据库并获得了结果。您已经将这些结果存储到一个 ResultSet 对象中，并且希望更新 ResultSet 中的一些值，并将它们提交回数据库。

### 解决办法

使 ResultSet 对象可更新，然后在迭代结果时根据需要更新行。以下示例方法演示了如何使结果集可更新，然后如何更新该结果集中的内容，最终将其保存在数据库中:

```java
private static void queryAndUpdateDbRecipes(String recipeNumber){
        String sql = "SELECT ID, RECIPE_NUMBER, RECIPE_NAME, DESCRIPTION " +
                     "FROM RECIPES " +
                     "WHERE RECIPE_NUMBER = ?";
        ResultSet rs = null;
        try (PreparedStatement pstmt =
                conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);){

            pstmt.setString(1, recipeNumber);
            rs = pstmt.executeQuery();
            while(rs.next()){
                String desc = rs.getString(4);
                System.out.println("Updating row" + desc);

                rs.updateString(4, desc + " -- More to come");
                rs.updateRow();
            }

        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            if (rs != null){
                try {
                    rs.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }
```

这个方法可以称为传递包含配方号的字符串值。假设配方号“13-1”被传递给了这个方法；结果将是以下输出:

```java
Successfully connected
13-1: Connecting to a Database - DriverManager and DataSource Implementations  
13-2: Querying a Database and Retrieving Results - Obtaining and Using Data from a DBMS
13-3: Handling SQL Exceptions - Using SQLException
Updating rowDriverManager and DataSource Implementations  
13-1: Connecting to a Database - DriverManager and DataSource Implementations - More to come
13-2: Querying a Database and Retrieving Results - Obtaining and Using Data from a DBMS
13-3: Handling SQL Exceptions - Using SQLException
```

### 它是如何工作的

有时您需要在解析数据时更新数据。通常这种技术包括测试从数据库返回的值，并在与另一个值比较后更新它们。最简单的方法是通过传递 ResultSet 使 ResultSet 对象可更新。连接对象的 createStatement()或 prepareStatement()方法的 CONCUR_UPDATABLE 常量。这样做会导致语句或 PreparedStatement 生成可更新的结果集。

###### 注意

一些数据库 JDBC 驱动程序不支持可更新的结果集。有关详细信息，请参阅您的 JDBC 驱动程序文档。这段代码是在 Oracle 数据库 11.2 版上使用 Oracle 的 ojdbc6.jar JDBC 驱动程序运行的。

创建将产生可更新结果集的语句的格式是将结果集类型作为第一个参数传递，将结果集并发性作为第二个参数传递。滚动类型必须是 TYPE_SCROLL_SENSITIVE，以确保结果集对所做的任何更新敏感。下面的代码通过创建一个语句对象来演示这种技术，该对象将产生一个可滚动和可更新的 ResultSet 对象:

```java
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
ResultSet.CONCUR_UPDATABLE);
```

创建将生成可更新结果集的 PreparedStatement 的格式是将 SQL 字符串作为第一个参数传递，将结果集类型作为第二个参数传递，将结果集并发性作为第三个参数传递。该配方的解决方案使用以下代码行演示了这种技术:

```java
pstmt = conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_SENSITIVE,
ResultSet.CONCUR_UPDATABLE);
```

本节中讨论的两行代码都将产生可滚动和可更新的 ResultSet 对象。一旦获得了可更新的 ResultSet，就可以像使用普通的 ResultSet 一样获取从数据库中检索到的值。此外，您可以调用 ResultSet 对象的 updateXXX()方法之一来更新 ResultSet 中的任何值。在这个配方的解决方案中，调用了 updateString()方法，将查询值的位置作为第一个参数传递，将更新后的文本作为第二个参数传递。在这种情况下，SQL 查询中列出的第四个元素列将被更新。

```java
rs.updateString(4, desc + " -- More to come");
```

最后，要持久化您已经更改的值，调用 ResultSet updateRow()方法，如这个配方的解决方案所示:

```java
rs.updateRow();
```

创建可更新的结果集并不是您每天都需要做的事情。事实上，您可能永远不需要创建可更新的结果集。然而，对于需要这种策略的情况，这种技术会非常方便。

## 13-10.缓存数据以便在断开连接时使用

### 问题

当处于断开状态时，您希望使用 DBMS 中的数据。也就是说，您正在一台没有连接到数据库的设备上工作，并且您仍然希望能够像连接到数据库一样处理一组数据。例如，您正在便携式设备上处理数据，并且您不在办公室，没有连接。您希望能够查询、插入、更新和删除数据，即使没有连接。一旦连接可用，您希望让您的设备同步断开连接时所做的任何数据库更改。

### 解决办法

使用 CachedRowSet 对象存储要在脱机时使用的数据。这将使您的应用程序能够像连接到数据库一样处理数据。连接恢复或连接回数据库后，将 CachedRowSet 中已更改的数据与数据库存储库同步。下面的示例类演示 CachedRowSet 的用法。在这种情况下，main()方法执行示例。但是，假设没有 main()方法，便携设备上的另一个应用程序将调用该类的方法。遵循示例中的代码，并考虑在未连接到数据库的情况下使用存储在 CachedRowSet 中的结果的可能性。例如，假设您在连接到网络的情况下开始在办公室工作，而现在在办公室之外，网络不稳定，您无法保持与数据库的持续连接:

```java
package org.java9recipes.chapter13.recipe13_10;

import java.sql.Connection;
import java.sql.SQLException;
import javax.sql.rowset.CachedRowSet;
import javax.sql.rowset.RowSetFactory;
import javax.sql.rowset.RowSetProvider;
import javax.sql.rowset.spi.SyncProviderException;
import org.java9recipes.chapter13.recipe13_01.CreateConnection;

public class CachedRowSetExample {

    public static Connection conn = null;
    public static CreateConnection createConn;
    public static CachedRowSet crs = null;

    public static void main(String[] args) {
        boolean successFlag = false;
        try {
            createConn = new CreateConnection();
            conn = createConn.getConnection();
            // Perform Scrollable Query
            queryWithRowSet();

            // Update the CachedRowSet
            updateData();

            // Synchronize changes
            syncWithDatabase();
        } catch (java.sql.SQLException ex) {
            System.out.println(ex);
        } finally {

            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }

    }

    /**
     * Call this method to synchronize the data that has been used in the
     * CachedRowSet with the database
     */
    public static void syncWithDatabase() {
        try {
            crs.acceptChanges(conn);
        } catch (SyncProviderException ex) {
            // If there is a conflict while synchronizing, this exception
            // will be thrown.
            ex.printStackTrace();
        } finally {
            // Clean up resources by closing CachedRowSet
            if (crs != null) {
                try {
                    crs.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }
    }

    public static void queryWithRowSet() {
        RowSetFactory factory;

        try  {

            // Create a new RowSetFactory
            factory = RowSetProvider.newFactory();

            // Create a CachedRowSet object using the factory
            crs = factory.createCachedRowSet();

            // Alternatively populate the CachedRowSet connection settings
            // crs.setUsername(createConn.getUsername());
            // crs.setPassword(createConn.getPassword());
            // crs.setUrl(createConn.getJdbcUrl());

            // Populate a query that will obtain the data that will be used
            crs.setCommand("select id, recipe_number, recipe_name, description from recipes");
            // Set key columns
            int[] keys = {1};
            crs.setKeyColumns(keys);
            crs.execute(conn);

            // You can now work with the object contents in a disconnected state
            while (crs.next()) {
                System.out.println(crs.getString(2) + ": " + crs.getString(3)
                        + " - " + crs.getString(4));
            }

        } catch (SQLException ex) {
            ex.printStackTrace();
        }
    }

    public static boolean updateData() {
        boolean returnValue = false;
        try {
            // Move to the position before the first row in the result set
            crs.beforeFirst();

            // traverse result set
            while (crs.next()) {
                // If the recipe_num equals 11-2 then update
                if (crs.getString("RECIPE_NUMBER").equals("13-2")) {
                    System.out.println("updating recipe 13-2");
                    crs.updateString("description", "Subject to change");
                    crs.updateRow();
                }

            }
          returnValue = true;

          // Move to the position before the first row in the result set
            crs.beforeFirst();

            // traverse result set to see changes
            while (crs.next()) {

                    System.out.println(crs.getString(2) + ": " + crs.getString(3)
                        + " - " + crs.getString(4));

            }

        } catch (SQLException ex) {
            returnValue = false;
            ex.printStackTrace();
        }
        return returnValue;
    }
}
```

运行此示例代码将显示类似于以下代码的输出，尽管文本可能会因数据库中的值而异。请注意，在更新 CachedRowSet 后，配方 13-2 的数据库记录有一个更改的描述。

```java
Successfully connected
13-1: Connecting to a Database - DriverManager and DataSource Implementations - More to Come
13-2: Querying a Database and Retrieving Results - Subject to Change
13-3: Handling SQL Exceptions - Using SQLException
Updating Recipe 13-2
13-1: Connecting to a Database - DriverManager and DataSource Implementations - More to Come
13-2: Querying a Database and Retrieving Results - Obtaining and Using Data from a DBMS
13-3: Handling SQL Exceptions - Using SQLException
```

### 它是如何工作的

如果您在移动设备上工作或旅行，不可能一直保持与互联网的连接。现在有一些设备可以让你在旅途中完成大量的工作，即使你没有直接连接到数据库。在这种情况下，像 CachedRowSet 对象这样的解决方案就可以发挥作用了。CachedRowSet 与常规的 ResultSet 对象相同，只是它不必为了保持可用而保持与数据库的连接。可以查询数据库，获取结果，放入 CachedRowSet 对象中；然后在没有连接到数据库的情况下使用它们。如果在任何时候对数据进行了更改，这些更改可以在以后与数据库同步。

有几种方法可以创建 CachedRowSet。这个配方的解决方案使用 RowSetFactory 来实例化 CachedRowSet。但是，您也可以使用 CachedRowSet 默认构造函数来创建新的实例。这样做将类似于下面的代码行:

```java
CachedRowSet crs = new CachedRowSetImpl();
```

一旦实例化，您需要建立到数据库的连接。还有几种方法可以做到这一点。可以为将要使用的连接设置属性，这个方法的解决方案在注释中演示了这种技术。以下解决方案摘录使用 CachedRowSet 对象的 setUsername()、setPassword()和 setUrl()方法设置连接属性。它们每个都接受一个字符串值，在本例中，该字符串是从 CreateConnection 类获得的:

```java
// Alternatively populate the CachedRowSet connection settings
// crs.setUsername(createConn.getUsername());
// crs.setPassword(createConn.getPassword());
// crs.setUrl(createConn.getJdbcUrl());
```

建立连接的另一种方法是等待查询执行完毕，并将连接对象传递给 executeQuery()方法。这是在解决这个配方时使用的技术。但是在执行查询之前，必须使用 setCommand()方法设置它，该方法接受一个字符串值。在这种情况下，字符串是您需要执行的 SQL 查询:

```java
crs.setCommand("select id, recipe_number, recipe_name, description from recipes");
```

接下来，如果 CachedRowSet 将用于更新，则应使用 setKeys()方法记录主键值。该方法接受一个包含键列位置索引的 int 数组。这些键用于标识唯一的列。在这种情况下，查询中列出的第一列 ID 是主键:

```java
int[] keys = {1};
crs.setKeyColumns(keys);
```

最后，执行查询并使用 execute()方法填充 CachedRowSet。如前所述，execute()方法可选地接受一个连接对象，这允许 CachedRowSet 获得一个数据库连接。

```java
crs.execute(conn);
```

一旦执行了查询并填充了 CachedRowSet，就可以像使用任何其他结果集一样使用它。您可以使用它向前和向后获取记录，或者通过指定您想要检索的行的绝对位置来获取记录。该配方的解决方案仅演示了其中的几种获取方法，但最常用的方法在表 [13-2](#Tab2) 中列出。

###### 表 13-2。CachedRowSet 提取方法

<colgroup class="calibre15"><col class="calibre16"> <col class="calibre16"></colgroup> 
| 

方法

 | 

描述

 |
| --- | --- |
| 首先() | 移动到集合中的第一行。 |
| beforeFirst() | 移动到集合中第一行之前的位置。 |
| 最后一次 | 移动到集合中最后一行之后的位置。 |
| 下一个() | 移动到集合中的下一个位置。 |
| 最后() | 移动到集合的最后一个位置。 |

可以在 CachedRowSet 中插入和更新行。若要插入行，请使用 moveToInsertRow()方法移动到新的行位置。然后使用与您在行中填充的列的数据类型相对应的各种方法[CachedRowSet、updateString()、updateInt()等]来填充行。一旦在行中填充了每个必需的列，就调用 insertRow()方法，然后调用 moveToCurrentRow()方法。以下代码行演示了如何将记录插入到 RECIPES 表中:

```java
crs.moveToInsertRow();
crs.updateInt(1, sequenceValue); // obtain current sequence values with a prior query
crs.updateString(2, “13-x”);
crs.updateString(3, “This is a new recipe title”);
crs.insertRow();
crs.moveToCurrentRow();
```

更新行类似于使用可更新的结果集。只需使用 CachedRowSet 对象的方法[updateString()、updateInt()等]来更新值，这些方法对应于您在行内要更新的列的数据类型。一旦更新了行中的一列或多列，就调用 updateRow()方法。这种技术在这个配方的解决方案中得到了演示。

```java
crs.updateString("description", "Subject to change");
crs.updateRow();
```

若要将任何更新或插入传播到数据库，必须调用 acceptChanges()方法。该方法可以接受一个可选的连接参数，以便连接到数据库。一旦被调用，所有的更改都会被刷新到数据库中。不幸的是，由于自上次为 CachedRowSet 检索数据以来可能已经过了一段时间，因此可能会出现冲突。如果出现这种冲突，将引发 SyncProviderException。您可以捕获这些异常，并使用 SyncResolver 对象手动处理冲突。但是，解决冲突超出了本方法的范围，因此要了解更多信息，请参阅在线文档，该文档可以在 http://download . Oracle . com/javase/tutorial/JDBC/basics/cachedrowset . html 找到。

CachedRowSet 对象为处理数据提供了极大的灵活性，尤其是当您使用的设备并不总是连接到数据库时。然而，在您可以简单地使用标准结果集甚至可滚动结果集的情况下，它们也可能是多余的。

## 13-11.未连接到数据源时联接行集对象

### 问题

您希望在未连接到数据库的情况下联接两个或多个行集。也许您的应用程序被加载到一个并不总是连接到数据库的移动设备上。在这种情况下，您正在寻找一个允许您连接两个或更多查询结果的解决方案。

### 解决办法

使用 JoinRowSet 从两个关系数据库表中获取数据并连接它们。应该将每个要联接的表中的数据提取到一个行集中，然后可以使用 JoinRowSet 根据这些行集中包含的相关元素来联接每个行集对象。例如，假设数据库中有两个相关的表。其中一个表存储作者列表，另一个表包含这些作者撰写的章节列表。这两个表可以使用 SQL 通过主键和外键关系来连接。

###### 注意

*主键*是数据库表的每个记录中的唯一标识符，外键是两个表之间的引用约束。

但是，应用程序不会连接到数据库来进行连接查询，因此必须使用 JoinRowSet 来完成。下面的类清单演示了一种可以使用的策略。在这个场景中，数据库表 BOOK_AUTHOR 的设置如下:

```java
BOOK_AUTHOR(
id          int primary key,
last        varchar(30),
first       varchar(30));

author_work(
id              int primary key,
author_id       int not null,
chapter_number  int not null,
chapter_title   varchar(100) not null,
constraint author_work_fk
foreign key(author_id) references book_author(id));

book(
id          int primary key,
title       varchar(150),
image       varchar(150),
description clob);
```

使用该表的 Java 代码如下:

```java
package org.java9recipes.chapter13.recipe13_11;

import com.sun.rowset.JoinRowSetImpl;
import java.sql.Connection;
import java.sql.SQLException;
import javax.sql.rowset.CachedRowSet;
import javax.sql.rowset.JoinRowSet;
import javax.sql.rowset.RowSetFactory;
import javax.sql.rowset.RowSetProvider;
import org.java9recipes.chapter13.recipe13_01.CreateConnection;

public class JoinRowSetExample {

    public static Connection conn = null;
    public static CreateConnection createConn;
    public static CachedRowSet bookAuthors = null;
    public static CachedRowSet authorWork = null;
    public static JoinRowSet jrs = null;

    public static void main(String[] args) {
        boolean successFlag = false;
        try {
            createConn = new CreateConnection();
            conn = createConn.getConnection();
            // Perform Scrollable Query
            queryBookAuthor();
            queryAuthorWork();

            joinRowQuery();
        } catch (java.sql.SQLException ex) {
            System.out.println(ex);
        } finally {

            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
            if (bookAuthors != null) {
                try {
                    bookAuthors.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
            if (authorWork != null) {
                try {
                    authorWork.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
            if (jrs != null) {
                try {
                    jrs.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }

    }

    public static void queryBookAuthor() {
        RowSetFactory factory;

        try {
            // Create a new RowSetFactory
            factory = RowSetProvider.newFactory();

            // Create a CachedRowSet object using the factory
            bookAuthors = factory.createCachedRowSet();

            // Alternatively populate the CachedRowSet connection settings
            // crs.setUsername(createConn.getUsername());
            // crs.setPassword(createConn.getPassword());
            // crs.setUrl(createConn.getJdbcUrl());

            // Populate a query that will obtain the data that will be used
            bookAuthors.setCommand("SELECT ID, LASTNAME, FIRSTNAME FROM BOOK_AUTHOR");

            bookAuthors.execute(conn);

            // You can now work with the object contents in a disconnected state
            while (bookAuthors.next()) {
                System.out.println(bookAuthors.getString(1) + ": " + bookAuthors.getString(2)
                        + ", " + bookAuthors.getString(3));
            }

        } catch (SQLException ex) {
            ex.printStackTrace();
        }
    }

    public static void queryAuthorWork() {
        RowSetFactory factory;

        try {
            // Create a new RowSetFactory
            factory = RowSetProvider.newFactory();

            // Create a CachedRowSet object using the factory
            authorWork = factory.createCachedRowSet();

            // Alternatively populate the CachedRowSet connection settings
            // crs.setUsername(createConn.getUsername());
            // crs.setPassword(createConn.getPassword());
            // crs.setUrl(createConn.getJdbcUrl());

            // Populate a query that will obtain the data that will be used
            authorWork.setCommand("SELECT AW.ID, AUTHOR_ID, B.TITLE FROM AUTHOR_WORK AW, " +
                    "BOOK B " +
                    "WHERE B.ID = AW.BOOK_ID");

            authorWork.execute(conn);

            // You can now work with the object contents in a disconnected state
            while (authorWork.next()) {
                System.out.println(authorWork.getString(1) + ": " + authorWork.getString(2)
                        + " - " + authorWork.getString(3));
            }

        } catch (SQLException ex) {
            ex.printStackTrace();
        }
    }

    public static void joinRowQuery() {
        try {
            // Create JoinRowSet
            jrs = new JoinRowSetImpl();

            // Add RowSet & Corresponding Keys
            jrs.addRowSet(bookAuthors, 1);
            jrs.addRowSet(authorWork, 2);
            // Alternatively use join-column name
            // jrs.addRowSet(authorWork, "AUTHOR_ID");

            // Traverse Results
            while(jrs.next()){
                System.out.println(jrs.getInt("ID") + ": " +
                                   jrs.getString("TITLE") + " - " +
                                   jrs.getString("FIRSTNAME") + " " +
                                   jrs.getString("LASTNAME"));
            }

        } catch (SQLException ex) {
            ex.printStackTrace();
        }

    }
}
```

运行该类将产生类似如下的输出:

```java
Successfully connected
100: JUNEAU, JOSH
101: DEA, CARL
102: BEATY, MARK
103: GUIME, FREDDY
104: JOHN, OCONNER
105: TESTER, JOE
110: TESTER, JOE
111: OCONNER, JOHN
1: 100 - Java 8 Recipes
2: 100 - Java 7 Recipes
3: 100 - Java EE 7 Recipes
4: 100 - Introducing Java EE 7
5: 103 - Java 7 Recipes
6: 101 - Java 7 Recipes
7: 111 - Java 7 Recipes
8: 102 - Java 7 Recipes
9: 101 - Java FX 2.0 - Introduction by Example
111: Java 7 Recipes - JOHN OCONNER
103: Java 7 Recipes - FREDDY GUIME
102: Java 7 Recipes - MARK BEATY
101: Java FX 2.0 - Introduction by Example - CARL DEA
101: Java 7 Recipes - CARL DEA
100: Introducing Java EE 7 - JOSH JUNEAU
100: Java EE 7 Recipes - JOSH JUNEAU
100: Java 7 Recipes - JOSH JUNEAU
100: Java 8 Recipes - JOSH JUNEAU
```

### 它是如何工作的

JoinRowSet 是两个或多个已填充的行集对象的组合。它可用于根据键/值关系联接两个行集对象，就像 SQL 联接查询一样。为了创建 JoinRowSet，必须首先用相关数据填充两个或多个 RowSet 对象，然后可以将它们分别添加到 JoinRowSet 中以创建组合结果。

在这个菜谱的解决方案中，被查询的表被命名为 BOOK_AUTHOR、BOOK 和 AUTHOR_WORK。BOOK_AUTHOR 表包含作者姓名列表，而 AUTHOR_WORK 表包含书籍列表以及相应的 AUTHOR_ID。图书表包含图书细节。按照 main()方法，首先查询 BOOK_AUTHOR 表，并使用 queryBookAuthor()方法将其结果提取到 CachedRowSet 中。有关使用 CachedRowSet 对象的更多详细信息，请参见配方 13-10。

接下来，调用 queryAuthorBook()方法时，用查询 AUTHOR_WORK 和 BOOK 表的结果填充另一个 CachedRowSet。此时，有两个填充的 CacheRowSet 对象，现在可以使用 JoinRowSet 将它们组合起来。为此，每个查询必须包含一个或多个与另一个表相关的列。在这种情况下，BOOK_AUTHOR。ID 列与 AUTHOR_WORK 相关。AUTHOR_ID 列，因此行集对象必须在这些列值上联接。

main()中调用的最后一个方法是 joinRowQuery()。此方法是所有 JoinRowSet 工作发生的地方。首先，通过实例化 JoinRowSetImpl()对象来创建新的 JoinRowSet:

```java
jrs = new JoinRowSetImpl();
```

###### 注意

使用 JoinRowSetImpl 时，您将收到一个编译时警告，因为它是一个内部的 SUN 专有 API。但是，Oracle 版本是 OracleJoinRowSet，它没有那么通用。

接下来，通过调用其 addRowSet()方法，将两个 CachedRowSet 对象添加到新创建的 JoinRowSet 中。addRowSet()方法接受两个参数。第一个是要添加到 JoinRowSet 的行集对象的名称，第二个是一个 int 值，指示在 CachedRowSet 中的位置，该值包含将用于实现联接的键值。在这个配方的解决方案中，对 addRowSet()的第一次调用传递 bookAuthors CachedRowSet 和数字 1，因为 bookAuthors CachedRowSet 第一个位置的元素对应于 BOOK_AUTHOR。ID 列。对 addRowSet()的第二次调用传递 authorWork CachedRowSet 和编号 2，因为 authorWork CachedRowSet 第二个位置的元素对应于 AUTHOR_WORK。作者 ID 列。

```java
// Add RowSet & Corresponding Keys
jrs.addRowSet(bookAuthors, 1);
jrs.addRowSet(authorWork, 2);
// Alternatively specify the join-column name
jrs.addRowSet(authorWork, "AUTHOR_ID");
```

JoinRowSet 现在可以用来获取连接的结果，就像它是一个普通的行集一样。当调用 JoinRowSet 的相应方法[getString()、getInt()等]时，传递与要存储的数据对应的数据库列的名称:

```java
while(jrs.next()){
System.out.println(jrs.getInt("ID") + ": " +
                   jrs.getString("TITLE") + " - " +
                   jrs.getString("FIRSTNAME") + " " +
                   jrs.getString("LASTNAME"));
}
```

虽然 JoinRowSet 不是每天都需要的，但在对两个相关数据集执行操作时，它会很方便。尤其是当应用程序没有一直连接到数据库时，或者当您试图使用尽可能少的连接对象时。

## 13-12.筛选行集中的数据

### 问题

您的应用程序查询数据库并返回大量的行。缓存结果集中的行数太大，用户无法一次处理。您希望限制可见的行数，以便可以使用从表中查询的不同数据集执行不同的活动。

### 解决办法

使用 FilteredRowSet 查询数据库并存储内容。FilteredRowSet 可以配置为筛选查询返回的结果，以便仅显示您想要查看的行。在下面的示例中，创建了一个 filter 类，该类稍后将用于筛选数据库查询返回的结果。示例中的过滤器用于根据作者的姓氏限制可见的行数。下面的类包含过滤器的实现:

```java
package org.java9recipes.chapter13.recipe13_12;

import java.sql.SQLException;
import javax.sql.RowSet;
import javax.sql.rowset.Predicate;

public class AuthorFilter implements Predicate {

  private String[] authors;
  private String colName = null;
  private int colNumber = -1;

  public AuthorFilter(String[] authors, String colName) {
    this.authors = authors;
    this.colNumber = -1;
    this.colName = colName;
  }

  public AuthorFilter(String[] authors, int colNumber) {
    this.authors = authors;
    this.colNumber = colNumber;
    this.colName = null;
  }

  @Override
  public boolean evaluate(Object value, String colName) {

    if (colName.equalsIgnoreCase(this.colName)) {
        for (String author : this.authors) {
            if (author.equalsIgnoreCase((String)value)) {
                return true;
            }
        }
    }
    return false;
  }

  @Override
  public boolean evaluate(Object value, int colNumber) {

    if (colNumber == this.colNumber) {
        for (String author : this.authors) {
            if (author.equalsIgnoreCase((String)value)) {
                return true;
            }
        }
    }
    return false;
  }

  @Override
  public boolean evaluate(RowSet rs) {

    if (rs == null)
      return false;

    try {
      for (int i = 0; i < this.authors.length; i++) {

        String authorLast = null;

        if (this.colNumber > 0) {
          authorLast = (String)rs.getObject(this.colNumber);
        } else if (this.colName != null) {
          authorLast = (String)rs.getObject(this.colName);
        } else {
          return false;
        }

        if (authorLast.equalsIgnoreCase(authors[i])) {
          return true;
        }
      }
    } catch (SQLException e) {
      return false;
    }
    return false;
  }

}
```

FilteredRowSet 使用该筛选器来限制查询的可见结果。正如您将看到的，利用 FilteredRowSet 可以在应用程序级别以面向对象的方式过滤数据，而不是在 SQL 数据库级别。好处是，您可以实现一系列过滤器，并将它们应用于同一个结果集，返回所需的结果。使用这样的选项消除了执行返回不同数据集的多个数据库查询的需求。

下面的类演示如何实现 FilteredRowSet。main()方法调用一个名为 implement FilteredRowSet()的方法，它包含用于筛选 BOOK_AUTHOR 和 AUTHOR_WORK 表的查询结果的代码，以便只返回来自姓 DEA 和 JUNEAU 的作者的结果:

```java
package org.java9recipes.chapter13.recipe13_12;

import com.sun.rowset.FilteredRowSetImpl;
import java.sql.Connection;
import java.sql.SQLException;
import javax.sql.RowSet;
import javax.sql.rowset.FilteredRowSet;
import org.java9recipes.chapter13.recipe13_01.CreateConnection;

public class FilteredRowSetExample {

    public static Connection conn = null;
    public static CreateConnection createConn;
    public static FilteredRowSet frs = null;

    public static void main(String[] args) {
        boolean successFlag = false;
        try {
            createConn = new CreateConnection();
            conn = createConn.getConnection();
            implementFilteredRowSet();
        } catch (java.sql.SQLException ex) {
            System.out.println(ex);
        } finally {

            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
            if (frs != null) {
                try {
                    frs.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }
    }

    public static void implementFilteredRowSet() {

        String[] authorArray = {"DEA", "JUNEAU"};

        AuthorFilter authorFilter = new AuthorFilter(authorArray, 2);

        try {
            frs = new FilteredRowSetImpl();

            frs.setCommand("SELECT TITLE, LASTNAME "
                    + "FROM BOOK_AUTHOR BA, "
                    + "     AUTHOR_WORK AW, "
                    + "     BOOK B "
                    + "WHERE AW.AUTHOR_ID = BA.ID "
                    + "AND B.ID = AW.BOOK_ID");

            frs.execute(conn);

            System.out.println("Prior to adding filter:");
            viewRowSet(frs);
            System.out.println("Adding author filter:");
            frs.beforeFirst();
            frs.setFilter(authorFilter);
            viewRowSet(frs);
        } catch (SQLException e) {
            e.printStackTrace();
        }

    }

    public static void viewRowSet(RowSet rs) {
        try {
            while (rs.next()) {
                System.out.println(rs.getString(1) + " - "
                        + rs.getString(2));
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
    }
}
```

运行这段代码的结果将类似于下面几行。请注意，FilteredRowSet 只返回与筛选器中列出的作者对应的数据行。

```java
Successfully connected
Prior to adding filter:
Java 7 Recipes - JUNEAU
Java 7 Recipes - BEATY
Java 7 Recipes - DEA
Java 7 Recipes - GUIME
Java 7 Recipes - OCONNER
Java EE 7 Recipes - JUNEAU
Java FX 2.0 - Introduction by Example - DEA
Adding author filter:
Java 7 Recipes - JUNEAU
Java 7 Recipes - DEA
Java EE 7 Recipes - JUNEAU
Java FX 2.0 - Introduction by Example – DEA
```

### 它是如何工作的

通常，数据库查询返回的结果包含大量的行。正如您可能知道的，太多的行会在可视化处理数据时产生问题。通过在 SQL 语句中使用 WHERE 子句来限制查询返回的行数，以便只返回相关的数据，这通常会有所帮助。但是，如果应用程序将数据检索到内存中的行集中，然后需要在没有其他数据库请求的情况下根据各种条件筛选数据，则需要使用查询以外的方法。FilteredRowSet 可用于筛选已填充行集中显示的数据，以便更易于管理。

使用 FilteredRowSet 有两个部分。首先，需要创建一个过滤器，用于指定应该如何过滤数据。过滤器类应该实现谓词接口。可能有多个构造函数，每个构造函数接受一组不同的参数，过滤器可能包含多个 evaluate()方法，每个方法接受不同的参数并包含不同的实现。构造函数应该接受可用于筛选行集的内容数组。它们还应该接受第二个参数，或者是筛选器应该针对的列名，或者是筛选器应该针对的列的位置。在这个配方的解决方案中，过滤器类被命名为 AuthorFilter，它用于根据作者姓名数组过滤数据。它的每个构造函数都接受一个数组，该数组包含要过滤的作者姓名，以及列名或位置。每个 evaluate()方法的任务是确定给定的数据行是否与指定的过滤器匹配；在这种情况下，通过数组传递的作者姓名。如果将列名而不是位置传递给过滤器，则调用第一个 evaluate()方法，如果传递了列位置，则调用第二个 evaluate()方法。最后一个 evaluate()方法接受行集本身，它执行遍历数据并返回一个布尔值的工作，以指示相应的列名/位置值是否与筛选数据匹配。

FilteredRowSet 实现的第二部分是 FilteredRowSet 的工作。这可以在 FilteredRowSetExample 类的 implementFilteredRowSet()方法中看到。FilteredRowSet 实际上将使用您编写的 filter 类来确定要显示哪些行。您可以看到，将传递给 filter 类的值数组是该方法中的第一个声明。第二个声明是过滤器类 AuthorFilter 的实例化。当然，过滤器值的数组和对应于过滤器值的列位置被传递到过滤器构造函数中。

```java
String[] authorArray = {"DEA", "JUNEAU"};

// Creates a filter using the array of authors
AuthorFilter authorFilter = new AuthorFilter(authorArray, 2);
```

若要实例化 FilteredRowSet，请创建 FilteredRowSetImpl 类的新实例。实例化后，只需使用 setCommand()方法设置用于获取结果的 SQL 查询，然后通过调用 executeQuery()方法来执行它。

```java
// Instantiate a new FilteredRowSet
frs = new FilteredRowSetImpl();
// Set the query
frs.setCommand("SELECT TITLE, LASTNAME "
              + "FROM BOOK_AUTHOR BA, "
              + "     AUTHOR_WORK AW, "
              + "     BOOK B "
              + "WHERE AW.AUTHOR_ID = BA.ID "
              + "AND B.ID = AW.BOOK_ID");
// Execute the query
frs.execute(conn);
```

###### 注意

使用 FilteredRowSetImpl 时，您将收到一个编译时警告，因为它是 Sun Microsystems 生产的一个较旧的内部专有 API。

请注意，过滤器尚未应用。实际上，此时您拥有的是一个可滚动的行集，其中填充了来自查询的所有结果。该示例在应用筛选器之前显示这些结果。若要应用过滤器，请使用 setFilter()方法，将过滤器作为参数传递。完成后，FilteredResultSet 将只显示那些与筛选器指定的条件相匹配的行。

同样，FilteredRowSet 技术也有其用武之地，尤其是当您使用的应用程序可能不总是连接到数据库时。它是一个强大的工具，可以用来过滤数据、处理数据，然后应用不同的过滤器并处理新的结果。这类似于在不查询数据库的情况下将 WHERE 子句应用于查询。

## 13-13.查询和存储大型对象

### 问题

您正在开发的应用程序需要存储可以包含无限数量字符的文本字符串。

### 解决办法

当需要存储的字符串非常大时，最好使用字符大对象(CLOB)数据类型来存储文本。RECIPE_TEXT 表的数据库图表如下:

```java
RECIPE_TEXT (
id              int primary key,
recipe_id       int not null,
text            clob,
constraint recipe_text_fk
foreign key (recipe_id)
references recipes(id))
```

以下示例中的代码演示了如何将 CLOB 加载到数据库中以及如何查询它:

```java
package org.java9recipes.chapter13.recipe13_13;

import java.sql.Clob;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import org.java9recipes.chapter13.recipe13_01.CreateConnection;

public class LobExamples {

    public static Connection conn = null;
    public static CreateConnection createConn;

    public static void main(String[] args) {
        boolean successFlag = false;
        try {
            createConn = new CreateConnection();
            conn = createConn.getConnection();
            loadClob();
            readClob();
        } catch (java.sql.SQLException ex) {
            System.out.println(ex);
        } finally {

            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }

        }
    }

    public static void loadClob() {
        Clob textClob = null;
        String sql = "INSERT INTO RECIPE_TEXT VALUES("
                    + "next value for recipe_text_seq, "
                    + "(select id from recipes where recipe_number = '13-1'), "
                    + "?)";
        try (PreparedStatement pstmt = conn.prepareStatement(sql);) {
            textClob = conn.createClob();
            textClob.setString(1, "This will be the recipe text in clob format");
            // obtain the sequence number in real world
            // set the clob value
            pstmt.setClob(1, textClob);
            pstmt.executeUpdate();

        } catch (SQLException ex) {
            ex.printStackTrace();
        }
    }

    public static void readClob() {
        String qry = "select text from recipe_text";
        Clob theClob = null;
        try(PreparedStatement pstmt = conn.prepareStatement(qry);
                ResultSet rs = pstmt.executeQuery();) {

            while (rs.next()) {
                theClob = rs.getClob(1);
                System.out.println("Clob length: " + theClob.length());
                System.out.println(theClob.toString());
            }
            System.out.println(theClob.toString());

        } catch (SQLException ex) {

            ex.printStackTrace();
        }
    }
}
```

### 它是如何工作的

如果您的应用程序需要存储字符串值，您需要知道这些字符串可能会有多大。对于 VARCHAR 字段的存储大小，大多数数据库都有一个上限。例如，Oracle 数据库的上限为 2，000 个字符，超过这个长度的部分将被删除。如果需要存储大量文本，请在数据库中使用 CLOB 字段。

在 Java 代码中，CLOB 的处理方式与字符串略有不同。事实上，在最初几次使用它时，实际上有点奇怪，因为您必须从一个连接创建 CLOB。

###### 注意

实际上，CLOBs 和 BLOBs(二进制大型对象)并不存储在定义它们的 Oracle 表中。相反，大型对象(LOB)定位器存储在表列中。Oracle 可能会将 CLOB 放在数据库服务器上的一个单独文件中。当 Java 创建 Clob 对象时，它可以用来保存更新到数据库中特定 lob 位置的数据，或者从数据库中特定 LOB 位置检索数据。

让我们来看看这个菜谱的解决方案中包含的 loadClob()方法。如您所见，Clob 对象是使用 Connection createClob()方法创建的。一旦创建了 Clob，就可以使用 setString()方法设置它的内容，方法是传递指示放置字符串的位置和文本字符串本身:

```java
textClob = conn.createClob();
textClob.setString(1, "This will be the recipe text in clob format");
```

一旦创建并填充了 Clob，只需使用 PreparedStatement setClob()方法将其传递给数据库。在本例中，PreparedStatement 像往常一样通过调用 executeUpdate()方法在 RECIPE_TEXT 表中执行数据库插入。

查询 Clob 也相当简单。正如您在这个配方的解决方案中包含的 readClob()方法中看到的，建立了一个 PreparedStatement 查询，并将结果检索到一个 ResultSet 中。使用 Clob 和字符串之间的唯一区别是，您必须将 Clob 加载到 Clob 类型中。

###### 注意

调用 Clob getString()方法将传递一个看起来很有趣的文本字符串，它表示一个 Clob 对象。因此，调用 Clob 对象的 getAsciiStream()方法将返回存储在 Clob 中的实际数据。

虽然 Clobs 很容易使用，但是需要额外的几个步骤来准备。最好相应地规划您的应用程序，并尝试估计您使用的数据库字段是否由于大小限制而需要 CLOBs。适当的规划将防止您回头修改标准的基于字符串的代码来使用 Clobs。

## 13-14.调用存储过程

### 问题

应用程序所需的一些逻辑被编写为数据库存储过程。您需要能够从应用程序中调用存储过程。

### 解决办法

下面的代码块显示了创建 Java 将调用的存储过程所需的 PL/SQL。这个存储过程的功能非常小；它只是接受一个值，并将该值赋给一个 OUT 参数，以便程序可以显示它:

```java
create or replace procedure dummy_proc (text IN VARCHAR2,
                                        msg OUT VARCHAR2) as
begin
    -- Do something, in this case the IN parameter value is assigned to the OUT parameter
    msg :=text;
end;
```

下面代码中的 CallableStatement 执行数据库中包含的这个存储过程，并传递必要的参数。然后，OUT 参数的结果会显示给用户。

```java
try(CallableStatement cs = conn.prepareCall("{call DUMMY_PROC(?,?)}");) {       
    cs.setString(1, "This is a test");
    cs.registerOutParameter(2, Types.VARCHAR);
    cs.executeQuery();

    System.out.println(cs.getString(2));

} catch (SQLException ex){
    ex.printStackTrace();
}
```

运行这个菜谱的示例类将显示以下输出，它与输入相同。这是因为 DUMMY_PROC 过程只是将 IN 参数的内容分配给 OUT 参数。

```java
Successfully connected
This is a test
```

### 它是如何工作的

对于应用程序来说，将数据库存储过程用于可以在数据库中直接执行的逻辑并不少见。为了从 Java 调用数据库存储过程，必须创建一个 CallableStatement 对象，而不是使用 PreparedStatement。在这个配方的解决方案中，一个 CallableStatement 调用一个名为 DUMMY_PROC 的存储过程。实例化 CallableStatement 的语法类似于使用 PreparedStatement 的语法。使用 Connection 对象的 prepareCall()方法，将调用传递给存储过程。存储过程调用必须用花括号{}括起来，否则应用程序将引发异常。

```java
cs = conn.prepareCall("{call DUMMY_PROC(?,?)}");
```

一旦实例化了 CallableStatement，就可以像 PreparedStatement 一样使用它来设置参数值。但是，如果某个参数在数据库存储过程中注册为 OUT 参数，则必须调用一个特殊的方法 registerOutParameter()，传递要注册的 OUT 参数的参数位置和数据库类型。在这个配方的解决方案中，OUT 参数在第二个位置，它的类型是 VARCHAR。

```java
cs.registerOutParameter(2, Types.VARCHAR);
```

若要执行存储过程，请对 CallableStatement 调用 executeQuery()方法。完成后，您可以通过调用对应于数据类型的 CallableStatement getXXX()方法来查看 OUT 参数的值:

```java
    System.out.println(cs.getString(2));
```

###### 关于存储函数的一个注记

调用存储数据库函数本质上与调用存储过程相同。但是，prepareCall()的语法略有修改。若要调用存储函数，请将花括号中的调用改为使用？性格。例如，假设一个名为 DUMMY_FUNC 的函数接受一个参数并返回一个值。下面的代码将用于进行调用并返回值:

```java
cs = conn.prepareCall("{? = call DUMMY_FUNC(?)}");
cs.registerOutParameter(1, Types.VARCHAR);
cs.setString(2, "This is a test");
cs.execute();
```

对 cs.getString(1)的调用将检索返回值。

## 13-15.获取数据库使用的日期

### 问题

您希望正确转换 LocalDate，以便将其插入到数据库记录中。

### 解决办法

利用静态 java.sql.Date . value of(LocalDate)方法将 local date 对象转换为 Java . SQL . date 对象，JDBC 可以利用该对象插入或查询数据库。在下面的示例中，当前日期被插入到日期类型的数据库列中。

```java
private static void insertRecord(
        String title,
        String publisher) {
    String sql = "INSERT INTO PUBLICATION VALUES("
            + "NEXT VALUE FOR PUBLICATION_SEQ, ?,?,?,?)";
    LocalDate pubDate = LocalDate.now();
    try (Connection conn = createConn.getConnection();
            PreparedStatement pstmt = conn.prepareStatement(sql);) {
        pstmt.setInt(1, 100);
        pstmt.setString(2, title);
        pstmt.setDate(3,  **java.sql.Date.valueOf(pubDate)**);
        pstmt.setString(4, publisher);
        pstmt.executeUpdate();
        System.out.println("Record successfully inserted.");
    } catch (SQLException ex) {
        ex.printStackTrace();
    }
}
```

### 它是如何工作的

在 Java 8 中，新的日期时间 API(第 4 章[第 4 章](04.html))是处理日期和时间的首选 API。因此，当处理日期值和数据库时，JDBC API 必须在 SQL 日期和新的日期时间 LocalDate 对象之间进行转换。这个配方的解决方案演示了如何从 LocalDate 对象获取 java.sql.Date 的实例，只需调用静态 java.sql.Date.valueOf()方法，传递相关的 LocalDate 对象。

## 13-16.自动关闭资源

### 问题

与其在每次数据库调用时手动打开和关闭资源，不如让应用程序为您处理这些样板代码。

### 解决办法

使用 try-with-resources 语法自动关闭您打开的资源。下面的代码块使用这种策略，在使用完连接、语句和结果集资源后自动关闭它们:

```java
String qry = "select recipe_number, recipename, description from recipes";

try (Connection conn = createConn.getConnection();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery(qry);) {

    while (rs.next()) {
        String recipe = rs.getString("RECIPE_NUMBER");
        String name = rs.getString("RECIPE_NAME");
        String desc = rs.getString("DESCRIPTION");

        System.out.println(recipe + "\t" + name + "\t" + desc);
    }
} catch (SQLException e) {
    e.printStackTrace();
}
```

运行此代码产生的输出应该类似于以下内容:

```java
Successfully connected
13-1    Connecting to a Database        DriverManager and DataSource Implementations - More to Come
13-2    Querying a Database and Retrieving Results       Subject to Change
13-3    Handling SQL Exceptions Using SQLException
```

### 它是如何工作的

管理 JDBC 资源一直是件令人头疼的事情。当不再需要资源时，关闭资源需要大量的样板代码。自从 Java SE 7 发布以来，情况就不是这样了。Java 7 引入了使用 try-with-resources 的自动资源管理。通过使用这种技术，开发人员不再需要手动关闭每个资源，这种改变可以减少许多行代码。

为了使用这种技术，您必须实例化您希望在 try 子句后的一组括号中启用自动处理的所有资源。在这个配方的解决方案中，声明的资源是连接、语句和结果集。

```java
try (Connection conn = createConn.getConnection();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery(qry);) {
```

一旦这些资源超出范围，它们就会自动关闭。这意味着不再需要编写 finally 块来确保关闭资源。自动资源处理不仅适用于数据库工作，还适用于任何符合新的 java.lang.Autocloseable API 的资源。文件 I/O 等其他操作也遵循新的 API。java.lang.Autoclosable 中有一个 close()方法管理资源的关闭。实现 java.io.Closeable 接口的类可以遵守 API。

### 摘要

在许多应用中，数据库对于存储重要信息已经变得必不可少。因此，很好地理解如何在应用程序中使用数据库是很重要的。本章从头开始，涵盖了数据库访问入门的诀窍。然后讨论了一些重要的主题，比如如何安全地访问和修改数据、事务管理以及在没有连接到网络时的数据访问。现在，您应该对 Java 解决方案中的一些数据处理技术有了很好的理解。请记住，有许多数据访问解决方案，本章中的方法只是解决信息管理这个大问题的一些方法。