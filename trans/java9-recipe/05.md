乔希·朱诺号 2017

乔希·朱诺号，Java 9 食谱，10.1007/978-1-4842-1976-8_5

# 5.面向对象的 Java

乔希·朱诺号

(一)美国伊利诺伊州辛克利

自从应用程序开发的第一天以来，编程语言已经发生了很大的变化。过去，过程语言是最先进的；事实上，今天仍有成千上万的 COBOL 和其他程序应用程序在使用。随着时间的推移，编码变得更加高效，重用、封装、抽象和其他面向对象的特性成为应用程序开发的关键。随着语言的发展，它们开始融入在程序中使用对象的思想。早在 20 世纪 70 年代，Lisp 语言就引入了一些面向对象的技术，但是真正的面向对象编程直到 20 世纪 90 年代才大获成功。

面向对象的程序由许多不同的代码组成，它们一起协同工作。面向对象的哲学不是编写包含一长串语句和命令的程序，而是将功能分解成独立的有组织的对象。每个对象都包含与其相关的功能，当这些对象被组合在一起时，它们可以被用来开发复杂的解决方案。随着人们注意到面向对象等同于生产力，诸如使用方法封装功能和重用另一个类的功能等编程技术开始流行起来。

在这一章中，我们将触及 Java 语言的一些关键的面向对象的特性。从涵盖访问修饰符的基本方法，到处理内部类的高级方法，本章包含的方法将帮助你理解 Java 的面向对象方法。

## 5-1.控制对类成员的访问

### 问题

你想创建一个不能从任何其他类访问的类的成员。

### 解决办法

创建私有实例成员，而不是将它们提供给其他类(公共的或受保护的)。例如，假设您正在创建一个应用程序，它将用于管理一项运动的一组运动员。您创建了一个名为 Player 的类，它将用于表示团队中的一名球员。您不希望从任何其他类访问该类的字段。下面的代码演示了一些实例成员的声明，使它们只能从定义它们的类中访问。

```
private String firstName = null;
private String lastName = null;
private String position = null;
private int status = -1;
```

### 它是如何工作的

若要将类成员指定为私有，请使用 private 关键字作为其声明或签名的前缀。private 访问修饰符用于隐藏类的成员，这样外部类就不能访问它们。任何被标记为私有的类成员将只对同一类的其他成员可用。任何外部类都不能访问被指定为私有的字段或方法，使用代码完成的集成开发环境(ide)也不能看到它们。

正如在这个方法的解决方案中提到的，在声明一个类的成员时，有三种不同的访问修饰符可以使用。这些修饰符是公共的、受保护的和私有的。声明为公共的成员可用于任何其他类。那些被声明为受保护的类可用于同一个包中的任何其他类。最好只将那些需要从另一个类直接访问的类成员声明为 public 或 protected。使用 private access 修饰符隐藏类的成员有助于实施更好的面向对象。

## 5-2.使私有字段可供其他类访问

### 问题

您希望创建私有实例成员，以便外部类不能直接访问它们。但是，您也希望以受控的方式访问这些私有成员。

### 解决办法

通过设置 getters 和 setters 来访问私有字段，从而封装私有字段。下面的代码演示了私有字段的声明，后面是可用于从外部类获取或设置该字段值的访问器(getter)和赋值器(setter)方法:

```
private String firstName = null;
/**
 * @return the firstName
 */
public String getFirstName() {
 return firstName;
}

/**
 * @param firstName the firstName to set
 */
public void setFirstName(String firstName) {
    this.firstName = firstName;
}
```

外部类可以使用 getFirstName()方法来获取 FirstName 字段的值。同样，外部类可以使用 setFirstName(String firstName)方法来设置 FirstName 字段的值。

### 它是如何工作的

通常，当字段在类中被标记为私有时，它们仍然需要被外部类访问，以便设置或检索它们的值。为什么不直接处理这些字段，然后将它们公开呢？直接处理其他类的字段并不是好的编程实践，因为通过使用访问器(getters)和赋值器(setters)，可以以受控的方式授予访问权限。通过不直接针对另一个类的成员进行编码，您还可以帮助分离代码，这有助于确保如果一个对象发生更改，依赖于它的其他对象不会受到负面影响。正如您在这个菜谱的解决方案的例子中所看到的，隐藏字段并使用公共方法来访问这些字段是相当容易的。简单地创建两个方法；一个用于获取私有字段的值，即“getter”或访问器方法。另一个用于设置私有字段的值，即“setter”或 mutator 方法。在这个配方的解决方案中，getter 用于返回私有字段中包含的未更改的值。类似地，setter 用于设置私有字段的值，方法是接受与私有字段具有相同数据类型的参数，然后将私有字段的值设置为该参数的值。

使用 getters 或 setters 访问字段的类不知道方法背后的任何细节。例如，如果需要，getter 或 setter 方法可以包含更多的功能。此外，可以更改这些方法的细节，而无需更改访问它们的任何代码。

###### 注意

使用 getters 和 setters 并不能完全分离代码。事实上，许多人认为使用 getters 和 setters 不是一个好的编程实践。使用访问器方法的对象仍然需要知道它们正在处理的实例字段的类型。也就是说，getters 和 setters 是提供对对象私有实例字段的外部访问的标准技术。要以更面向对象的方式使用访问器方法，请在接口中声明它们，并针对接口而不是对象本身进行编码。有关接口的更多信息，请参考配方 5-6。

## 5-3.创建具有单个实例的类

### 问题

您希望创建一个在整个应用程序中只能有一个实例的类，这样所有应用程序用户都可以与该类的同一个实例进行交互。

### 解决方案 1

使用单例模式创建类。实现 Singleton 模式的类只允许该类的一个实例，并提供对该实例的单点访问。假设您想要创建一个统计类，用于计算一项有组织的运动中每个队和运动员的统计数据。在应用程序中拥有这个类的多个实例是没有意义的，所以您希望将 Statistics 类创建为一个 Singleton，以防止生成多个实例。下列类别代表单一模式:

```
package org.java9recipes.chapter5.recipe5_03;

import java.util.ArrayList;
import java.util.List;
import java.io.Serializable;

public class Statistics implements Serializable {

// Definition for the class instance
private static volatile Statistics instance = new Statistics();

private List teams = new ArrayList();

/**
 * Constructor has been made private so that outside classes do not have
 * access to instantiate more instances of Statistics.
 */
private Statistics(){
}

/**
 * Accessor for the statistics class.  Only allows for one instance of the
 * class to be created.
 * @return
 */
public static Statistics getInstance(){

    return instance;
}

/**
 * @return the teams
 */
public List getTeams() {
    return teams;
}

/**
 * @param teams the teams to set
 */
public void setTeams(List teams) {
    this.teams = teams;
}
protected Object readResolve(){
        return instance;
    }
} 
```

如果另一个类试图创建该类的一个实例，它将使用 getInstance()访问器方法来获取 Singleton 实例。值得注意的是，解决方案代码演示了急切实例化，这意味着实例将在加载单例时被实例化。对于惰性实例化，它将在第一次请求时被实例化，您必须注意同步 getInstance()方法以使它是线程安全的。下面的代码演示了一个惰性实例化的示例:

```
public static Statistics getInstance(){
    synchronized(Statistics.class){
        if (instance == null){
            instance = new Statistics();
        }
    }
    return instance;
}
```

### 解决方案 2

首先，创建一个枚举，并在其中声明一个名为 INSTANCE 的元素。接下来，在枚举中声明其他字段，这些字段可用于存储应用程序所需的值。以下枚举表示将提供与解决方案 1 相同功能的单例:

```
import java.util.ArrayList;
import java.util.List;

public enum StatisticsSingleton {
    INSTANCE;

    private List teams = new ArrayList();

    /**
     * @return the teams
     */
    public List getTeams() {
        return teams;
    }

    /**
     * @param teams the teams to set
     */
    public void setTeams(List teams) {
        this.teams = teams;
    }
}
```

###### 注意

recipe5_03 包中有一个测试类，您可以使用它来处理 enum Singleton 解决方案。

### 它是如何工作的

Singleton 模式用于创建不能被任何其他类实例化的类。当您只想将某个类的一个实例用于整个应用程序时，这很有用。可以通过以下三个步骤将单例模式应用于一个类。首先，将类的构造函数设为私有，这样外部类就不能实例化它。接下来，定义一个私有静态 volatile 字段，它将表示该类的一个实例。volatile 关键字保证每个线程使用相同的实例。创建类的实例，并将其分配给字段。在该配方的解决方案中，类名为 Statistics，字段定义如下:

```
private static volatile Statistics instance = new Statistics();
```

最后，实现一个名为 getInstance()的访问器方法，该方法只返回实例字段。下面的代码演示了这样一种访问器方法:

```
public static Statistics getInstance(){
    return instance;
}
```

要使用另一个类中的 Singleton，调用 Singleton 的 getInstance()方法。这将返回类的一个实例。下面的代码显示了另一个类的示例，该类获取了该配方的解决方案 1 中定义的 Statistics Singleton 的一个实例。

```
Statistics statistics = Statistics.getInstance();
List teams = statistics.getTeams();
```

任何调用该类的 getInstance()方法的类都将获得相同的实例。因此，对于整个应用程序中对 getInstance()的每次调用，Singleton 中包含的字段都具有相同的值。

如果单例被序列化然后反序列化会发生什么？这种情况可能会导致在反序列化时返回对象的另一个实例。为了防止此问题发生，请确保实现 readResolve()方法，如解决方案 1 中所示。当对象被反序列化时调用此方法，简单地返回实例可以确保不会生成另一个实例。

解决方案 2 展示了一种创建单例的不同方法，即使用 Java enum 而不是类。使用这种方法是有益的，因为 enum 提供序列化，禁止多重实例化，并允许您更简洁地处理代码。为了实现枚举单例，创建一个枚举并声明一个实例元素。这是一个静态常数，它将把枚举的实例返回给引用它的类。然后，您可以将元素添加到应用程序中的其他类可以用来存储值的枚举中。

与任何编程解决方案一样，有不止一种方法来做事情。有些人认为解决方案 1 中展示的标准单例模式不是最理想的解决方案。其他人出于不同的原因不喜欢 enum 解决方案。这两种方法都可以，尽管你可能会发现在某些情况下一种比另一种更有效。

## 5-4.生成类的实例

### 问题

在您的一个应用程序中，您想提供动态生成对象实例的能力。对象的每个实例都应该可以使用，对象创建者不需要知道对象创建的细节。

### 解决办法

利用工厂方法模式实例化类的实例，同时从对象创建者那里抽象出创建过程。创建工厂将使类的新实例能够在调用时返回。下面的类表示一个简单的工厂，它在每次调用其 createPlayer(String)方法时返回 Player 子类的一个新实例。返回的 Player 子类取决于传递给 createPlayer 方法的字符串值。

```
public class PlayerFactory {

    public static Player createPlayer(String playerType){
        Player returnType;
        switch(playerType){
        case "GOALIE":
            returnType = new Goalie();
            break;
        case "LEFT":
            returnType = new LeftWing();
            break;
        case "RIGHT":
            returnType = new RightWing();
            break;
        case "CENTER":
            returnType = new Center();
            break;
        case "DEFENSE":
            returnType = new Defense();
            break;
        default:
            returnType = new AllPlayer();
        }
        return returnType;
    }
}
```

如果一个类想要使用该工厂，它只需调用静态 createPlayer 方法，传递一个表示 Player 新实例的字符串值。下面的代码代表了一个 Player 子类；其他的可能非常相似:

```
public class Goalie extends Player implements PlayerType {

    private int totalSaves;

    public Goalie(){
        this.setPosition("GOALIE");
    }

    /**
     * @return the totalSaves
     */
    public int getTotalSaves() {
        return totalSaves;
    }

    /**
     * @param totalSaves the totalSaves to set
     */
    public void setTotalSaves(int totalSaves) {
        this.totalSaves = totalSaves;
    }
}
```

其他每个球员子类都非常类似于守门员类。需要注意的最重要的代码是工厂方法 createPlayer，它可用于创建 Player 类的新实例。

###### 注意

为了进一步说明这个例子，您可以限制可以访问的方法。通过返回 PlayerType 类型的对象，并且只在该接口中声明可访问的方法，可以做到这一点。

### 它是如何工作的

工厂用于生成对象。它们通常用于从对象的创建者那里抽象出对象的实际创建。当创建者不需要知道生成新对象的实际实现细节时，这非常方便。当需要对对象的创建进行受控访问时，工厂模式也很有用。为了实现工厂，创建一个包含至少一个用于返回新创建的对象的方法的类。

在这个配方的解决方案中，PlayerFactory 类包含一个名为 createPlayer(String)的方法，该方法返回一个新创建的 Player 对象。这个方法在幕后不做任何特别的事情；它只是根据传递给该方法的字符串值实例化一个新的播放器实例。另一个可以访问 PlayerFactory 类的对象可以使用 createPlayer 返回新的 Player 对象，而无需知道该对象是如何创建的。虽然在 createPlayer 方法的情况下这并没有隐藏太多，但是 PlayerFactory 抽象了正在实例化的类的细节，因此开发人员只需担心如何获得新的 Player 对象。

工厂模式是控制如何创建对象的一种有效方式，它使创建某种类型的对象变得更加容易。想象一下，如果一个对象的构造函数接受的不仅仅是几个参数；创建不仅仅需要几个参数的新对象会变得很麻烦。生成一个工厂来创建这些对象，这样您就不必对每个实例化的所有参数进行硬编码，这样可以提高您的工作效率！

## 5-5.创建可重用对象

### 问题

您希望生成一个对象，用于表示应用程序中的某些内容。此外，您希望能够重用该对象来表示多个实例。例如，假设您正在创建一个应用程序，用于为不同的运动队生成统计数据和联盟信息。在这种情况下，您想要创建一个可以用来表示团队的对象。

### 解决办法

创建一个 JavaBean，它可以用来表示您想要创建的对象。JavaBean 对象提供了将对象字段声明为私有的能力，并且它们还允许读取和更新属性，以便可以在应用程序中传递和使用对象。这个菜谱演示了一个名为 Team 的 JavaBean 的创建。团队对象包含几个不同的字段，这些字段可以包含信息:

```
public class Team implements TeamType {

    private List<Player> players;
    private String name = null;
    private String city = null;

    /**
     * @return the players
     */
    public List<Player> getPlayers() {
        return players;
    }

    /**
     * @param players the players to set
     */
    public void setPlayers(List<Player> players) {
        this.players = players;
    }

    /**
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return the city
     */
    public String getCity() {
        return city;
    }

    /**
     * @param city the city to set
     */
    public void setCity(String city) {
        this.city = city;
    }

}
```

正如您所看到的，这个解决方案中的对象包含三个字段，每个字段都被声明为 private。然而，每个字段都有两个访问器方法――getter 和 setter――允许字段被间接访问。

### 它是如何工作的

JavaBean 是一个用来保存信息的对象，这样就可以在应用程序中传递和使用信息。JavaBean 最重要的方面之一是它的字段被声明为私有的。这禁止其他类直接访问这些字段。相反，每个字段应该由定义的方法封装，以便其他类可以访问它们。这些方法必须遵循以下命名约定:

*   用于访问字段数据的方法应该使用前缀 get，后跟字段名来命名。

*   用于设置字段数据的方法应该使用前缀 set 命名，后跟字段名。

例如，在这个菜谱的解决方案中，Team 对象包含一个包含玩家姓名的字段。为了访问该字段，应该声明一个名为 getPlayers 的方法。该方法应该返回包含在玩家字段中的数据。同样，要填充 players 字段，应该声明一个名为 setPlayers 的方法。该方法应该接受与 players 字段类型相同的参数，并且应该将 players 字段的值设置为等于该参数。这可以在下面的代码中看到:

```
public List<Player> getPlayers() {
    return players;
}

void setPlayers(List<Player> players) {
    this.players = players;
}
```

JavaBeans 可用于填充数据列表、写入数据库记录或用于无数其他功能。使用 JavaBeans 使得代码更容易阅读和维护。它还有助于增加未来代码增强的可能性，因为只需要很少的代码实现。使用 JavaBeans 的另一个好处是大多数主流 ide 会自动完成字段的封装。

## 5-6.为类定义接口

### 问题

您希望创建一组方法签名和字段，这些方法签名和字段可以用作公共模板来公开类实现的方法和字段。

### 解决办法

生成一个 Java 接口来声明一个类必须实现的每个字段和方法。这样的接口可以由一个类实现，并用来表示一个对象类型。以下代码是一个接口，用于声明 Team 对象必须实现的方法:

```
public interface TeamType {

    void setPlayers(List<Player> players);
    void setName(String name);
    void setCity(String city);
    String getFullName();
}
```

接口中的所有方法都是隐式抽象的。也就是说，只提供了方法签名。还可以在接口中包含静态最终字段声明。

### 它是如何工作的

Java 接口是一种用于定义结构的构造，无论是类必须实现的字段还是方法。在大多数情况下，接口不包括任何方法实现；相反，它们只包含方法签名。接口可以包含隐式静态和最终变量。

###### 注意

从 Java SE 8 开始，接口可以包含方法实现。这种方法被称为*默认方法。*更多详情见制作方法 5-7。

在这个配方的解决方案中，接口不包括任何常量字段声明。但是，它包括四个方法签名。所有方法签名都没有指定访问修饰符，因为接口中的所有声明都是隐式公共的。接口用于公开一组功能；因此，接口中公开的所有方法都必须是隐式公共的。任何实现接口的类都必须为接口中声明的任何方法签名提供实现，除了默认方法和抽象类(更多细节见方法 5-7 和 5-13)，在这种情况下，接口可以为它的一个子类留下实现。

虽然 Java 语言不允许多重继承，但是一个 Java 类可以实现多个接口，从而允许受控形式的多重继承。抽象类也可以实现接口。下面的代码演示了一个实现接口的类:Team 对象声明实现了 TeamType 接口。

```
public class Team implements TeamType {

    private List<Player> players;
    private String name;
    private String city;

    /**
     * @return the players
     */
    public List<Player> getPlayers() {
        return players;
    }

    /**
     * @param players the players to set
     */
    public void setPlayers(List<Player> players) {
        this.players = players;
    }

    /**
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
} 

    /**
     * @return the city
     */
    public String getCity() {
        return city;
    }

    /**
     * @param city the city to set
     */
    public void setCity(String city) {
        this.city = city;
    }

public String getFullName() {
        return this.name + " - " + this.city;
    }

}
```

接口可以用来声明对象的类型。任何声明为具有接口类型的对象都必须遵循接口中声明的所有实现，除非存在默认实现。例如，下面的字段声明定义了一个包含所有在 TeamType 接口中声明的属性的对象:

```
TeamType team;
```

接口也可以扩展其他接口(因此多重继承提供了相同类型的理论)。但是，由于接口中没有方法实现，因此在 Java 类中实现多个接口比在 C++中扩展多个类要安全得多。

接口是 Java 语言最重要的结构之一。它们提供了用户和类实现之间的接口。尽管不使用接口也可以创建完整的应用程序，但它们有助于促进面向对象，并对其他类隐藏方法实现。

## 5-7.在不破坏现有代码的情况下修改接口

### 问题

您已经有了一个实现接口的实用程序类，并且实用程序库中的许多不同的类都实现了该接口。假设您想向实用程序类添加一个新方法，并通过它的接口使它可供其他类使用。但是，如果更改接口，可能会破坏一些已经实现该接口的现有类。

### 解决办法

将新方法及其实现作为默认方法添加到实用程序类接口中。通过这样做，实现该接口的每个类将自动获得对新方法的使用，并且不会被强制实现它，因为存在默认实现。下面的类接口包含一个默认方法，任何实现该接口的类都可以使用该方法。

```
public interface TeamType {

    List<Player> getPlayers();

    void setPlayers(List<Player> players);

    void setName(String name);

    void setCity(String city);

    String getFullName();

    default void listPlayers() {
        getPlayers().stream().forEach((player) -> {
            System.out.println(player.getFirstName() + " " + player.getLastName());
        });
    }

}
```

接口 TeamType 包含一个名为 listPlayers()的默认方法。这个方法不需要由任何实现 TeamType 的类来实现，因为接口中包含了一个默认的实现。

### 它是如何工作的

在以前的 Java 版本中，接口只能包含方法签名和常量变量。不可能在接口中定义方法实现。这在大多数情况下工作良好，因为接口是一种旨在加强类型安全和抽象实现细节的构造。但是，在某些情况下，允许接口包含默认方法实现是有益的。例如，如果有许多类实现了一个现有的接口，那么如果该接口被更改，许多代码可能会被破坏。这将造成向后兼容不可能的情况。在这种情况下，将一个默认的方法实现放在一个接口中是有意义的，而不是强制所有的类实现一个放在接口中的新方法。这就是为什么缺省方法变得必不可少，并且包含在 Java 8 版本中的原因。

要在接口中创建默认方法(也称为“defender 方法”)，请在方法签名中使用关键字 default，并包含一个方法实现。一个接口可以包含零个或多个默认方法。在这个配方的解决方案中，listPlayers()方法是 TeamType 接口中的默认方法，任何实现 TeamType 的类都将自动继承默认实现。理论上，任何实现 TeamType 的类都不会受到 listPlayers()默认方法的影响。这使人们能够在不破坏向后兼容性的情况下更改接口，这具有很大的价值。

###### 注意

从 Java 9 开始，可以在接口中创建私有方法。私有方法只能由同一接口中的默认方法使用。因此，如果您有一些在两个或更多默认方法中重复的代码，那么可重复的代码可以封装在私有方法中。

## 5-8.用不同的值构造同一类的实例

### 问题

您的应用程序需要能够构造同一对象的实例，但是每个对象实例需要包含不同的值，从而创建同一对象的不同类型。

### 解决办法

利用构建器模式，通过一步一步的过程构建同一对象的不同类型。例如，假设您有兴趣为一个体育联盟创建不同的团队。每个团队必须包含相同的属性，但是这些属性的值因团队而异。因此，您创建了许多相同类型的对象，但是每个对象都是唯一的。下面的代码演示了 builder 模式，该模式可用于创建所需的团队。

首先，您需要定义每个团队需要包含的一组属性。为此，应该创建一个 Java 接口，包含需要应用于每个团队对象的不同属性。以下是这种界面的一个示例:

```
public interface TeamType {

    public void setPlayers(List<Player> players);
    public void setName(String name);
    public void setCity(String city);
    public String getFullName();

}
```

接下来，定义一个类来代表一个团队。这个类需要实现刚刚创建的 TeamType 接口，这样它将遵循构建团队所需的格式:

```
public class Team implements TeamType {

    private List<Player> players;
    private String name = null;
    private String city = null;
    private int wins = 0;
    private int losses = 0;
    private int ties = 0;

    /**
     * @return the players
     */
    public List<Player> getPlayers() {
        return players;
    }

    /**
     * @param players the players to set
     */
    public void setPlayers(List<Player> players) {
        this.players = players;
    }

    /**
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return the city
     */
    public String getCity() {
        return city;
    }

    /**
     * @param city the city to set
     */
    public void setCity(String city) {
        this.city = city;
    }

    public String getFullName(){
        return this.name + "  – "  + this.city;  
    }

} 
```

现在已经定义了团队类，需要创建一个构建器。构建器对象的目的是允许逐步创建团队对象。为了抽象构建对象的细节，应该创建一个构建器类接口。该接口应该定义将用于构建对象的任何方法，以及将返回完全构建的对象的方法。在这种情况下，该接口将定义构建新团队对象所需的每个方法，然后构建器实现将实现该接口。

```
public interface TeamBuilder {
    public void buildPlayerList();
    public void buildNewTeam(String teamName);
    public void designateTeamCity(String city);
    public Team getTeam();

} 
```

下面的代码演示了生成器类的实现。虽然下面的代码不会创建一个定制的播放器列表，但是它包含了实现构建器模式所需的所有特性。创建一个更加定制的球员名单的细节可以在以后解决，可能是通过允许用户通过键盘输入来创建球员。此外，TeamBuilder 接口可以用于实现不同运动的团队。下面的类命名为 HockeyTeamBuilder，但是实现 TeamBuilder 的类似类可以命名为 FootballTeamBuilder，依此类推。

```
public class HockeyTeamBuilder implements TeamBuilder {

    private Team team;

    public HockeyTeamBuilder(){
        this.team = new Team();
    }

    @Override
    public void buildPlayerList() {
        List players = new ArrayList();
        for(int x = 0; x <= 10; x++){
            players.add(PlayerFactory.getPlayer());
        }
        team.setPlayers(players);
    }

    @Override
    public void buildNewTeam(String teamName) {
        team.setName(teamName);
    }

    @Override
    public void designateTeamCity(String city){
        team.setCity(city);
    }

    public Team getTeam(){
        return this.team;
    }

}
```

最后，通过调用在其接口中定义的方法来使用构建器创建团队。下面的代码演示了如何使用这个生成器来创建一个团队。您可以在这个菜谱的源代码中使用花名册类来测试这个代码:

```
public Team createTeam(String teamName, String city){
    TeamBuilder builder = new HockeyTeamBuilder();
    builder.buildNewTeam(teamName);
    builder.designateTeamCity(city);
    builder.buildPlayerList();
    return builder.getTeam();
}
```

尽管构建器模式的演示相对较短，但它演示了如何隐藏对象的实现细节，从而使对象更容易构建。您不需要知道构建器中的方法实际上做什么；你只需要呼唤他们。

### 它是如何工作的

构建器模式提供了一种以过程方式生成对象的新实例的方法。它抽象了对象创建的细节，因此创建者不需要做任何特定的工作来生成新的实例。通过将工作分解成一系列步骤，构建器模式允许对象以不同的方式实现其构建器方法。因为对象创建者只能访问构建器方法，所以创建不同的对象类型要容易得多。

有几个类和接口是使用构建器模式所必需的。首先，您需要定义一个类及其不同的属性。正如这个配方的解决方案所展示的，这个类可能遵循 JavaBean 模式(更多细节见配方 5-5)。通过创建 JavaBean，您将能够使用它的 setters 和 getters 来填充对象。接下来，您应该创建一个接口，用于访问您创建的对象的 setters。每个 setter 方法都应该在接口中定义，然后对象本身应该实现该接口。正如在解决方案中所看到的，Team 对象包含以下 setterss，并且每个 setter 都是在 TeamType 接口中定义的:

```
public void setPlayers(List<Player> players);
public void setName(String name);
public void setCity(String city);
```

现实生活中，一个团队大概会包含更多的属性。例如，您可能想要设置一个吉祥物和一个主体育场的名称和地址。这个例子中的代码可以被认为是缩写的，因为它演示了一个通用的“团队对象”的创建，而不是向您展示创建一个真实团队的所有代码。因为 Team 类实现了这些在 TeamType 接口中定义的 setters，所以可以调用接口方法来与 Team 类的实际方法进行交互。

在对对象及其接口进行编码之后，需要创建实际的构建器。生成器由一个接口及其实现类组成。首先，您必须定义在构建对象时希望其他类调用的方法。例如，在这个配方的解决方案中，在名为 TeamBuilder 的构建器接口中定义了 buildNewTeam()、designateTeamCity()和 buildPlayerList()方法。当一个类以后想要构建这些对象之一时，它只需要调用这些定义的方法就可以了。接下来，定义一个构建器类实现。实现类将实现在构建器接口中定义的方法，对对象创建者隐藏这些实现的所有细节。在这个配方的解决方案中，构建器类 HockeyTeamBuilder 实现了 TeamBuilder 接口。当一个类想要创建一个新的团队对象时，它只是实例化一个新的构建器类。

```
TeamBuilder builder = new HockeyTeamBuilder();
```

为了填充新创建的类对象，在其上调用构建器方法。

```
builder.buildNewTeam(teamName);
builder.designateTeamCity(city);
builder.buildPlayerList();
```

使用这种技术为对象提供了一步一步的创建。构建该对象的实现细节对对象创建者是隐藏的。对于不同的构建器实现来说，使用相同的 TeamBuilder 接口来构建不同类型的团队对象是非常容易的。例如，可以编写一个构建器实现来为足球生成团队对象，而另一个实现可以被定义来为棒球生成团队对象。每个团队对象的实现都是不同的。然而，它们都可以实现相同的接口——team builder——并且创建者可以简单地调用构建器方法而不用关心细节。

## 5-9.通过接口与类交互

### 问题

您已经创建了一个实现接口或类类型的类。您希望通过调用接口中声明的方法来与该类的方法进行交互，而不是直接使用该类。

### 解决办法

将同一类型的字段声明为接口。然后，可以将实现接口的类分配给已声明的字段，并调用接口中声明的方法来执行工作。在下面的示例中，一个字段被声明为 TeamType 类型。使用配方 5-8 中的相同类，你可以看到类 Team 实现了 TeamType 接口。以下示例中创建的字段包含对新团队对象的引用。

因为 Team 类实现了 TeamType 接口，所以可以使用该接口中公开的方法:

```
TeamType team = new Team();
team.setName("Juneau Royals");
team.setCity("Chicago");
System.out.println(team.getFullName());
```

结果输出:

```
Juneau Royals – Chicago
```

### 它是如何工作的

接口的用处有很多。接口的两个最重要的用例是一致性和抽象。接口定义了一个模型，任何实现接口的类都必须符合这个模型。因此，如果在接口中定义了一个常量，它将自动在类中使用。如果在接口中定义了一个方法，那么这个类必须实现这个方法，除非已经定义了一个默认的实现(见方法 5-7)。接口提供了一种很好的方式让类符合标准。

接口对任何不需要看到的类隐藏不必要的信息。接口中定义的任何方法都是公共的，任何类都可以访问。正如这个配方的解决方案中所演示的，创建了一个对象，并将其声明为接口的类型。示例中的接口 TeamType 只包含团队对象中可用的一小部分方法。因此，对于任何处理已声明为 TeamType 的对象的类来说，唯一可访问的方法是那些在接口中定义的方法。使用此接口类型的类不能访问任何其他方法或常数，也不需要访问。接口是隐藏不需要被其他类使用的逻辑的好方法。另一个很大的副作用是:实现接口的类可以被改变和重新编译，而不会影响使用该接口的代码。然而，如果一个接口被改变，可能会对实现它的任何类产生影响。因此，如果 getFullName()方法实现发生变化，任何针对 TeamType 接口编码的类都不会受到影响，因为接口没有变化。实现将在幕后改变，任何处理接口的类都将开始使用新的实现，而不需要知道。

###### 注意

在某些情况下，现有类的变更会导致代码中断。在使用库时，这种情况更为常见。例如，假设一个类实现了一个用新方法签名更新的接口。实现该接口的所有类现在都必须更新，以包括新方法的实现，为了保持向后兼容性，这在库类中有时是不可能的。这是 Java 8 中包含默认方法的主要原因；更多详情见配方 5-7。

最后，接口有助于提高安全性。它们隐藏了在接口中声明的方法的实现细节，以免任何类使用该接口调用该方法。如前一段所述，如果一个类对 TeamType 接口调用 getFullName()方法，只要结果按预期返回，它就不需要知道该方法的实现细节。

旧的 Enterprise JavaBean (EJB)模型使用接口与执行数据库工作的方法进行交互。这个模型很好地隐藏了其他类不需要的细节和逻辑。其他框架使用类似的模型，通过 Java 接口公开功能。接口的使用已经被证明是一种聪明的软件编码方式，因为它提高了可重用性、灵活性和安全性。

## 5-10.使类可克隆

### 问题

您希望一个类能够被另一个类克隆或复制。

### 解决办法

在要克隆的类中实现可克隆接口；然后调用该对象克隆方法来复制它。下面的代码演示了如何使 Team 类可克隆:

```
public class Team implements TeamType, Cloneable, Serializable {

    private String name;
    private String city;

    /**
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return the city
     */
    public String getCity() {
        return city;
    }

    /**
     * @param city the city to set
     */
    public void setCity(String city) {
        this.city = city;
    }

    public String getFullName() {
        return this.name + " - " + this.city;
    }

    /**
     * Overrides Object's clone method to create a deep copy
     *
     * @return
     */
    @Override
    public Team clone() {

        Team obj = null;
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(this);
            oos.close();

            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            obj = (Team) ois.readObject();
            ois.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException cnfe) {
            cnfe.printStackTrace();
        }
        return obj;
    }

    /**
     * Overrides Object's clone method to create a shallow copy
     *
     * @return
     */
    public Team shallowCopyClone() {

        try {
            return (Team) super.clone();
        } catch (CloneNotSupportedException ex) {
            return null;
        }
    }

    @Override
    public boolean equals(Object obj) {

        if (this == obj) {
            return true;
        }
        if (obj instanceof Team) {
            Team other = (Team) obj;
            return other.getName().equals(this.getName())
                    && other.getCity().equals(this.getCity());
        } else {
            return false;
        }

    }
} 
```

要制作团队对象的深层副本，需要针对该对象调用 clone()方法。要制作对象的浅层副本，必须调用 shallowCopyClone()方法。以下代码演示了这些技术:

```
Team team1 = new Team();
Team team2 = new Team();

team1.setCity("Boston");
team1.setName("Bandits");

team2.setCity("Chicago");
team2.setName("Wildcats");

Team team3 = team1;
Team team4 = team2.clone();

Team team5 = team1.shallowCopyClone();

System.out.println("Team 3:");
System.out.println(team3.getCity());
System.out.println(team3.getName());

System.out.println("Team 4:");
System.out.println(team4.getCity());
System.out.println(team4.getName());

// Teams move to different cities
team1.setCity("St. Louis");
team2.setCity("Orlando");

System.out.println("Team 3:");
System.out.println(team3.getCity());
System.out.println(team3.getName());

System.out.println("Team 4:");
System.out.println(team4.getCity());
System.out.println(team4.getName());

System.out.println("Team 5:");
System.out.println(team5.getCity());
System.out.println(team5.getName());

if (team1 == team3){
    System.out.println("team1 and team3 are equal");
} else {
    System.out.println("team1 and team3 are NOT equal");
}

if (team1 == team5){
    System.out.println("team1 and team5 are equal");
} else {
    System.out.println("team1 and team5 are NOT equal");
}
```

这段代码演示了如何克隆一个对象。结果输出如下。

```
Team 3:
Boston
Bandits
Team 4:
Chicago
Wildcats
Team 3:
St. Louis
Bandits
Team 4:
Chicago
Wildcats
Team 5:
Boston
Bandits
team1 and team3 are equal
team1 and team5 are NOT equal 
```

### 它是如何工作的

有两种不同的策略可用于复制对象:浅层副本和深层副本。可以制作一个*浅拷贝*,它将拷贝该对象，而不拷贝它的任何内容或数据。相反，所有变量都通过引用传递到复制的对象中。创建对象的浅层副本后，原始对象及其副本中的对象引用相同的数据和内存。因此，修改原始对象的内容也会修改复制的对象。默认情况下，对对象调用 super.clone()方法会执行浅层复制。这个菜谱的解决方案中的 shallowCopyClone()方法演示了这种技术。

可以进行的第二种复制称为*深度复制*，它复制包含所有内容的对象。因此，每个对象都引用内存中不同的空间，修改一个对象不会影响另一个。在这个配方的解决方案中，展示了深层拷贝和浅层拷贝之间的区别。首先，创建团队 1 和团队 2。接下来，用一些值填充它们。然后，team3 对象被设置为与 team1 对象相等，而 team4 对象是 team2 对象的克隆。当 team1 对象中的值发生变化时，它们在 team3 对象中也会发生变化，因为这两个对象的内容指向内存中的同一个空间。这是一个对象浅层拷贝的例子。当 team2 对象中的值发生变化时，它们在 team4 对象中保持不变，因为每个对象都有自己的变量，这些变量引用内存中的不同空间。这是深层拷贝的一个例子。

为了制作对象的精确副本(深层副本)，您必须序列化对象，以便可以将其写入磁盘。基本对象类实现了 clone()方法。默认情况下，对象类的 clone()方法是受保护的。为了使一个对象可克隆，它必须实现可克隆接口并覆盖默认的 clone()方法。您可以通过一系列步骤序列化对象来制作对象的深层副本，例如将对象写入输出流，然后通过输入流读回它。这个菜谱的解决方案的 clone()方法中显示的步骤就是这样做的。该对象被写入 ByteArrayOutputStream，然后使用 ByteArrayInputStream 读取。一旦发生这种情况，对象就被序列化，这就创建了深层副本。此配方的解决方案中的 clone()方法已被覆盖，因此它创建了一个深层副本。

一旦遵循了这些步骤，并且对象实现了 Cloneable 并覆盖了默认的 object clone()方法，就可以克隆对象了。为了制作对象的深层副本，只需调用该对象的被覆盖的 clone()方法，如解决方案中所示。如果只是从 clone()方法返回 Object，那么就需要进行类型转换，如下所示:

```
Team team4 = (Team) team2.clone();
```

克隆对象并不十分困难，但是很好地理解对象副本之间的差异是很重要的。

## 5-11.比较对象

### 问题

您的应用程序需要能够比较两个或多个对象，以查看它们是否相同。

### 解决方案 1

若要确定两个对象引用是否指向同一个对象，请使用==和！=运算符。下面的解决方案演示了两个对象引用的比较，以确定它们是否引用同一个对象。

```
// Compare if two objects contain the same values
Team team1 = new Team();
Team team2 = new Team();

team1.setName("Jokers");
team1.setCity("Crazyville");

team2.setName("Jokers");
team2.setCity("Crazyville");

if (team1 == team2){
    System.out.println("These object references refer to the same object.");
} else {
    System.out.println("These object references do NOT refer to the same object.");
}

// Compare two objects to see if they refer to the same object
Team team3 = team1;
Team team4 = team1;

if (team3 == team4){
    System.out.println("These object references refer to the same object.");
} else {
    System.out.println("These object references do NOT refer to the same object.");
}
```

运行代码的结果:

```
These object references do NOT refer to the same object.
These object references refer to the same object. 
```

### 解决方案 2

若要确定两个对象是否包含相同的值，请使用 equals()方法。被比较的对象必须实现 equals()和 hashCode()，这样这个解决方案才能正常工作。下面是覆盖这两个方法的 Team 类的代码:

```
public class Team implements TeamType, Cloneable {

    private List<Player> players;
    private String name;
    private String city;
    // Used by the hashCode method for performance reasons
    private volatile int cachedHashCode = 0;

    /**
     * @return the players
     */
    public List<Player> getPlayers() {
        return players;
    }

    /**
     * @param players the players to set
     */
    public void setPlayers(List<Player> players) {
        this.players = players;
    }

    /**
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return the city
     */
    public String getCity() {
        return city;
    }

    /**
     * @param city the city to set
     */
    public void setCity(String city) {
        this.city = city;
    }

    public String getFullName() {
        return this.name + " - " + this.city;
} 

    /**
     * Overrides Object's clone method
     *
     * @return
     */
    public Object clone() {

        try {
            return super.clone();
        } catch (CloneNotSupportedException ex) {
            return null;
        }
    }

    @Override
    public boolean equals(Object obj) {

        if (this == obj) {
            return true;
        }
        if (obj instanceof Team) {
            Team other = (Team) obj;
            return other.getName().equals(this.getName())
&& other.getCity().equals(this.getCity())
&& other.getPlayers().equals(this.getPlayers());
        } else {
            return false;
        }

} 

@Override
    public int hashCode() {
        int hashCode = cachedHashCode;
        if (hashCode == 0) {
            String concatStrings = name + city;
            if (players.size() > 0) {
                for (Player player : players) {
                    concatStrings = concatStrings
                            + player.getFirstName()
                            + player.getLastName()
                            + player.getPosition()
                            + String.valueOf(player.getStatus());

                }
            }
            hashCode = concatStrings.hashCode();
        }
        return hashCode;
    }
} 
```

下面的解决方案演示了包含相同值的两个对象的比较。

```
// Compare if two objects contain the same values
Team team1 = new Team();
Team team2 = new Team();

// Build Player List
Player newPlayer = new Player("Josh", "Juneau");
playerList.add(0, newPlayer);
newPlayer = new Player("Jonathan", "Gennick");
playerList.add(1, newPlayer);
newPlayer = new Player("Joe", "Blow");
playerList.add(1, newPlayer);
newPlayer = new Player("John", "Smith");
playerList.add(1, newPlayer);
 newPlayer = new Player("Paul", "Bunyan");
playerList.add(1, newPlayer);

team1.setName("Jokers");
team1.setCity("Crazyville");
team1.setPlayers(playerList);

team2.setName("Jokers");
team2.setCity("Crazyville");
team2.setPlayers(playerList);

if (team1.equals(team2)){
    System.out.println("These object references contain the same values.");
} else {
    System.out.println("These object references do NOT contain the same values.");
}
```

运行这段代码的结果是:

```
These object references do NOT refer to the same object.
These object references contain the same values.
These object references refer to the same object.
```

### 它是如何工作的

比较运算符(==)可用于确定两个对象是否相等。这种相等不属于对象值，而是属于对象引用。通常应用程序更关心对象的值；在这种情况下，equals()方法是首选，因为它比较的是对象中包含的值，而不是对象引用。

比较运算符查看对象引用，并确定它是否指向与要比较的对象引用相同的对象。如果两个对象相等，将返回布尔值 true 结果；否则，将返回布尔假结果。在解决方案 1 中，team1 对象引用和 team2 对象引用之间的第一次比较返回 false 值，因为这两个对象在内存中是分开的，即使它们包含相同的值。在解决方案 1 中，team3 对象引用和 team4 对象引用之间的第二次比较返回 true 值，因为这两个引用都引用了 team1 对象。

equals()方法可用于测试两个对象是否包含相同的值。为了使用 equals()方法进行比较，被比较的对象应该覆盖 object 类 equals()和 hashCode()方法。equals()方法应该实现与包含在对象中的值进行比较，从而产生真实的比较结果。以下代码是一个被覆盖的 equals()方法的示例，该方法已被放入 Team 对象中:

```
@Override
public boolean equals(Object obj) {

    if (this == obj) {
        return true;
    }
    if (obj instanceof Team) {
        Team other = (Team) obj;
        return other.getName().equals(this.getName())
&& other.getCity().equals(this.getCity())
&& other.getPlayers().equals(this.getPlayers());
    } else {
        return false;
    }

}
```

正如您所看到的，被覆盖的 equals()方法首先检查作为参数传递的对象是否引用了与它进行比较的对象相同的对象。如果是，则返回真结果。如果两个对象没有引用内存中的同一个对象，equals()方法会检查这两个字段是否相等。在这种情况下，任何两个在 name 和 city 字段中包含相同值的团队对象都将被视为相等。一旦 equals()方法被覆盖，就可以执行这两个对象的比较，如该配方的解决方案 2 所示。

hashCode()方法返回一个 int 值，该值必须始终返回同一个整数。有很多方法可以计算对象的 hashCode。在网上搜索一下这个话题，你会发现各种各样的技巧。实现 hashCode()方法的一个最基本的方法是将所有对象的变量连接成字符串格式，然后返回结果字符串的 hashCode()。缓存 hashCode 的值供以后使用是一个好主意，因为初始计算可能需要一些时间。解决方案 2 中的 hashCode()方法演示了这种策略。

考虑到有多种方法可以比较 Java 对象，比较 Java 对象可能会变得令人困惑。如果要对对象标识执行比较，请使用比较(==)运算符。但是，如果您想要比较对象中的值，或者对象的状态，那么 equals()方法是一个不错的选择。

## 5-12.扩展类的功能

### 问题

你的一个应用程序包含了一个类，你想用它作为另一个类的基础。您希望您的新类包含该基类的相同功能，但还包含其他功能。

### 解决办法

通过使用 extends 关键字后跟要扩展的类的名称来扩展基类的功能。下面的示例显示了两个类。第一个类名为 HockeyStick，表示一个曲棍球棒对象。它将由名为 WoodenStick 的第二个类扩展。通过这样做，WoodenStick 类将继承 HockeyStick 中包含的所有属性和功能，私有变量和具有默认访问级别的变量除外。WoodenStick 类成为 HockeyStick 的子类。首先，让我们看一下 HockeyStick 类，它包含标准曲棍球棒的基本属性:

```
public class HockeyStick {

    private int length;
    private boolean curved;
    private String material;

    public HockeyStick(int length, boolean curved, String material){
        this.length = length;
        this.curved = curved;
        this.material = material;
    }

     /**
     * @return the length
     */
    public int getLength() {
        return length;
    }

    /**
     * @param length the length to set
     */
    public void setLength(int length) {
        this.length = length;
    }

    /**
     * @return the curved
     */
    public boolean isCurved() {
        return curved;
    }

    /**
     * @param curved the curved to set
     */
    public void setCurved(boolean curved) {
        this.curved = curved;
    }

    /**
     * @return the material
     */
    public String getMaterial() {
        return material;
    }

    /**
     * @param material the material to set
     */
    public void setMaterial(String material) {
        this.material = material;
    }

}
```

接下来，看看 HockeyStick 的子类:一个名为 WoodenStick 的类。

```
public class WoodenStick extends HockeyStick {

    private static final String material = "WOOD";
    private int lie;
    private int flex;

    public WoodenStick(int length, boolean isCurved){
        super(length, isCurved, material);
    }

    public WoodenStick(int length, boolean isCurved, int lie, int flex){
        super(length, isCurved, material);
        this.lie = lie;
        this.flex = flex;
    }

    /**
     * @return the lie
     */
    public int getLie() {
        return lie;
    }

    /**
     * @param lie the lie to set
     */
    public void setLie(int lie) {
        this.lie = lie;
    }

    /**
     * @return the flex
     */
    public int getFlex() {
        return flex;
    }

    /**
     * @param flex the flex to set
     */
    public void setFlex(int flex) {
        this.flex = flex;
    }
}
```

###### 注意

在这个例子中，我们假设可能有不止一种类型的 HockeyStick。在这种情况下，我们扩展 HockeyStick 来创建一个 WoodenStick，但是我们也可以扩展 HockeyStick 来创建其他类型的 HockeyStick，比如 AluminumStick 或 GraphiteStick。

### 它是如何工作的

对象继承是任何面向对象语言的基本技术。从基类继承增加了价值，因为它允许代码在多个地方重用。这有助于使代码管理更加容易。如果在基类中进行了更改，它将自动在子类中继承。另一方面，如果您的应用程序中分散着重复的功能，那么一个微小的更改就意味着您必须在许多地方更改代码。对象继承也使得为一个或多个子类指定一个基类变得容易，这样每个类可以包含相似的字段和功能。

Java 语言只允许一个类扩展另一个类。这在概念上不同于包含多重继承的其他语言，如 C++。虽然有些人认为单个类继承是语言的障碍，但它是为了增加语言的安全性和易用性而设计的。当一个子类包含多个超类时，混乱就会接踵而至。

## 5-13.为要扩展的类定义模板

### 问题

您希望定义一个模板，用于生成包含类似功能的对象。

### 解决办法

定义一个抽象类，其中包含可以在其他类中使用的字段和功能。抽象类还可以包含未实现的方法，称为*抽象方法*，需要由抽象类的子类实现。下面的示例演示了抽象类的概念。示例中的抽象类表示一个团队日程，它包括一些基本的字段声明和每个团队的日程都需要使用的功能。然后由 TeamSchedule 类扩展 Schedule 类，它将用于为每个团队实现特定的功能。首先，让我们看看抽象的 Schedule 类:

```
public abstract class Schedule {

    public String scheduleYear;
    public String teamName;

    public List<Team> teams;

    public Map<Team, LocalDate> gameMap;

    public Schedule(){}

    public Schedule(String teamName){
        this.teamName = teamName;
    }

    abstract void calculateDaysPlayed(int month);

}
```

接下来，TeamSchedule 扩展了抽象类的功能。

```
public class TeamSchedule extends Schedule {

    public TeamSchedule(String teamName) {
        super(teamName);
    }

    @Override
    void calculateDaysPlayed(int month) {
        int totalGamesPlayedInMonth = 0;
        for (Map.Entry<Team, LocalDate> entry : gameMap.entrySet()) {
            if (entry.getKey().equals(teamName)
                    && entry.getValue().getMonth().equals(month)) {
                totalGamesPlayedInMonth++;
            }
        }
        System.out.println("Games played in specified month: " + totalGamesPlayedInMonth);
    }

}
```

如您所见，TeamSchedule 类可以使用抽象 Schedule 类中包含的所有字段和方法。它还实现了包含在 Schedule 类中的抽象方法。

### 它是如何工作的

抽象类就是这样标记的，它们包含可以在子类中使用的字段声明和方法。它们与常规类的不同之处在于它们可以包含抽象方法，抽象方法是没有实现的方法声明。这个配方的解决方案包含一个名为 calculateDaysPlayed()的抽象方法。抽象类可能包含也可能不包含抽象方法。它们可以包含字段和完全实现的方法。抽象类不能被实例化；其他类只能扩展它们。当一个类扩展一个抽象类时，它获得该抽象类的所有字段和功能。然而，在抽象类中声明的任何抽象方法都必须由子类实现。

您可能想知道为什么抽象类不仅仅包含方法的实现，这样它的所有子类都可以使用它。如果你思考一下这个概念，它就非常有意义。一种类型的对象执行的任务可能与另一种不同。使用抽象方法会强制扩展抽象类的类实现它，但它允许自定义实现方式的能力。

## 5-14.增加类封装

### 问题

您的一个类需要使用另一个类的功能。但是，没有其他类需要使用相同的功能。您希望生成一个只能由需要它的类使用的实现，同时将代码放在一个逻辑位置，而不是创建一个包含这一附加功能的单独的类。

### 解决办法

在需要其功能的类中创建一个内部类。

```
import java.util.ArrayList;
import java.util.List;

/**
 * Inner class example. This example demonstrates how a team object could be
 * built using an inner class object.
 *
 * @author juneau
 */
public class TeamInner {

    private Player player;
    private List<Player> playerList;
    private int size = 4;

    /**
     * Inner class representing a Player object
     */
    class Player {

        private String firstName = null;
        private String lastName = null;
        private String position = null;
        private int status = -1;

        public Player() {
        }

        public Player(String position, int status) {
            this.position = position;
            this.status = status;
        }

        protected String playerStatus() {
            String returnValue = null;

            switch (getStatus()) {
                case 0:
                    returnValue = "ACTIVE";
                    break;
                case 1:
                    returnValue = "INACTIVE";
                    break;
                case 2:
                    returnValue = "INJURY";
                    break;
                default:
                    returnValue = "ON_BENCH";
                    break;
} 

            return returnValue;
        }

        public String playerString() {
            return getFirstName() + " " + getLastName() + " - " + getPosition();
        }

        /**
         * @return the firstName
         */
        public String getFirstName() {
            return firstName;
        }

        /**
         * @param firstName the firstName to set
         */
        public void setFirstName(String firstName) {
            this.firstName = firstName;
        }

        /**
         * @return the lastName
         */
        public String getLastName() {
            return lastName;
} 

        /**
         * @param lastName the lastName to set
         */
        public void setLastName(String lastName) {
            this.lastName = lastName;
        }

        /**
         * @return the position
         */
        public String getPosition() {
            return position;
        }

        /**
         * @param position the position to set
         */
        public void setPosition(String position) {
            this.position = position;
        }

        /**
         * @return the status
         */
        public int getStatus() {
            return status;
        }

        /**
         * @param status the status to set
         */
        public void setStatus(int status) {
            this.status = status;
        }

        @Override
        public String toString(){
            return this.firstName + " " + this.lastName + " - "+
                   this.position + ": " + this.playerStatus();
        }
    }

    /**
     * Inner class that constructs the Player objects and adds them to an array
     * that was declared in the outer class;
     */
    public TeamInner() {

        final int ACTIVE = 0;

        // In reality, this would probably read records from a database using
        // a loop...but for this example we will manually enter the player data.
        playerList = new ArrayList();
        playerList.add(constructPlayer("Josh", "Juneau", "Right Wing", ACTIVE));
        playerList.add(constructPlayer("Joe", "Blow", "Left Wing", ACTIVE));
        playerList.add(constructPlayer("John", "Smith", "Center", ACTIVE));
        playerList.add(constructPlayer("Bob","Coder", "Defense", ACTIVE));
        playerList.add(constructPlayer("Jonathan", "Gennick", "Goalie", ACTIVE));
    }

    public Player constructPlayer(String first, String last, String position, int status){
            Player player = new Player();
            player.firstName = first;
            player.lastName = last;
            player.position = position;
            player.status = status;
            return player;
    }

    public List<Player> getPlayerList() {
        return this.playerList;
    }

    public static void main(String[] args) {
TeamInner inner = new TeamInner();
        System.out.println("Team Roster");
        System.out.println("===========");
for(Player player:inner.getPlayerList()){
            System.out.println(player.playerString());
        }
    }
} 
```

运行这段代码的结果是一个团队成员的列表。

```
Team Roster
===========
Josh Juneau - Right Wing
Joe Blow - Left Wing
John Smith - Center
Bob Coder - Defense
Jonathan Gennick - Goalie
```

### 它是如何工作的

有时将功能封装在单个类中很重要。其他时候，为只在另一个类中使用的功能包含一个单独的类是没有意义的。假设您正在开发一个 GUI，您需要使用一个类来支持一个按钮的功能。如果按钮类中没有可重用的代码，那么创建一个单独的类并公开该功能供其他类使用是没有意义的。相反，将该类封装在需要该功能的类中是有意义的。这一理念是内部类(也称为*嵌套类*)的一个用例。

内部类是包含在另一个类中的类。内部类可以像任何其他类一样被公开、私有或保护。它可以包含与普通类相同的功能；唯一的区别是内部类包含在封闭类中，也称为*外部类*。这个配方的解决方案演示了这种技术。TeamInner 类包含一个名为 Player 的内部类。Player 类是一个表示 Player 对象的 JavaBean 类。如您所见，Player 对象能够从其包含的类继承功能，包括其私有字段。这是因为内部类包含对外部类的隐式引用。它也可以由包含它的 TeamInner 类访问，如 constructPlayer()方法中所示:

```
public Player constructPlayer(String first, String last, String position, int status){
            Player player = new Player();
            player.firstName = first;
            player.lastName = last;
            player.position = position;
            player.status = status;
            return player;
    }
```

外部类可以根据需要多次实例化内部类。在这个例子中，constructPlayer()方法可以被调用任意次，实例化内部类的一个新实例。但是，当实例化外部类时，不会实例化内部类的任何实例。类似地，当外部类不再使用时，所有内部类实例也被销毁。

内部类可以通过引用外部类和它想要调用的方法来引用外部类方法。下面一行代码演示了这样一个引用，它使用了这个配方的解决方案中表示的相同对象。假设玩家类需要从外部类获得玩家列表；您应该编写类似下面的内容:

```
TeamInner.this.getPlayerList();
```

虽然不经常使用，但外部类以外的类可以通过使用以下语法获得对公共内部类的访问:

```
TeamInner outerClass = new TeamInner();
outerClass.player = outerClass.new Player();
```

静态内部类有点不同，因为它们不能直接引用其封闭类的任何实例变量或方法。下面是一个静态内部类的例子。

```
public class StaticInnerExample {

    static String hello = "Hello";

    public static void sayHello(){
        System.out.println(hello);
    }

    static class InnerExample {
        String goodBye = "Good Bye";

        public void sayGoodBye(){
            System.out.println(this.goodBye);
        }
    }

    public static void main (String[] args){
        StaticInnerExample.sayHello();
        StaticInnerExample.InnerExample inner =
                new StaticInnerExample.InnerExample();
        inner.sayGoodBye();
    }
}
```

内部类有助于提供逻辑封装。此外，它们允许私有字段的继承，这在使用标准类时是不可能的。

## 摘要

Java 是一种面向对象的语言。为了利用这种语言的能力，人们必须学会如何精通面向对象。本章讲述了诸如类创建和访问修饰符之类的基础知识。它还涵盖了封装、接口和配方，以帮助开发人员利用面向对象的强大功能。