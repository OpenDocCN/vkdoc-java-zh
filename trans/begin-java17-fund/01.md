# 1.编程概念

在本章中，您将学习:

*   编程的一般概念

*   编程的不同组成部分

*   主要编程范例

*   什么是面向对象(OO)范式，它是如何在 Java 中使用的

## 什么是编程？

术语“编程”在许多上下文中使用。我们讨论它在人机交互环境中的意义。简而言之，编程就是编写一系列指令来告诉计算机执行特定任务的方式。计算机的指令序列被称为*程序*。一组定义明确的符号用于编写程序。用来编写程序的一套符号被称为*编程语言*。写程序的人被称为*程序员*。程序员使用编程语言编写程序。

一个人如何告诉计算机执行一项任务？人能告诉计算机执行任何任务吗，或者计算机有一套预定义的它能执行的任务吗？在我们看人机交流之前，我们先来看看人与人之间的交流。一个人如何与另一个人交流？你会说人与人之间的交流是通过口语来完成的，例如，英语、德语、印地语等。然而，口语并不是人类之间唯一的交流方式。我们也用书面语言或手势交流，而不用说任何话。有些人甚至可以坐在几英里以外的地方交流，而不用任何语言或手势；他们可以在思想层面交流。

要进行成功的交流，仅仅使用像口语或书面语这样的交流媒介是不够的。双方之间成功沟通的主要要求是双方能够理解对方传达的内容。例如，假设有两个人。一个人知道如何说英语，另一个人知道如何说德语。他们能互相交流吗？答案是否定的，因为他们听不懂对方的语言。如果我们在它们之间加一个英德翻译器会怎么样？我们同意，他们将能够在翻译的帮助下交流，即使他们不能直接相互理解。

计算机只能理解二进制格式的指令，二进制格式是 0 和 1 的序列。所有计算机都理解的 0 和 1 的序列被称为机器语言或机器代码。计算机有一套它能理解的固定的基本指令。每台计算机都有自己的一套指令。例如，一台计算机可能使用 0010 作为将两个数字相加的指令，而另一台计算机可能出于相同的目的使用 0101。因此，用机器语言编写的程序是机器相关的。有时机器代码被称为本机代码，因为它是为其编写的机器的本机代码。用机器语言编写的程序很难写、读、理解和修改。假设你想写一个程序，把 15 和 12 这两个数字相加。用机器语言将两个数字相加的程序看起来类似于这里显示的程序。您不需要理解本节中编写的示例代码。这仅仅是为了讨论和说明的目的:

```
0010010010  10010100000100110
0001000100  01010010001001010

```

这些指令是把两个数相加。用机器语言写一个程序来执行一个复杂的任务会有多难？基于这段代码，你现在可能意识到用机器语言编写、阅读和理解一个程序是非常困难的。但是计算机不是应该使我们的工作更容易，而不是更困难吗？我们需要用一些更容易书写、阅读和理解的符号来表示计算机的指令，所以计算机科学家们想出了另一种语言，叫做汇编语言。汇编语言提供了不同的符号来编写指令。它比它的前身机器语言更容易写、读和理解。汇编语言使用助记符来表示指令，与机器语言中使用的二进制(0 和 1)相反。用汇编语言编写的将两个数相加的程序如下所示:

```
li $t1, 15
add $t0, $t1, 12

```

如果比较用两种不同语言编写的执行相同任务的两个程序，你会发现汇编语言比机器代码更容易编写、阅读和理解。对于给定的计算机体系结构，机器语言的指令和汇编语言的指令之间是一一对应的。回想一下，计算机只能理解机器语言的指令。用汇编语言编写的指令必须先翻译成机器语言，计算机才能执行。把汇编语言编写的指令翻译成机器语言的程序叫做*汇编程序*。图 [1-1](#Fig1) 显示了汇编代码、汇编程序和机器码之间的关系。

![../images/323069_3_En_1_Chapter/323069_3_En_1_Fig1_HTML.png](../images/323069_3_En_1_Chapter/323069_3_En_1_Fig1_HTML.png)

图 1-1

汇编代码、汇编程序和机器代码之间的关系

机器语言和汇编语言也被称为低级语言，因为程序员必须理解计算机的低级细节才能用这些语言编写程序。例如，如果你在用这些语言编写程序，你需要知道你在哪个内存位置写或者读，哪个寄存器用来存储一个特定的值，等等。很快，程序员们意识到需要一种更高级的编程语言，可以对他们隐藏计算机的底层细节。这种需求导致了诸如 COBOL、Pascal、FORTRAN、C、C++、Java、C#等高级编程语言的发展。高级编程语言使用类似英语的单词、数学符号和标点符号来编写程序。用高级编程语言编写的程序也叫*源代码* *。*它们更接近人类熟悉的书面语言。用高级编程语言(例如 Java)编写的将两个数字相加的指令类似于以下内容:

```
int x = 15 + 12;

```

你可能会注意到，用高级语言编写的程序比用机器和汇编语言编写的程序更容易、更直观地编写、阅读、理解和修改。你可能已经意识到计算机不能理解用高级语言编写的程序，因为它们只能理解 0 和 1 的序列。因此，需要一种方法将高级语言编写的程序翻译成机器语言。翻译由编译器、解释器或两者的组合来完成。编译器是把用高级编程语言编写的程序翻译成机器语言的程序。编译程序是一个超载的短语。通常，这意味着将高级语言编写的程序翻译成机器语言。有时它被用来指把用高级编程语言编写的程序翻译成低级编程语言，而低级编程语言不一定是机器语言。由编译器生成的代码称为*编译代码* *。*编译后的程序由计算机执行。

执行用高级编程语言编写的程序的另一种方法是使用解释器。解释器不会立刻把整个程序翻译成机器语言。相反，它一次读取一条用高级编程语言编写的指令，将其翻译成机器语言，并执行它。你可以把一个解释器看作一个模拟器。有时，编译器和解释器的组合可以用来编译和运行用高级语言编写的程序。例如，用 Java 编写的程序被编译成一种叫做字节码的中间语言。一个解释器，具体称为 Java 平台的 Java 虚拟机(JVM ),用于解释字节码并执行它。解释程序比编译程序运行得慢。今天，大多数 JVM 使用实时(JIT)编译器，根据需要将整个 Java 程序编译成机器语言。有时，另一种称为超前(AOT)编译器的编译器被用来将中间语言(例如 Java 字节码)的程序编译成机器语言。图 [1-2](#Fig2) 显示了源代码、编译器和机器码之间的关系。

![../images/323069_3_En_1_Chapter/323069_3_En_1_Fig2_HTML.png](../images/323069_3_En_1_Chapter/323069_3_En_1_Fig2_HTML.png)

图 1-2

源代码、编译器和机器码之间的关系

编程语言也分为第一代、第二代、第三代和第四代语言。这种语言的版本越高，用这种语言编写程序就越接近普通的人类语言。机器语言也被称为第一代编程语言或 1GL。汇编语言也被称为第二代编程语言或 2GL。高级过程编程语言，如 C、C++、Java 和 C#，其中您必须使用语言语法编写算法来解决问题，也称为第三代编程语言或 3GLs。高级非过程化编程语言被称为第四代编程语言或 4gl，在这种语言中，您不需要编写算法来解决问题。结构化查询语言(SQL)是使用最广泛的 4GL，用于与数据库通信。

## 编程语言的组成部分

编程语言是用来为计算机编写指令的符号系统。它可以用三个部分来描述:

*   句法

*   语义学

*   语用学

语法部分处理使用可用的符号形成有效的编程结构。语义部分处理编程结构的含义。语用学部分处理编程语言在实践中的使用。

像书面语言(例如，英语)一样，编程语言具有词汇和语法。编程语言的词汇表由一组单词、符号和标点符号组成。编程语言的语法定义了如何使用该语言的词汇来形成有效的编程结构的规则。您可以将编程语言中的有效编程构造想象成书面语言中的句子，它是使用该语言的词汇和语法形成的。类似地，使用编程语言的词汇和语法来形成编程构造。词汇表和使用该词汇表形成有效编程结构的规则被称为编程语言的*语法*。

在书面语言中，你可能会形成一个语法正确的句子，但这个句子可能没有任何有效的含义。例如，“石头在笑”是一个语法正确的句子。然而，这没有任何意义。在书面语言中，这种歧义是允许的。编程语言意味着向计算机传达指令，没有任何含糊不清的余地。我们不能用模糊的指令与计算机交流。编程语言还有另一个组成部分，叫做*语义*，它解释了语法上有效的编程结构的含义。编程语言的语义回答了这样一个问题，“这个程序在计算机上运行时做什么？”请注意，语法上有效的编程结构可能在语义上也无效。一个程序在被计算机执行之前必须在语法和语义上是正确的。

编程语言的语用学描述了它的用途和它对用户的影响。用编程语言编写的程序可能在语法和语义上是正确的。但是，它可能不容易被其他程序员理解。这一方面与编程语言的语用学有关。语用学关注的是编程语言的实用方面。它回答了关于编程语言的一些问题，如实现的容易程度、对特定应用的适用性、效率、可移植性、对编程方法的支持等。

## 编程范例

在线的《韦氏词典学习词典》对“范式”一词的定义如下:

> *范式是关于应该如何做、做或思考某事的一种理论或一组想法。*

一开始，在编程环境中理解“范式”这个词有点困难。编程就是使用编程语言支持的计算模型为现实世界的问题提供解决方案。这个解决方案叫做程序。在我们以程序的形式提供问题的解决方案之前，我们总是对问题及其解决方案有一个心理上的看法。在我讨论如何使用计算模型解决现实世界的问题之前，让我们举一个现实世界的社会问题的例子，一个与计算机无关的问题。

假设地球上有一个地方食物短缺。那个地方的人们没有足够的食物吃。问题是“食物短缺”让我们请三个人提供解决这个问题的方法。这三个人分别是政治家、慈善家和僧侣。政治家会对问题及其解决方案有政治观点。他们可能认为这是一个为他们的同胞服务的机会，通过制定一些法律为饥饿的人提供食物。一个慈善家会提供一些钱/食物来帮助那些饥饿的人，因为他们同情所有的人类，因此也同情那些饥饿的人。一个僧侣会试图用他们的精神观点来解决这个问题。他们可能会对他们说教，让他们自己去工作，去谋生；他们可能会呼吁富人向饥饿的人捐赠食物；或者他们可能会教他们瑜伽来征服他们的饥饿！你看到三个人对同一个现实，也就是“食物短缺”有不同的看法了吗？他们看待现实的方式就是他们的范式。你可以把范式想象成一种在特定背景下看待现实的思维模式。通常有多种范例，让一个人以不同的观点看待同一现实。例如，一个既是慈善家又是政治家的人将有能力以不同的方式看待“食物短缺”问题及其解决方案，一个人有他们的政治思维，一个人有他们的慈善家思维。三个人遇到了同样的问题。他们都提供了解决问题的方法。然而，他们对问题及其解决方案的看法并不相同。我们可以将术语“范式”定义为一组概念和想法，它们构成了一种看待现实的方式。

无论如何，我们为什么需要为一个范例而烦恼呢？如果一个人使用他们的政治、慈善或精神范式来找到解决方案，这有关系吗？最终我们找到了解决问题的方法。不是吗？

仅仅有解决问题的方法是不够的。解决方案必须切实有效。因为问题的解决方案总是与思考问题和解决方案的方式相关，所以范式变得至关重要。你可以看到，和尚提供的解决方案可能会在饥饿的人们得到任何帮助之前杀死他们。慈善家的解决方案可能是一个不错的短期解决方案。这位政治家的解决方案似乎是一个长期的解决方案，也是最好的方案。使用正确的范例来解决一个问题，以得到一个实用的和最有效的解决方案，这总是很重要的。请注意，一种范式不可能是解决所有问题的正确范式。例如，如果一个人在寻求永恒的幸福，他们需要咨询僧侣，而不是政治家或慈善家。

这是著名的计算机科学家 Robert W. Floyd 对术语“编程范式”的定义。他在 1978 年 ACM 图灵奖题为“编程范例”的演讲中给出了这个定义:

> *编程范例是一种概念化的方式，它意味着执行计算，以及在计算机上执行的任务应该如何构造和组织。*

您可以观察到，在编程环境中，单词“paradigm”的含义与日常生活中使用的含义相似。编程用于使用计算机提供的计算模型来解决现实世界的问题。编程范式是您思考和概念化真实世界问题及其在底层计算模型中的解决方案的方式。在您开始使用编程语言编写程序之前，编程范式就已经出现了。这是在分析阶段，当你使用一个特定的范式，以一种特定的方式分析一个问题及其解决方案。编程语言提供了一种适当实现特定编程范例的方法。一种编程语言可以提供使其适合使用一种编程范例而不适合另一种编程范例的特性。

一个程序有两个组成部分——数据和算法。数据用来表示信息片段。算法是对数据进行操作以得出问题解决方案的一组步骤。不同的编程范例涉及通过以不同的方式组合数据和算法来查看问题的解决方案。编程中使用了许多范例。以下是一些常用的编程范例:

*   命令范式

*   程序范式

*   陈述范式

*   功能范式

*   逻辑范式

*   面向对象的范例

### 命令范式

命令式范式也称为算法范式。在命令式范例中，程序由数据和操纵数据的算法(命令序列)组成。特定时间点的数据定义了程序的状态。当命令按特定顺序执行时，程序的状态会发生变化。数据存储在内存中。命令式编程语言提供了引用内存位置的变量、改变变量值的赋值操作以及控制程序流程的其他结构。在命令式编程中，您需要指定解决问题的步骤。

假设你有一个整数，比如说`15`，你想给它加 10。你的方法是将 1 到 15 相加 10 次，你得到结果，`25`。你可以用命令式语言写一个程序，把 10 加到 15，如下。请注意，您不需要理解以下代码的语法。试着感受一下:

```
int num = 15;              // num holds 15 at this point
int counter = 0;           // counter holds 0 at this point
while (counter < 10) {
    num = num + 1;         // Modifying data in num
    counter = counter + 1; // Modifying data in counter
}
// num holds 25 at this point

```

前两行是变量声明，表示程序的数据部分。`while`循环代表程序中对数据进行操作的算法部分。循环中的代码被执行十次。在每次迭代中，循环将存储在`num`变量中的数据递增 1。当循环结束时，它将`num`的值增加了 10。请注意，命令式编程中的数据是暂时的，而算法是永久的。FORTRAN、COBOL 和 C 是支持命令式范例的编程语言的几个例子。

### 程序范式

过程范式类似于命令范式，但有一点不同:它将多个命令组合在一个称为*过程*的单元中。过程作为一个单元执行。执行包含在过程中的命令被称为调用或调用过程。过程语言中的程序由数据和一系列操作数据的过程调用组成。下面这段代码是一个名为`addTen`的程序的典型代码:

```
void addTen(int num) {
    int counter = 0;
    while (counter < 10) {
        num = num + 1;          // Modifying data in num
        counter = counter + 1;  // Modifying data in counter
    }
    // num has been incremented by 10
}

```

`addTen`过程使用一个占位符(也称为参数)`num`，它是在执行时提供的。该代码忽略了`num`的实际值。它只是在`num`的当前值上加 10。让我们用下面这段代码把 10 加到 15。请注意，`addTen`程序的代码和以下代码不是使用任何特定的编程语言编写的。这里提供它们只是为了说明的目的:

```
int x = 15; // x holds 15 at this point
addTen(x);  // Call addTen procedure that will increment x by 10
            // x holds 25 at this point

```

您可能会注意到命令式范例中的代码和过程式范例中的代码在结构上是相似的。使用过程产生模块化代码并增加算法的可重用性。有些人忽略了这种差异，将命令式和程序式这两种范式视为相同。请注意，即使它们不同，过程范式也总是包含命令范式。在过程范式中，编程的单位不是一系列命令。相反，您将一系列命令抽象成一个过程，而您的程序由一系列过程组成。手术有副作用。它在执行逻辑时修改程序的数据部分。C、C++、Java 和 COBOL 是支持过程范式的编程语言的几个例子。

### 陈述范式

在声明式范例中，程序由问题的描述组成，计算机找到解决方案。这个程序没有具体说明如何解决这个问题。当一个问题被描述给计算机时，它的工作就是得出一个解决方案。对比声明性范式和命令性范式。在命令式范式中，我们关心的是问题的“如何”部分。在声明性范例中，我们关心问题的“是什么”部分。我们关心的是问题是什么，而不是如何解决它。接下来描述的功能范式和逻辑范式是声明性范式的子类型。

使用结构化查询语言(SQL)编写数据库查询属于基于声明性范例的编程，在声明性范例中，您指定想要的数据，数据库引擎计算出如何为您检索数据。与命令式范式不同，在声明式范式中，数据是永久的，而算法是瞬时的。在命令式范例中，数据随着算法的执行而被修改。在声明性范例中，数据作为输入提供给算法，并且输入数据在算法执行时保持不变。该算法产生新数据，而不是修改输入数据。换句话说，在声明性范例中，算法的执行不会产生副作用。

### 功能范式

函数范式是基于数学函数的概念。您可以将函数想象成一种算法，它从一些给定的输入中计算出一个值。与过程式编程中的过程不同，函数没有副作用。在函数式编程中，值是不可变的。

通过对输入值应用函数来导出新值。输入值不会改变。函数式编程语言不使用用于修改数据的变量和赋值。在命令式编程中，使用循环结构执行重复的任务，例如,`while`循环。在函数式编程中，使用递归来执行重复的任务，这是一种根据函数本身来定义函数的方法。换句话说，递归函数做一些工作，然后调用自己。

当一个函数应用于相同的输入时，它总是产生相同的输出。可以应用于整数`x`以将整数`n`加到其上的函数，比如说`add`，可以定义如下:

```
int add(x, n) {
    if (n == 0) {
        return x;
    } else {
        return 1 + add(x, n-1); // Apply the add function recursively
    }
}

```

注意，`add`函数不使用任何变量，也不修改任何数据。它使用递归。您可以调用`add`函数将 10 加到 15，如下所示:

```
add(15, 10); // Results in 25

```

Haskell、Erlang 和 Scala 是支持函数范式的编程语言的几个例子。

Tip

Java SE 8 增加了一个新的语言结构，叫做 *lambda expressions* ，可以用来用 Java 编写函数式编程风格的代码。

### 逻辑范式

与命令式范式不同，逻辑范式关注的是问题的“是什么”部分，而不是如何解决它。你需要指定的只是需要解决的问题。程序会找出算法来解决它。算法对程序员来说不太重要。程序员的主要任务是尽可能地描述问题。在逻辑范式中，程序由一组公理和一个目标语句组成。公理集是构成理论的事实和推理规则的集合。目标陈述是一个定理。该程序使用演绎来证明理论中的定理。逻辑编程使用集合论中一个叫做关系的数学概念。集合论中的关系被定义为两个或更多集合的笛卡尔积的子集。假设有两个集合，`Persons`和`Nationality`，定义如下:

```
Person = {John, Li, Ravi}
Nationality = {American, Chinese, Indian}

```

两个集合的笛卡儿积表示为`Person x Nationality`，是另一个集合，如下所示:

```
Person x Nationality = {{John, American}, {John, Chinese}, {John, Indian},
                        {Li, American}, {Li, Chinese}, {Li, Indian},
                        {Ravi, American}, {Ravi, Chinese}, {Ravi, Indian}}

```

`Person x Nationality`的每个子集都是另一个定义数学关系的集合。一个关系的每个元素被称为一个*元组*。设`PersonNationality`为如下定义的关系:

```
PersonNationality = {{John, American}, {Li, Chinese}, {Ravi, Indian}}

```

在逻辑编程中，您可以使用`PersonNationality`关系作为已知为真的事实的集合。你可以这样陈述目标陈述(或问题)

```
PersonNationality(?, Chinese)

```

意思是“给我所有中国人的名字。”该程序将搜索`PersonNationality`关系，并提取匹配的元组，这些元组将是您的问题的答案(或解决方案)。在这种情况下，答案将是`Li`。

Prolog 是支持逻辑范例的编程语言的一个例子。

### 面向对象的范例

在面向对象(OO)范例中，程序由相互作用的对象组成。对象封装了数据和算法。数据定义了对象的状态。算法定义了对象的行为。一个对象通过向其他对象发送消息来与它们通信。当一个对象收到一个消息时，它通过执行它的一个算法来响应，这可能会修改它的状态。将面向对象的范例与命令式和函数式范例进行对比。在命令式和函数式范例中，数据和算法是分离的，而在面向对象的范例中，数据和算法是不分离的；它们被组合在一个实体中，这个实体被称为对象。

类是面向对象范例中编程的基本单位。相似的对象被分组到一个定义中，称为类。类的定义用于创建对象。对象也称为类的实例。一个类由实例变量和方法组成。对象的实例变量的值定义了对象的状态。一个类的不同对象分别维护它们的状态。也就是说，类的每个对象都有自己的实例变量副本。对象的状态对该对象是私有的。也就是说，不能从对象外部直接访问或修改对象的状态。类中的方法定义了它的对象的行为。方法就像过程范式中的过程(或子例程)。方法可以访问/修改对象的状态。通过调用一个对象的方法将消息发送给该对象。

假设你想在你的程序中表现真实世界的人。您将创建一个`Person`类，它的实例将代表您程序中的人。可以如清单 [1-1](#PC13) 所示定义`Person`类。这个例子使用了 Java 编程语言的语法。此时，您不需要理解您正在编写的程序中使用的语法；我将在后续章节中讨论定义类和创建对象的语法。

```
package com.jdojo.concepts;
public class Person {
    private String name;
    private String gender;
    public Person(String initialName, String initialGender) {
        name = initialName;
        gender = initialGender;
    }
    public String getName() {
        return name;
    }
    public void setName(String newName) {
        name = newName;
    }
    public String getGender() {
        return gender;
    }
}

Listing 1-1The Definition of a Person Class Whose Instances Represent Real-World Persons in a Program

```

`Person`类包括三样东西:

*   *两个实例变量* : `name`和`gender`

*   *一名建造师* : `Person(String initialName, String initialGender)`

*   *三种方法* : `getName()`、`setName(String newName)`、`getGender()`

实例变量存储对象的内部数据。每个实例变量的值表示对象的相应属性的值。每个`Person`类的实例都有一个`name`和`gender`数据的副本。对象在某一时间点的所有属性值(存储在实例变量中)共同定义了该对象在该时间点的状态。在现实世界中，一个人拥有许多属性，例如，姓名、性别、身高、体重、头发颜色、地址、电话号码等。然而，当您将现实世界中的人建模为一个类时，您只需要包括那些与被建模的系统相关的人的属性。在当前的演示中，让我们只对现实世界中一个人的两个属性——T3 和 T4——建模，作为`Person`类中的两个实例变量。

一个类包含对象的定义(或蓝图)。需要有一种方法来构造(创建或实例化)一个类的对象。对象还需要有其属性的初始值，这些初始值将决定其创建时的初始状态。类的构造函数用于创建该类的对象。一个类可以有许多构造函数，以便于创建具有不同初始状态的对象。`Person`类提供了一个构造函数，允许您通过指定`name`和`gender`的初始值来创建它的对象。下面的代码片段创建了两个`Person`类的对象:

```
Person john = new Person("John Jacobs", "Male");
Person donna = new Person("Donna Duncan", "Female");

```

第一个对象被称为`john`，其`"John Jacobs"`和`"Male"`分别作为其`name`和`gender`属性的初始值。第二个对象被称为`donna`，分别用`"Donna Duncan"`和`"Female"`作为其`name`和`gender`属性的初始值。

类的方法代表了它的对象的行为。比如在现实世界中，一个人是有名字的，当被问到名字时他们的反应能力就是他们的行为之一。`Person`类的对象能够响应三种不同的消息:`getName`、`setName`和`getGender`。对象响应消息的能力是使用方法实现的。你可以给一个`Person`对象发送一条消息，比如说`getName`，它会通过返回它的名字来响应。这就像问“你叫什么名字？”让对方告诉你他们的名字:

```
String johnName = john.getName();   // Send getName message to john
String donnaName = donna.getName(); // Send getName message to donna

```

发送给`Person`对象的`setName`消息要求将当前名称更改为新名称。以下代码片段将`donna`对象的名称从`"Donna Duncan"`更改为`"Donna Jacobs"`:

```
donna.setName("Donna Jacobs");

```

如果此时将`getName`消息发送给`donna`对象，它将返回`"Donna Jacobs"`，而不是“唐娜·邓肯”。

您可能会注意到您的`Person`对象没有能力响应像`setGender`这样的消息。人对象的性别是在对象创建时设置的，以后不能更改。但是，您可以通过向一个`Person`对象发送`getGender`消息来查询它的性别。对象可以(或不可以)响应什么消息是在设计时根据被建模系统的需要决定的。在`Person`对象的例子中，我们认为它们没有能力通过在`Person`类中不包含`setGender(String newGender)`方法来响应`setGender`消息。图 [1-3](#Fig3) 显示了名为`john`的`Person`对象的状态和接口。

![../images/323069_3_En_1_Chapter/323069_3_En_1_Fig3_HTML.png](../images/323069_3_En_1_Chapter/323069_3_En_1_Fig3_HTML.png)

图 1-3

人对象的状态和接口

面向对象的范式是一种非常强大的范式，用于在计算模型中对现实世界的现象进行建模。在日常生活中，我们习惯于和周围的物体打交道。面向对象的范例是自然而直观的，因为它让您从对象的角度来思考。然而，它并没有给你正确思考事物的能力。有时，问题的解决方案不属于面向对象范例的范畴。在这种情况下，您需要使用最适合问题领域的范例。面向对象的范例有一个学习曲线。它不仅仅是在你的程序中创建和使用对象。抽象、封装、多态和继承是面向对象范例的一些重要特征。为了充分利用面向对象的范例，您必须理解并能够使用本书涵盖的这些特性。在后续章节中，我们将详细讨论这些特性以及如何在程序中实现它们。

仅举几个例子，C++、Java 和 C#(发音为“C sharp”)都是支持面向对象范例的编程语言。注意，编程语言本身并不是面向对象的。它是面向对象的范例。编程语言可能有也可能没有支持面向对象范例的特性。

## Java 是什么？

Java 是一种通用编程语言。它具有支持基于面向对象、过程和函数范例的编程的特性。你经常会读到“Java 是一种面向对象的编程语言”这样的语句。这意味着 Java 语言具有支持面向对象范例的特性。编程语言不是面向对象的。它是面向对象的范例，而编程语言可能具有使实现面向对象范例变得容易的特性。有时候，程序员会有这样的误解，认为所有用 Java 编写的程序都是面向对象的。Java 还具有支持过程和函数范例的特性。你可以用 Java 写一个 100%过程化的程序，其中没有一点面向对象的成分。

Java 平台的最初版本是由 Sun Microsystems(自 2010 年 1 月起成为甲骨文公司的一部分)在 1995 年发布的。Java 编程语言的开发始于 1991 年。最初，这种语言被称为 Oak，意在用于电视机顶盒。

发布后不久，Java 成为一种非常流行的编程语言。它受欢迎的最重要的特征之一是它的“一次编写，随处运行”(WORA)特征。这个特性让您只需编写一次 Java 程序，就可以在任何平台上运行。例如，您可以在 UNIX 上编写和编译 Java 程序，并在 Microsoft Windows、Macintosh 或 UNIX 机器上运行它，而无需对源代码进行任何修改。WORA 是通过将 Java 程序编译成称为字节码的中间语言来实现的。字节码的格式是独立于平台的。一个称为 Java 虚拟机(JVM)的虚拟机用于在每个平台上运行字节码。注意，JVM 是一个用软件实现的程序。它不是物理机器，这就是它被称为“虚拟”机器的原因。JVM 的工作是根据它运行的平台将字节码转换成可执行代码。这个特性使得 Java 程序与平台无关。也就是说，同一个 Java 程序无需任何修改就可以在多个平台上运行。

以下是 Java 在软件行业中受欢迎和被接受背后的一些特征:

*   简单

*   各种各样的使用环境

*   稳健性

在这种情况下，简单可能是一个主观的词。在 Java 发布的时候，C++是软件行业广泛使用的流行而强大的编程语言。如果你是一名 C++程序员，Java 将为你提供比 C++更简单的学习和使用体验。Java 保留了 C/C++的大部分语法，这对试图学习这种新语言的 C/C++程序员很有帮助。更好的是，它排除了 C++中一些最令人困惑和难以正确使用的特性(尽管功能强大)。例如，Java 没有指针和多重继承，而这些在 C++中都有。

如果你正在学习 Java 作为你的第一编程语言，它是否是一门简单的语言对你来说可能不是真的。这就是为什么我们说 Java 或者任何编程语言的简单性都是非常主观的原因。自从第一次发布以来，Java 语言及其库(一组包含 Java 类的包)一直在增长。为了成为一名真正的 Java 开发者，你需要付出一些认真的努力。

Java 可以用来开发可以在不同环境下使用的程序。你可以用 Java 编写能在客户机-服务器环境中使用的程序。Java 程序早期最流行的用途是开发小程序，这在 Java SE 9 中已被弃用。applet 是嵌入在网页中的 Java 程序，它使用超文本标记语言(HTML ),并在诸如 Firefox、Google Chrome 等网络浏览器中显示。applet 的代码存储在 web 服务器上，当浏览器加载包含 applet 引用的 HTML 页面时，下载到客户机上，并在客户机上运行。

Java 包含了一些使开发分布式应用程序变得容易的特性。分布式应用程序由运行在通过网络连接的不同机器上的程序组成。Java 的一些特性使得开发并发应用程序变得很容易。一个并发应用有多个并行运行的交互线程(一个*线程*就像一个程序中的独立进程，有自己的值和处理，独立于其他线程)。

程序的健壮性是指它合理处理意外情况的能力。程序中的意外情况也称为错误。Java 通过在程序生命周期的不同阶段提供许多错误检查特性来提供健壮性。以下是 Java 程序中可能出现的三种不同类型的错误:

*   编译时错误

*   运行时错误

*   逻辑错误

编译时错误也称为语法错误。它们是由 Java 语言语法的不正确使用引起的。它们被 Java 编译器检测到。有编译时错误的程序在错误被纠正之前不会编译成字节码。语句末尾缺少分号，将十进制值(如 10.23)赋给整数类型的变量，等等。都是编译时错误的例子。

Java 程序运行时会出现运行时错误。这种错误不会被编译器检测到，因为编译器没有所有可用的运行时信息。Java 是一种强类型语言，它在编译时和运行时都有强大的类型检查功能。Java 提供了一种简洁的异常处理机制来处理运行时错误。当 Java 程序中出现运行时错误时，JVM 会抛出一个异常，程序可以捕捉并处理这个异常。例如，将整数除以零(如`17/0`)会产生运行时错误。Java 通过提供自动内存分配和释放的内置机制，避免了严重的运行时错误，如内存溢出和内存泄漏。自动内存释放的特性被称为垃圾收集。

逻辑错误是程序中最关键的错误，而且很难发现。它们是由程序员通过不正确地实现功能需求而引入的。Java 编译器或 Java 运行时无法检测到这种错误。当应用程序测试人员或用户将程序的实际行为与其预期行为进行比较时，他们会发现这些错误。有时，一些逻辑错误会潜入生产环境中，甚至在应用程序退役后也不会被注意到。

程序中的错误被称为 *bug* 。在程序中发现并修复错误的过程被称为*调试*。所有现代集成开发环境(ide)，如 NetBeans、Eclipse、JDeveloper 和 IntelliJ IDEA，都为程序员提供了一种叫做*调试器*的工具，让他们一步一步地运行程序，并在每一步检查程序的状态以检测错误。调试是程序员日常活动的现实。如果你想成为一名优秀的程序员，你必须学习并善于使用你用来开发 Java 程序的开发工具中的调试器。

## 面向对象的范例和 Java

面向对象范式支持四大原则:*抽象*、*封装*、*继承*和*多态*。它们也被称为面向对象范例的四大支柱。抽象是暴露一个实体的基本细节，同时忽略不相关的细节，以减少用户的复杂性的过程。封装是将数据和对数据的操作捆绑在一个实体中的过程。继承用于从现有类型派生新类型，从而建立父子关系。多态性让一个实体在不同的上下文中有不同的含义。这四项原则将在接下来的章节中详细讨论。

### 抽象

程序为现实世界的问题提供了解决方案。程序的大小可能从几行到几百万行不等。它可以写成一个从第一行到第一百万行的整体结构。如果一个完整的程序超过 25-50 行，那么它将变得难以编写、理解和维护。为了更容易维护，一个大的整体程序必须分解成更小的子程序。子程序然后被组合在一起解决原来的问题。分解程序时必须小心。所有的子程序都必须足够简单和小，能够被它们自己理解，当它们被汇编时，它们必须解决原始的问题。让我们考虑对设备的以下要求:

> *设计并开发一种设备，让用户使用所有英文字母、数字和符号来键入文本。*

设计这种设备的一种方法是提供一种键盘，该键盘具有用于所有字母、数字和符号的所有可能组合的键。这种解决方案是不合理的，因为设备的尺寸将是巨大的。你可能意识到我们正在谈论设计一个键盘。看看你的键盘，看看它是如何设计的。它将输入文本的问题分解为一次输入一个字母、一个数字或一个符号，这代表了原始问题的一小部分。如果您可以一次键入所有字母、所有数字和所有符号，则可以键入任意长度的文本。

原始问题的另一个分解可以包括两个键:一个键用于键入水平线，另一个键用于键入垂直线，用户可以使用这两个键来键入`E`、`T`、`I`、`F`、`H`和`L`，因为这些字母仅由水平线和垂直线组成。使用这种解决方案，用户只需两个键的组合就可以键入六个字母。但是，根据您使用键盘的经验，您可能会意识到，分解按键以使一个按键仅用于输入字母的一部分并不是一个合理的解决方案，尽管这是一个解决方案。

为什么提供两个键来键入六个字母不是一个合理的解决方案？我们不是在节省空间和键盘上的键数吗？在这种情况下,“合理”一词的使用是相对的。从纯粹主义者的角度来看，这可能是一个合理的解决方案。我称之为“不合理”的理由是它不容易被用户理解。它向用户暴露了比需要的更多的细节。用户必须记住水平线位于`T`的顶部和`L`的底部。当用户为每个字母获得单独的密钥时，他们不必处理这些细节。重要的是，为部分原始问题提供解决方案的子程序必须被简化，以具有相同的细节水平，从而无缝地协同工作。同时，子程序不应该公开不需要知道的细节以便使用。

最后，所有的键都安装在一个键盘上，它们可以单独更换。如果一把钥匙坏了，它可以被替换，而不用担心其他钥匙。类似地，当程序被分解成子程序时，子程序中的修改不应该影响其他子程序。子程序还可以通过关注不同层次的细节而忽略其他细节来进一步分解。一个好的程序分解旨在提供以下特征:

*   简单

*   隔离

*   可维护性

每个子程序都应该足够简单，便于自己理解。简单是通过关注相关的信息，忽略不相关的信息来实现的。哪些信息是相关的，哪些是不相关的，这取决于上下文。

每个子程序都应该与其他子程序隔离开来，以便子程序中的任何更改都应该具有局部影响。一个子程序中的更改不应影响任何其他子程序。子程序定义了与其他子程序交互的接口。子程序的内部细节对外界是隐藏的。只要子程序的接口保持不变，其内部细节的变化就不会影响与其交互的其他子程序。

每个子程序都应该足够小，以便于编写、理解和维护。

所有这些特征都是在一个问题(或解决一个问题的程序)的分解过程中通过一个叫做抽象的过程实现的。抽象是一种对问题进行分解的方法，它关注相关的细节，忽略特定上下文中与问题无关的细节。请注意，没有一个问题的细节是不相关的。换句话说，问题的每个细节都是相关的。然而，一些细节可能在一个上下文中相关，而一些在另一个上下文中相关。需要注意的是，是“上下文”决定了哪些细节是相关的，哪些是不相关的。例如，考虑设计和开发键盘的问题。从用户的角度来看，键盘由可以按下和释放以键入文本的键组成。键的数量、类型、大小和位置是与键盘用户相关的唯一细节。然而，按键并不是键盘的唯一细节。键盘有一个电子电路，它与电脑相连。当用户按键时，键盘和计算机内部会发生很多事情。键盘的内部工作与键盘设计者和制造商有关。然而，它们与键盘用户无关。你可以说不同的用户在不同的语境下对同一件事有不同的看法。关于事物的哪些细节是相关的，哪些是不相关的，这取决于用户和上下文。

抽象是指考虑在特定环境中以适当的方式看待问题所必需的细节，并忽略(隐藏、抑制或忘记)不必要的细节。抽象上下文中的“隐藏”和“抑制”等术语可能会产生误导。这些术语可能意味着隐藏问题的一些细节。抽象是关于一个事物的哪些细节应该被考虑，哪些不应该为了一个特定的目的而被考虑。这确实意味着隐藏细节。东西是如何隐藏的是另一个叫做信息隐藏的概念，这将在下一节讨论。

术语“抽象”用于表示两个事物之一:过程或实体。作为一个过程，它是一种技术，提取关于一个问题的相关细节，忽略不相关的细节。作为一个实体，它是对一个问题的特定观点，考虑一些相关的细节，忽略不相关的细节。

#### 隐藏复杂性的抽象

我们来讨论一下抽象在现实编程中的应用。假设你想写一个程序来计算两个整数之间所有整数的和。假设您想计算 10 到 20 之间所有整数的和。你可以这样写程序。如果您不理解本节程序中使用的语法，请不要担心。试着理解抽象是如何被用来分解程序的:

```
int sum = 0;
int counter = 10;
while (counter <= 20) {
    sum = sum + counter;
    counter = counter + 1;
}
System.out.println(sum);

```

这段代码将添加`10 + 11 + 12 + ... + 20`并打印`165`。假设您想计算`40`和`60`之间所有整数的和。以下是实现这一目标的计划:

```
int sum = 0;
int counter = 40;
while (counter <= 60) {
    sum = sum + counter;
    counter = counter + 1;
}
System.out.println(sum);

```

这段代码将对`40`和`60`之间的所有整数求和，并打印出`1050`。请注意这两段代码的相似之处和不同之处。两者的逻辑是一样的。但是，范围的下限和上限是不同的。如果您可以忽略两个代码片段之间存在的差异，您将能够避免两个地方的逻辑重复。让我们考虑下面的代码片段:

```
int sum = 0;
int counter = lowerLimit;
while (counter <= upperLimit) {
    sum = sum + counter;
    counter = counter + 1;
}
System.out.println(sum);

```

这一次，您没有使用任何范围的下限和上限的任何实际值。相反，您使用了在编写代码时未知的`lowerLimit`和`upperLimit`占位符。通过在代码中使用两个占位符，您隐藏了范围下限和上限的标识。换句话说，在编写这段代码时，您忽略了它们的实际值。您在代码中应用了抽象过程，忽略了范围的下限和上限的实际值。

当这段代码被执行时，实际值必须被替换为`lowerLimit`和`upperLimit`占位符。在编程语言中，这是通过将代码片段打包在一个称为*过程*的模块(子例程或子程序)中实现的。占位符被定义为该过程的形式参数。清单 [1-2](#PC20) 有这样一个程序的代码。

```
int getRangeSum(int lowerLimit, int upperLimit) {
    int sum = 0;
    int counter = lowerLimit;
    while (counter <= upperLimit) {
        sum = sum + counter;
        counter = counter + 1;
    }
    return sum;
}

Listing 1-2A Procedure Named getRangeSum to Compute the Sum of All Integers Between Two Integers

```

一个过程有一个名字，在这个例子中是`getRangeSum`。过程有一个返回类型，在它的名字前面指定。返回类型指示它将返回给调用者的值的类型。

在这种情况下，返回类型是`int`，这表明计算的结果将是一个整数。

一个过程有形参(可能是零)，这些形参在名字后面的括号中指定。形参由数据类型和名称组成。在这种情况下，形参被命名为`lowerLimit`和`upperLimit`，两者的数据类型都是`int`。它有一个主体，放在大括号内。过程的主体包含逻辑。

当您想要执行某个过程的代码时，您必须传递其形参的实际值。您可以计算并打印出`10`和`20`之间所有整数的和，如下所示:

```
int s1 = getRangeSum(10, 20);
System.out.println(s1);

```

这段代码将打印`165`。要计算`40`和`60`之间所有整数的总和，您可以执行以下代码片段:

```
int s2 = getRangeSum(40, 60);
System.out.println(s2);

```

这段代码将打印出`1050`，这与您之前获得的结果完全相同。

你在定义`getRangeSum`过程中使用的抽象方法被称为*参数化抽象*。过程中的形参用于隐藏过程主体操作的实际数据的身份。`getRangeSum`过程中的两个参数隐藏了整数范围的下限和上限。现在你已经看到了抽象的第一个具体例子。抽象是一个庞大的话题。在这一节中，我将讲述更多关于抽象的基础知识。

假设一个程序员编写了`getRangeSum`过程的代码，如清单 [1-2](#PC20) 所示，另一个程序员想要使用它。第一个程序员是程序的设计者和编写者；第二个是过程的用户。使用`getRangeSum`程序的用户需要知道哪些信息？

在回答这个问题之前，让我们考虑一个设计和使用 DVD(数字多功能光盘)播放器的真实例子。DVD 播放器是由电子工程师设计开发的。你如何使用 DVD 播放器？在你使用 DVD 播放器之前，你不需要打开它来研究它的基于电子工程理论的所有细节。当你买它的时候，它有一本如何使用它的手册。一个 DVD 播放器被包装在一个盒子里。盒子里面藏着玩家的详细资料。同时，盒子以接口的形式向外界暴露了关于播放器的一些细节。DVD 播放器的界面由以下项目组成:

*   输入和输出连接端口，用于连接电源插座、电视机等。

*   插入 DVD 的面板

*   执行弹出、播放、暂停、快进等操作的一组按钮。

DVD 播放机附带的手册描述了为用户提供的播放机界面的用法。DVD 用户不需要担心其内部工作的细节。手册还描述了操作它的一些条件。例如，在使用之前，您必须将电源线插入电源插座并打开电源。

程序的设计、开发和使用方式与 DVD 播放器相同。清单 [1-2](#PC20) 中所示程序的用户无需担心用于实现程序的内部逻辑。程序的用户只需要知道它的用法，包括使用它的界面，以及在使用它之前和之后必须满足的条件。换句话说，你需要提供一份描述其用法的`getRangeSum`程序手册。使用`getRangeSum`程序的用户需要阅读其手册。一个程序的“手册”就是它的规格说明书。有时它也被称为文档或注释。它提供了另一种抽象方法，称为规范抽象。它描述(或公开或关注)程序的“是什么”部分，并对用户隐藏(或忽略或隐藏)程序的“如何”部分。

清单 [1-3](#PC23) 显示了与其规格相同的`getRangeSum`程序代码。

```
/**
 * Computes and returns the sum of all integers between two
 * integers specified by lowerLimit and upperLimit parameters.
 *
 * The lowerLimit parameter must be less than or equal to the
 * upperLimit parameter. If the sum of all integers between the
 * lowerLimit and the upperLimit exceeds the range of the int data
 * type then result is not defined.
 *
 * @param lowerLimit The lower limit of the integer range
 * @param upperLimit The upper limit of the integer range
 * @return The sum of all integers between lowerLimit (inclusive)
 *         and upperLimit (inclusive)
 */
public static int getRangeSum(int lowerLimit, int upperLimit) {
    int sum = 0;
    int counter = lowerLimit;
    while (counter <= upperLimit) {
        sum = sum + counter;
        counter = counter + 1;
    }
    return sum;
}

Listing 1-3The getRangeSum Procedure with Its Specification for the Javadoc Tool

```

Javadoc 标准用于编写 Java 程序的规范，Javadoc 工具可以处理该规范以生成 HTML 页面。在 Java 中，程序元素的规范被放在元素前的`/**`和`*/`之间。该规范是为`getRangeSum`程序的用户准备的。Javadoc 工具将为`getRangeSum`过程生成规范，如图 [1-4](#Fig4) 所示。

![../images/323069_3_En_1_Chapter/323069_3_En_1_Fig4_HTML.png](../images/323069_3_En_1_Chapter/323069_3_En_1_Fig4_HTML.png)

图 1-4

getRangeSum 过程的规范

该规范提供了 getRangeSum 过程的描述(“什么”部分)。它还指定了两个条件，称为前置条件，在调用过程时这两个条件必须为真。第一个前提条件是下限必须小于或等于上限。第二个先决条件是，下限和上限的值必须足够小，以便它们之间的所有整数之和符合`int`数据类型的大小。它指定了另一个条件，称为后置条件，在“Returns”子句中指定。只要前提条件成立，后置条件就成立。前置条件和后置条件就像程序和用户之间的契约(或协议)。它声明，只要程序的用户确保前置条件成立，程序就保证后置条件成立。请注意，规范从未告诉用户程序如何实现(实现细节)后置条件。它只告诉“什么”它要做，而不是“如何”它要做。拥有规范的`getRangeSum`程序的用户不需要查看`getRangeSum`过程的主体来找出它使用的逻辑。换句话说，您向用户提供了这个规范，从而隐藏了`getRangeSum`过程的实现细节。也就是说，`getRangeSum`过程的用户可以为了使用它而忽略它的实现细节。这是抽象的另一个具体例子。通过使用规范来隐藏子程序的实现细节(“如何”部分)并公开其用法(“做什么”部分)的方法被称为通过规范的*抽象*。

参数化抽象和规范抽象让程序的用户把程序看作一个黑盒，他们只关心程序产生的效果，而不关心程序如何产生这些效果。图 [1-5](#Fig5) 描述了`getRangeSum`程序的用户视图。注意，用户看不到(也不需要看到)包含细节的过程主体。细节只与程序的作者有关，与用户无关。

![../images/323069_3_En_1_Chapter/323069_3_En_1_Fig5_HTML.png](../images/323069_3_En_1_Chapter/323069_3_En_1_Fig5_HTML.png)

图 1-5

用户将 getRangeSum 过程视为使用抽象的黑盒

通过应用抽象来定义`getRangeSum`过程，您获得了哪些优势？最重要的优势之一就是隔离。它与其他程序相隔离。如果你修改了它主体内部的逻辑，其他程序，包括正在使用它的程序，都不需要修改。要打印`10`和`20`之间的整数之和，可以使用以下程序:

```
int s1 = getRangeSum(10, 20);
System.out.println(s1);

```

该过程的主体使用一个`while`循环，循环的执行次数与上限和下限之间的整数次数一样多。`getRangeSum`程序内的`while`循环执行`n`次，其中`n`等于`(upperLimit – lowerLimit + 1)`。需要执行的指令数量取决于输入值。有一种更好的方法来计算两个整数`lowerLimit`和`upperLimit`之间所有整数的和，使用下面的公式:

```
n = upperLimit - lowerLimit + 1;
sum = n * (2 * lowerLimit + (n-1))/2;

```

如果使用这个公式，计算两个整数之间所有整数之和所执行的指令数总是相同的。你可以重写`getRangeSum`过程的主体，如清单 [1-4](#PC26) 所示。此处未显示`getRangeSum`程序的规格。

```
public int getRangeSum(int lowerLimit, int upperLimit) {
    int n = upperLimit - lowerLimit + 1;
    int sum = n * (2 * lowerLimit + (n-1))/2;
    return sum;
}

Listing 1-4Another Version of the getRangeSum Procedure with the Logic Changed Inside Its Body

```

注意清单 [1-3](#PC23) 和清单 [1-4](#PC26) 之间的`getRangeSum`过程的主体(实现或“如何”部分)已经改变。然而，`getRangeSum`过程的用户不会受到这一变化的影响，因为通过使用抽象，该过程的实现细节对其用户是隐藏的。如果您想使用清单 [1-4](#PC26) 中所示的`getRangeSum`过程版本计算 10 到 20 之间所有整数的和，您的旧代码仍然有效:

```
int s1 = getRangeSum(10, 20);
System.out.println(s1);

```

您已经看到了抽象的最大好处之一，其中程序的实现细节(在本例中是一个过程)可以被改变，而无需保证使用该程序的代码的任何改变。这个好处也给你一个机会来重写你的程序逻辑，以提高将来的性能，而不影响应用程序的其他部分。

在本节中，我考虑了两种类型的抽象:

*   过程抽象

*   数据抽象

过程抽象允许您定义一个过程，例如`getRangeSum`，您可以将它用作一个动作或一个任务。到目前为止，我一直在讨论过程抽象。参数化抽象和规范抽象是实现过程抽象和数据抽象的两种方法。下一节将详细讨论数据抽象。

#### 数据抽象

面向对象编程基于数据抽象。然而，在讨论数据抽象之前，我需要简单地讨论一下数据类型。数据类型(或简称为类型)由三个部分定义:

*   一组值(或数据对象)

*   可以应用于集合中所有值的一组运算

*   一种数据表示形式，它决定了值的存储方式

编程语言提供了一些预定义的数据类型，称为内置数据类型。他们还让程序员定义他们自己的数据类型，这就是所谓的用户定义的数据类型。由一个不可分割的原子值组成的数据类型(在没有任何其他数据类型帮助的情况下定义)被称为原始数据类型。比如 Java 内置了`int`、`float`、`boolean`、`char`等原语数据类型。在 Java 中定义`int`原始数据类型的三个组件如下:

*   int 数据类型由–2147483648 和 2147483647 之间的所有整数组成。

*   为`int`数据类型定义了加、减、乘、除、比较等操作。

*   `int`数据类型的值在 32 位存储器中以 2 的补码形式表示。

数据类型的所有三个组成部分都是由 Java 语言预定义的。您不能扩展或重新定义`int`数据类型的定义。您可以将`int`数据类型的值命名为

```
int n1;

```

该语句说明`n1`是一个名称(技术上称为标识符),它可以与定义`int`数据类型的值的值集中的一个值相关联。例如，您可以使用如下赋值语句将整数`26`与名称`n1`相关联:

```
n1 = 26;

```

在这个阶段，您可能会问，“与名称`n1`相关联的值`26`存储在内存中的什么地方？”从`int`数据类型的定义中可以知道`n1`将占用 32 位内存。但是，你不知道，不能知道，也不需要知道 32 位在内存中的什么位置分配给了`n1`。你在这里看到抽象的例子了吗？如果你在这种情况下看到一个抽象的例子，你就对了。这是一个抽象的例子，它内置于 Java 语言中。在这种情况下，关于`int`数据类型的数据值的数据表示的信息对该数据类型的用户(程序员)是隐藏的。换句话说，程序员忽略了`n1`的内存位置，而专注于它的值和可以在其上执行的操作。程序员不关心`n1`的内存是分配在寄存器、RAM 还是硬盘中。

面向对象的编程语言(如 Java)允许您使用称为数据抽象的抽象机制来创建新的数据类型。新的数据类型被称为抽象数据类型(ADT)。ADT 中的数据对象可能由原始数据类型和其他 ADT 的组合组成。ADT 定义了一组可应用于其所有数据对象的操作。数据表示总是隐藏在 ADT 中。对于 ADT 的用户来说，它只包含操作。它的数据元素只能使用它的操作来访问和操作。使用数据抽象的优点是，它的数据表示形式可以更改，而不会影响任何使用 ADT 的代码。

Tip

数据抽象允许程序员创建一种新的数据类型，称为抽象数据类型，其中数据对象的存储表示对数据类型的用户是隐藏的。换句话说，ADT 仅根据可以应用于其类型的数据对象的操作来定义，而无需知道数据的内部表示。这种数据类型被称为抽象的原因是，ADT 的用户永远看不到数据值的表示。用户以抽象的方式查看 ADT 的数据对象，在不知道数据对象表示细节的情况下对它们应用操作。请注意，ADT 并不意味着没有数据表示。数据表示始终存在于 ADT 中。这只意味着对用户隐藏数据表示。

Java 有一些构造，例如类、接口、注释和`enum`，允许您定义新的 ADT。当您使用一个类来定义一个新的 ADT 时，您需要小心隐藏数据表示，因此您的新数据类型确实是抽象的。如果 Java 类中的数据表示没有被隐藏，那么该类会创建一个新的数据类型，但不会创建 ADT。Java 中的类为您提供了一些特性，您可以使用这些特性来公开或隐藏数据表示。在 Java 中，一个类数据类型的值的集合被称为*对象*。对对象的操作被称为*方法*。对象的实例变量(也称为字段)是类类型的数据表示。

Java 中的类允许你实现对数据表示的操作。Java 中的接口允许您创建纯 ADT。接口让您只提供可以应用于其类型的数据对象的操作规范。接口中不能提及操作或数据表示的实现。清单 [1-1](#PC13) 显示了使用 Java 语言语法的`Person`类的定义。通过定义名为`Person`的类，您已经创建了一个新的 ADT。它对`name`和`gender`的内部数据表示使用了`String`数据类型(`String`是 Java 类库提供的内置 ADT)。请注意，`Person`类的定义在`name`和`gender`声明中使用了`private`关键字来对外界隐藏它们。`Person`类的用户不能访问`name`和`gender`数据元素。它提供了四个操作:一个构造函数和三个方法(`getName`、`setName`和`getGender`)。

构造器操作用于初始化新构造的`Person`类型的数据对象。`getName`和`setName`操作分别用于访问和修改`name`数据元素。`getGender`操作用于访问`gender`数据元素的值。

`Person`类的用户必须只使用这四个操作来处理`Person`类型的数据对象。`Person`类型的用户不知道用于存储`name`和`gender`数据元素的数据存储类型。我交替使用三个术语，“类型”、“类”和“接口”，因为它们在数据类型的上下文中表示相同的意思。它给了`Person`类型的开发人员改变`name`和`gender`数据元素的数据表示的自由，而不会影响任何`Person`类型的用户。假设一个`Person`类型的用户有下面的代码片段:

```
Person john = new Person("John Jacobs", "Male");
String intialName = john.getName();
john.setName("Wally Jacobs");
String changedName = john.getName();

```

这段代码只是根据`Person`类型提供的操作编写的。它没有(也不可能)直接引用`name`和`gender`实例变量。让我们看看如何在不影响代码片段的情况下改变`Person`类型的数据表示。清单 [1-5](#PC31) 显示了`Person`类新版本的代码。

```
package com.jdojo.concepts;
public class Person {
    private String[] data = new String[2];
    public Person(String initialName, String initialGender) {
        data[0] = initialName;
        data[1] = initialGender;
    }
    public String getName() {
        return data[0];
    }
    public void setName(String newName) {
        data[0] = newName;
    }
    public String getGender() {
        return data[1];
    }
}

Listing 1-5Another Version of the Person Class That Uses a String Array of Two Elements to Store Name and Gender Values as Opposed to Two String Variables

```

比较清单 [1-1](#PC13) 和清单 [1-5](#PC31) 中的代码。这一次，您用一个包含两个元素的`String`数组替换了两个实例变量(`name`和`gender`)，它们是清单 [1-1](#PC13) 中`Person`类型的数据表示。因为类中的操作(或方法)是对数据表示进行操作的，所以您必须改变`Person`类型中所有四个操作的实现。清单 [1-5](#PC31) 中的客户端代码是根据四个操作的规范而不是它们的实现编写的。因为您没有更改任何操作的规范，所以您不需要更改使用`Person`类的代码片段；对于`Person`类型的新定义，它仍然有效，如清单 [1-5](#PC31) 所示。`Person`类中的一些方法通过参数化使用抽象，所有的方法都通过规范使用抽象。我没有在这里展示方法的规范，这将是 Javadoc 注释。

在本节中，您已经看到了数据抽象的两个主要好处:

*   它允许您通过定义新的数据类型来扩展编程语言。您创建的新数据类型取决于应用程序域。例如，对于银行系统，`Person`、`Currency`和`Account`可能是新数据类型的好选择，而对于汽车保险应用程序，`Person`、`Vehicle`和`Claim`可能是好选择。新数据类型中包含的操作取决于应用程序的需要。

*   使用数据抽象创建的数据类型可以改变数据的表示，而不影响使用该数据类型的客户端代码。

### 封装和信息隐藏

术语封装用来表示两种不同的东西:一个过程或一个实体。作为一个流程，它是将一个或多个项目捆绑到一个容器中的行为。容器可以是物理的，也可以是逻辑的。作为一个实体，它是一个容纳一个或多个项目的容器。

编程语言以多种方式支持封装。过程是执行任务的步骤的封装；数组是几个相同类型元素的封装；等等。在面向对象编程中，封装是将数据和对数据的操作捆绑到一个称为类的实体中。Java 以多种方式支持封装:

*   它允许您将数据和对数据进行操作的方法捆绑在一个名为*类*的实体中。

*   它允许您将一个或多个逻辑上相关的类捆绑在一个名为*包*的实体中。Java 中的包是一个或多个相关类的逻辑集合。包创建了一个新的命名范围，其中所有的类都必须有唯一的名称。两个类在 Java 中可以有相同的名字，只要它们被捆绑(或封装)在两个不同的包中。

*   它允许您将包捆绑到一个在 Java SE 9 中引入的*模块*中。模块可以导出它的包。其他模块可以访问导出包中定义的类型，而其他模块无法访问非导出包中定义的类型。

*   它允许你将一个或多个相关的类捆绑在一个名为*编译单元* *的实体中。*一个编译单元中的所有类都可以独立于其他编译单元进行编译。

在讨论面向对象编程的概念时，两个术语——*封装*和*信息隐藏*——经常互换使用。然而，它们在面向对象编程中是不同的概念，因此不应该互换使用。封装就是将项目捆绑在一起成为一个实体。信息隐藏是隐藏可能改变的实现细节的过程。封装不关心捆绑在实体中的项目是否对应用程序中的其他模块隐藏。什么应该被隐藏(或忽略)和什么不应该被隐藏是抽象的关注点。抽象只关心应该隐藏哪一项。抽象不关心项目应该如何隐藏。信息隐藏关注的是如何隐藏一个项目。

封装、抽象和信息隐藏是三个独立的概念。不过，它们的关系非常密切。一个概念促进了其他概念的工作。理解它们在面向对象编程中所扮演角色的细微差别是很重要的。

Tip

在 Java SE 中，您会经常遇到类似“一个模块提供了强大的封装”这样的语句。这里，术语*封装*用于信息隐藏的意义上。这意味着模块中非导出包中的类型对其他模块是隐藏的(或不可访问的)。

可以使用隐藏或不隐藏任何信息的封装。例如，清单 [1-1](#PC13) 中的`Person`类展示了一个封装和信息隐藏的例子。数据元素(`name`和`gender`)和方法(`getName()`、`setName()`和`getGender()`)被捆绑在一个名为`Person`的类中。这就是封装。换句话说，`Person`类是数据元素`name`和`gender`加上方法`getName()`、`setName()`和`getGender()`的封装。同一个`Person`类通过对外界隐藏数据元素来使用信息隐藏。注意`name`和`gender`数据元素使用 Java 关键字`private`，这实质上是对外界隐藏了它们。清单 [1-6](#PC32) 显示了一个`Person2`类的代码。

```
package com.jdojo.concepts;
public class Person2 {
    public String name;   // Not hidden from its users
    public String gender; // Not hidden from its users
    public Person2(String initialName, String initialGender) {
        name = initialName;
        gender = initialGender;
    }
    public String getName() {
        return name;
    }
    public void setName(String newName) {
        name = newName;
    }
    public String getGender() {
        return gender;
    }
}

Listing 1-6The Definition of the Person2 Class in Which Data Elements Are Not Hidden by Declaring Them Public

```

清单 [1-1](#PC13) 中的代码和清单 [1-6](#PC32) 中的代码除了两个小的区别之外基本相同。`Person2`类使用关键字`public`来声明`name`和`gender`数据元素。`Person2`类使用封装的方式与`Person`类相同。然而，`name`和`gender`数据元素并未隐藏。也就是说，`Person2`类不使用数据隐藏(数据隐藏就是信息隐藏的一个例子)。如果你看看`Person`和`Person2`类的构造函数和方法，它们的主体使用了信息隐藏，因为写在它们主体内部的逻辑对它们的用户是隐藏的。

Tip

封装和信息隐藏是面向对象编程的两个不同概念。一个的存在并不意味着另一个的存在。

### 遗产

继承是面向对象编程中的另一个重要概念。它让你以一种新的方式使用抽象。在前面的章节中，您已经看到了类是如何表示抽象的。清单 [1-1](#PC13) 中显示的`Person`类代表了现实世界中一个人的抽象。继承机制允许您通过扩展现有的抽象来定义新的抽象。现有的抽象称为超类型、超类、父类或基类。新的抽象被称为子类型、子类、子类或派生类。据说子类型是从超类型派生(或继承)来的，超类型是子类型的泛化，子类型是超类型的特化。继承可以用来在多个层次上定义新的抽象。子类型可以用作超类型来定义另一个子类型，依此类推。继承产生了以层次形式排列的一族类型。

继承允许你在不同层次使用不同程度的抽象。在图 [1-6](#Fig6) 中，`Person`类位于继承层次的顶端(最高级别)。`Customer`和`Employee`类位于继承层次的第二层。当您沿着继承层次向下移动时，您会关注更重要的信息。换句话说，在继承的更高层次上，你关注的是更大的图景；在较低层次的继承中，你关心越来越多的细节。从抽象的角度来看，还有另一种方式来看待继承层次。在图 [1-6](#Fig6) 中的`Person`关卡，你专注于`Customer`和`Employee`的共同特点，忽略了它们之间的差异。在`Employee`级别，你关注`Clerk`、`Programmer`和`Cashier`的共同特征，忽略它们之间的差异。

![../images/323069_3_En_1_Chapter/323069_3_En_1_Fig6_HTML.jpg](../images/323069_3_En_1_Chapter/323069_3_En_1_Fig6_HTML.jpg)

图 1-6

人员类的继承层次结构

在继承层次结构中，超类型及其子类型代表一种“是-是”关系。即一个`Employee`是一个`Person`；一个`Programmer`是一个`Employee`；等等。因为较低层次的继承意味着更多的信息，所以子类型总是包含其父类型所拥有的，甚至更多。继承的这一特点导致了面向对象编程中的另一个特点，即所谓的*替代性原则*。这意味着父类型总是可以被它的子类型替换。例如，在你的`Person`抽象中，你只考虑了一个人的`name`和`gender`信息。如果从`Person`继承`Employee`，`Employee`包含从`Person`继承的`name`和`gender`信息。`Employee`可能包括更多信息，如员工 ID、雇佣日期、工资等。如果上下文中需要一个`Person`,这意味着只有`name`和`gender`信息与该上下文相关。您总是可以用`Employee`、`Customer`、`Clerk`或`Programmer`替换该上下文中的`Person`，因为作为`Person`的子类型(直接或间接)，这些抽象保证了它们至少有能力处理`name`和`gender`信息。

在编程级别，继承提供了代码重用机制。超类型中编写的代码可以被其子类型重用。子类型可以通过添加更多的功能或重新定义其超类型的现有功能来扩展其超类型的功能。

Tip

继承也被用作实现多态性的技术，这将在下一节讨论。继承让你编写多态代码。代码是根据超类型编写的，同样的代码也适用于子类型。

继承是一个很大的话题。这本书用了整整一章来讲述如何在 Java 中使用继承。

### 多态性

“多态性”一词源于两个希腊词:“poly”(表示许多)和“morphos”(表示形式)。在编程中，多态性是一个实体(例如，变量、类、方法、对象、代码、参数等)的能力。)在不同的语境中呈现不同的含义。具有不同含义的实体称为多态实体。存在各种类型的多态性。每种类型的多态性都有一个名称，通常表明这种类型的多态性在实践中是如何实现的。多态的正确使用会产生通用的和可重用的代码。多态性的目的是通过编写适用于许多类型(或者理想情况下适用于所有类型)的通用类型来编写可重用和可维护的代码。多态性可以分为以下两类:

*   特定多态性

*   通用多态性

如果一段代码适用于有限数量的类型，并且在编写代码时必须知道所有这些类型，这就是所谓的*特定多态性*。特殊多态性也被称为*表观多态性*，因为它不是真正意义上的多态性。一些计算机科学纯粹主义者根本不认为特别多态是多态。

临时多态性进一步分为两类:

*   重载多态性

*   强制多态性

如果一段代码以这样一种方式编写，它适用于无限多种类型(也适用于编写代码时未知的新类型)，它被称为*通用多态性*。在通用多态性中，相同的代码适用于许多类型，而在专用多态性中，为不同的类型提供不同的代码实现，给人一种明显的多态性印象。

通用多态性进一步分为两类:

*   包含多态性

*   参数多态性

在随后的部分中，我将通过例子详细描述这些类型的多态性。

#### 重载多态性

重载是一种特殊的多态性。当一个方法(在 Java 中称为方法，在其他语言中称为函数)或一个操作符至少有两个作用于不同类型的定义时，就会导致重载。在这种情况下，相同的名称(对于方法或操作符)用于其不同的定义。也就是说，同一个名字表现出许多行为，因此具有多态性。这样的方法和运算符称为重载方法和重载运算符。Java 让你定义重载的方法。Java 有一些重载的操作符，但是它不允许为 ADT 重载操作符。也就是说，不能在 Java 中为操作符提供新的定义。清单 [1-7](#PC33) 显示了一个名为`MathUtil`的类的代码。

```
// MathUtil.java
package com.jdojo.concepts;
public class MathUtil {
    public static int max(int n1, int n2) {
        /* Code to determine the maximum of two integers goes here */
    }
    public static double max(double n1, double n2) {
        /* Code to determine the maximum of two floating-point numbers goes here */
    }
    public static int max(int[] num) {
        /* Code to determine the maximum in an array of int goes here */
    }
}

Listing 1-7An Example of an Overloaded Method in Java

```

`MathUtil`类的`max()`方法被重载。它有三个定义，每个定义都执行计算最大值的相同任务，但是是在不同的类型上。第一个定义最多计算两个`int`数据类型的数字，第二个定义最多计算两个`double`数据类型的浮点数，第三个定义最多计算一个`int`数据类型的数字数组。下面的代码片段使用了重载的`max()`方法的所有三个定义:

```
int max1 = MathUtil.max(10, 23);                 // Uses max(int, int)
double max2 = MathUtil.max(10.34, 2.89);         // Uses max(double, double)
int max3 = MathUtil.max(new int[]{1, 89, 8, 3}); // Uses max(int[])

```

请注意，方法重载只提供了方法名的共享。它不会导致方法定义的共享。在清单 [1-7](#PC33) 中，方法名`max`被所有三个方法共享，但是它们都有自己的计算不同类型的最大值的定义。在方法重载中，方法的定义不必相关。他们可能做完全不同的事情，并分享相同的名字。

下面的代码片段展示了 Java 中运算符重载的一个例子。操作员是`+`。在下面的三条语句中，它执行三种不同的操作:

```
int n1 = 10 + 20;              // Adds two integers
double n2 = 10.20 + 2.18;      // Adds two floating-point numbers
String str = "Hi " + "there";  // Concatenates two strings

```

在第一条语句中，`+`运算符对两个整数`10`和`20`执行加法运算，并返回`30`。在第二条语句中，它对两个浮点数`10.20`和`2.18`进行加法运算，并返回`12.38`。在第三个语句中，它执行两个字符串“Hi”和“there”的连接，并返回`"Hi there"`。

在重载中，方法的实际参数的类型(在操作符的情况下是操作数的类型)用于确定使用哪个代码定义。方法重载只提供方法名的重用。只需为重载方法的所有版本提供一个唯一的名称，就可以移除方法重载。例如，您可以将`max()`方法的三个版本重命名为`max2Int()`、`max2Double()`和`maxNInt()`。请注意，重载方法或运算符的所有版本都不必执行相关或相似的任务。在 Java 中，重载方法名的唯一要求是，该方法的所有版本在形参的数量和/或类型上必须不同。

#### 强制多态性

强制是一种特殊的多态性。当一种类型自动隐式转换(强制)为另一种类型时，即使不是显式的，也会发生强制。考虑以下 Java 语句:

```
int num = 707;
double d1 = (double)num; // Explicit conversion of int to double
double d2 = num;         // Implicit conversion of int to double (coercion)

```

在第一条语句中，变量`num`被声明为`int`数据类型，并被赋值为`707`。第二个语句使用了一个造型`(double)`，将存储在`num`中的`int`值转换为`double`，并将转换后的值赋给一个名为`d1`的变量。这是从`int`到`double`的显式转换的情况。在这种情况下，程序员通过使用强制转换来明确他们的意图。第三个语句的效果和第二个完全一样；然而，它依赖于 Java 语言提供的隐式转换(在 Java 中称为扩大转换),该语言在需要时自动将`int`转换为`double`。第三个陈述是一个强迫的例子。编程语言(包括 Java)在不同的上下文中执行不同类型的强制:赋值(如前所示)、方法参数等。

考虑下面的代码片段，它显示了一个`square()`方法的定义，该方法接受一个`double`数据类型的参数:

```
double square(double num) {
    return num * num;
}

```

可以使用数据类型为`double`的实际参数调用`square()`方法，如下所示:

```
double d1 = 20.23;
double result = square(d1);

```

同样的`square()`方法也可以用`int`数据类型的实参调用，如下所示:

```
int k = 20;
double result = square(k);

```

您已经看到了`square()`方法对`double`和`int`数据类型的参数都有效，尽管您只根据`double`数据类型的形参定义了它一次。这正是多态的含义。在这种情况下，`square()`方法被称为关于`double`和`int`数据类型的多态方法。因此，`square()`方法表现出多态行为，即使编写代码的程序员并不打算这样做。因为 Java 语言提供的隐式类型转换(从`int`到`double`的强制),所以`square()`方法是多态的。这里有一个多态方法的更正式的定义:

> *假设 m 是一个声明 T 类型形参的方法，如果 S 是一个可以隐式转换为 T 的类型，则称方法 m 相对于 S 和 T 是多态的*

#### 包含多态性

包含是一种普遍的多态性。它也被称为*子类型(或子类)多态性*，因为它是使用子类型或子类实现的。这是面向对象编程语言支持的最常见的多态性类型。Java 支持。

当使用某个类型编写的一段代码适用于它的所有子类型时，就会出现包含多态性。根据子类型规则，属于子类型的值也属于父类型，这种类型的多态性是可能的。假设`T`是一个类型，`S1`、`S2`、`S3...`是`T`的子类型。属于`S1`、`S2`、`S3...`的一个值也属于`T`。这种子类型规则使得编写如下代码成为可能:

```
T t;
S1 s1;
S2 s2;
...
t = s1; // A value of type s1 can be assigned to a variable of type T
t = s2; // A value of type s2 can be assigned to a variable of type T

```

Java 使用继承支持包含多态性，继承是一种子类化机制。你可以在 Java 中使用一个类型的形参来定义一个方法，比如`Person`，这个方法可以在它的所有子类型上被调用，比如`Employee`、`Student`、`Customer`等等。假设你有一个方法`processDetails()`如下:

```
void processDetails(Person p) {
    /*
Write code using the formal parameter p, which is of type Person. The same code will work if an object of any of the subclass of Person is passed to this method.
    */
}

```

`processDetails()`方法声明了一个`Person`类型的形参。您可以定义任意数量的类，这些类是`Person`类的子类。这种方法适用于这样的子类。假设`Employee`和`Customer`是`Person`类的子类。您可以编写这样的代码:

```
Person p1 = create a Person object;
Employee e1 = create an Employee object;
Customer c1 = create a Customer object;
processDetails(p1); // Use the Person type
processDetails(e1); // Use the Employee type, which is a subclass of Person
processDetails(c1); // Use the Customer type, which is a subclass of Person

```

子类型规则的作用是超类型包含(因此得名 inclusion)属于其子类型的所有值。只有当一段代码可以处理无限多种类型时，它才被称为通用多态。在包含多态性的情况下，代码工作的类型数量是有限的，但却是无限的。约束条件是所有类型都必须是编写代码的那个类型的子类型。如果对一个类型可以有多少个子类型没有限制，那么子类型的数量是无限的(至少理论上是这样)。请注意，包含多态性不仅让您编写可重用的代码，还让您编写可扩展和灵活的代码。`processDetails()`方法作用于`Person`类的所有子类。它将继续为`Person`类的所有子类工作，这将在未来定义，没有任何修改。Java 使用其他机制，如方法覆盖和动态调度(也称为后期绑定)，以及子类化规则，使包含多态性更加有效和有用。

#### 参数多态性

参数化是一种普遍的多态性。它也被称为“真正的”多态性，因为它允许您编写适用于任何类型(相关或不相关)的真正的通用代码。有时，它也被称为*泛型*。在参数多态中，一段代码以一种可以在任何类型上工作的方式编写。对比参数多态性和包含多态性。在包含多态性中，代码是为一种类型编写的，它适用于它的所有子类型。这意味着代码在包含多态性中工作的所有类型都通过超类型-子类型关系相关联。然而，在参数多态性中，相同的代码适用于所有类型，这些类型不一定相关。参数多态性是通过在编写代码时使用类型变量来实现的，而不是使用任何特定的类型。type 变量假定代码需要为特定类型执行。从 Java 5 到泛型，Java 都支持参数多态性。Java 支持多态实体(例如，参数化类)以及使用参数多态的多态方法(参数化方法)。

在 Java 中，参数多态性是通过使用泛型来实现的。Java 中的所有集合类型都使用泛型。您可以使用泛型编写代码，如下所示:

```
/* Example #1 */
// Create a List of String
List<String> sList = new ArrayList<String>();
// Add two Strings to the List
sList.add("string 1");
sList.add("string 2");
// Get the first String from the List
String s1 = sList.get(0);
/* Example #2 */
// Create a List of Integer
List<Integer> iList = new ArrayList<Integer>();
// Add two Integers to the list
iList.add(10);
iList.add(20);
// Get the first Integer from the List
int k1 = iList.get(0);

```

这段代码使用一个`List`对象作为一个`String`类型的列表，使用一个`List`对象作为一个`Integer`类型的列表。使用泛型，您可以将一个`List`对象视为 Java 中任何类型的列表。注意在这些例子中使用了`<Xxx>`来指定您想要实例化的`List`对象的类型。

## 摘要

为计算机编写一组指令来完成一项任务被称为编程。这组指令被称为程序。存在不同类型的编程语言。它们在接近硬件可以理解的指令或范例方面有所不同。机器语言让你用 0 和 1 写程序，是最低级的编程语言。用机器语言编写的程序被称为机器码。汇编语言让你用助记符编写程序。用汇编语言编写的程序被称为汇编代码。后来，更高级的编程语言被开发出来，使用一种类似英语的语言。

实践中有几种类型的编程范例。编程范式是以特定方式观察和分析现实世界问题的思维帽。命令式、过程式、函数式和面向对象是软件开发中一些广泛使用的范例。Java 是一种支持过程式、函数式和面向对象编程范例的编程语言。

抽象、封装、继承和多态是面向对象范例的四大支柱。抽象是隐藏与程序用户无关的程序细节的过程。封装是将多个项目捆绑成一个实体的过程。继承是以分层方式排列类以建立父类型-子类型关系的过程。继承通过允许程序员根据一个同样适用于所有子类型的超类型来编写代码，从而提高了代码的可重用性。多态性是指一次编写一段可以在多种类型上操作的代码的方式。方法重载、方法覆盖、子类型和泛型是实现多态性的一些方法。

EXERCISES

以下所有问题的答案都可以在本章的不同部分找到。

1.  什么是编程，什么是程序？

2.  汇编程序和编译器有什么区别？

3.  什么是机器语言，用机器语言编写的程序由什么组成？

4.  什么是汇编语言，用汇编语言写的程序由什么组成？

5.  说出三种更高级的编程语言。

6.  基于编程语言(1GL、2GL 等)的产生。)，Java 和 SQL 属于什么类别？

7.  什么是编程范例？用例子描述过程的、功能的和面向对象的范例。

8.  说出面向对象编程的四个支柱，并用例子描述每个支柱。

9.  什么是“真正的”多态性，Java 是如何支持它的？

10.  什么是抽象数据类型？Java 如何支持抽象数据类型？