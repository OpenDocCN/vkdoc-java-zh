# 18.正则表达式

在本章中，您将学习:

*   如何创建正则表达式

*   如何在`String`类中使用方便的方法来执行基于正则表达式的查找和替换

*   如何使用`Pattern`类编译正则表达式

*   如何使用`Matcher`类来匹配一个正则表达式和一个输入字符串

*   如何在正则表达式中使用组

*   如何使用`Matcher`类执行高级查找和替换

本章中的所有示例程序都是清单 [18-1](#PC1) 中声明的`jdojo.regex`模块的成员。

```java
// module-info.java
module jdojo.regex {
    exports com.jdojo.regex;
}

Listing 18-1The Declaration of a jdojo.regex Module

```

## 什么是正则表达式？

*正则表达式*是描述字符序列中模式的一种方式。该模式可用于验证字符序列、搜索字符序列、用另一个字符序列替换匹配该模式的字符序列等。

先说个例子。假设你有一个字符串，它可能是一个电子邮件地址。如何确保字符串是有效的电子邮件地址格式？此时，您对电子邮件地址的存在不感兴趣。您只想验证它的格式。

您希望根据一些规则来验证字符串。例如，它必须包含一个`@`符号，该符号前面至少有一个字符，后面是域名。或者，您可以指定`@`符号之前的文本必须只包含字母、数字、下划线和连字符。域名必须包含一个点。您可能想要添加更多的验证。如果您只想检查字符串中的`@`字符，您可以通过调用`email.indexOf('@')`来完成，其中`email`是保存电子邮件地址的字符串的引用。如果要确保邮件字符串中只有一个`@`字符，就需要添加更多的逻辑。在这种情况下，您可能会有 20–50 行代码，甚至更多，这取决于您想要执行的验证的数量。

这就是正则表达式派上用场的地方。这将使您的电子邮件地址验证变得容易。只用一行代码就可以完成。听起来是不是好得不像真的？就在不久前，您被告知您可能最终会有 50 行代码。现在，您被告知只需一行代码就可以完成同样的任务。这是真的。它可以在一行代码中完成。在我们详细讨论如何做到这一点之前，让我们列出完成这项任务所需的步骤:

*   为了验证这些类型的字符串，您需要识别您正在寻找的模式。例如，在最简单的电子邮件地址验证形式中，字符串应该由一些文本(至少一个字符)加上一个`@`符号，后跟一些域名文本。让我们暂时忽略任何其他细节。

*   你需要一种方式来表达这种被认可的模式。正则表达式用于描述这种模式。

*   你需要一个程序来匹配输入字符串的模式。这样的程序也被称为正则表达式引擎。

假设您想测试一个字符串的形式是否为`X@X`，其中`X`是任意字符。弦乐`"a@a"`、`"b@f"`、`"3@h"`都是这种形式。你可以在这里观察到一种模式。模式是“一个字符后面跟着`@`，后面跟着另一个字符。”用 Java 怎么表达这种模式？

在这种情况下，字符串`".@."`将代表您的正则表达式。在`".@."`中，圆点有着特殊的含义。它们代表任何字符。所有在正则表达式中有特殊含义的字符都被称为元字符。我们将在下一节讨论元字符。`String`类包含一个`matches()`方法。它将一个正则表达式作为参数，如果整个字符串匹配正则表达式，则返回`true`。否则返回`false`。这个方法的特征是

```java
boolean matches(String regex)

```

清单 [18-2](#PC3) 包含了说明`String`类的`matches()`方法用法的完整代码。

```java
// RegexMatch.java
package com.jdojo.regex;
public class RegexMatch {
    public static void main(String[] args) {
        // Prepare a regular expression to represent a pattern
        String regex = ".@.";
        // Try matching many strings against the regular expression
        matchIt("a@k", regex);
        matchIt("webmaster@jdojo.com", regex);
        matchIt("r@j", regex);
        matchIt("a%N", regex);
        matchIt(".@.", regex);
    }
    public static void matchIt(String str, String regex) {
        // Test for pattern match
        boolean matched = str.matches(regex);
        System.out.printf("%s matched %s = %b%n", str, regex, matched);
    }
}

a@k matched .@. = true
webmaster@jdojo.com matched .@. = false
r@j matched .@. = true
a%N matched .@. = false
.@. matched .@. = true

Listing 18-2Matching a String Against a Pattern

```

需要注意的一些要点如下:

*   正则表达式`".@."`与`"webmaster@jdojo.com"`不匹配，因为点意味着只有一个字符，而`String.matches()`方法匹配正则表达式中的模式和整个字符串。注意，字符串`"webmaster@jdojo.com"`具有由`.@.`表示的模式；也就是一个字符后跟`@`和另一个字符。但是，模式匹配字符串的一部分，而不是整个字符串。`"webmaster@jdojo.com"`的`"r@j"`部分与该模式相匹配。我们给出了一些例子，在这些例子中，你可以在字符串中的任何地方匹配模式，而不是匹配整个字符串。

*   如果要匹配字符串中的点字符，需要对正则表达式中的点进行转义。正则表达式`".\\.."`将匹配任何三个字符的字符串，其中中间的字符是点字符。比如方法调用`"a.b".matches(".\\..")`会返回`true`；方法调用`"...".matches(".\\..")`将返回`true`；方法调用`"abc".matches(".\\..")`和`"aa.ca".matches(".\\..")`将返回`false`。

您也可以用另一个字符串替换匹配的字符串。`String`类有两种方法来进行匹配替换:

*   `String replaceAll(String regex, String replacementString)`

*   `String replaceFirst(String regex, String replacementString)`

`replaceAll()`方法用指定的`replacementString`替换与指定的`regex`表示的模式匹配的字符串。它返回替换后的新字符串。使用`replaceAll()`方法的一些例子如下:

```java
String regex = ".@.";
// newStr will contain "webmaste***dojo.com" String newStr = "webmaster@jdojo.com".replaceAll(regex,"***");
// newStr will contain "***"
newStr = "A@B".replaceAll(regex,"***");
// newStr will contain "***and***"
newStr = "A@BandH@G".replaceAll(regex,"***");
// newStr will contain "B%T" (same as the original string)
newStr = "B%T".replaceAll(regex,"***");

```

`replaceFirst()`方法用`replacementString`替换第一次出现的匹配。它返回替换后的新字符串。使用`replaceFirst()`方法的一些例子如下:

```java
String regex = ".@.";
// newStr will contain "webmaste***dojo.com"
String newStr = "webmaster@jdojo.com".replaceFirst(regex, "***");
// newStr will contain "***"
newStr = "A@B".replaceFirst(regex, "***");
// newStr will contain "***andH@G"
newStr = "A@BandH@G".replaceFirst(regex, "***");
// newStr will contain "B%T" (same as the original string)
newStr = "B%T".replaceFirst(regex, "***");

```

## 元字符

元字符是具有特殊含义的字符。它们用在正则表达式中。有时元字符没有任何特殊含义，它们被视为普通字符。根据使用它们的上下文，它们被视为普通字符或元字符。Java 中正则表达式支持的元字符如下:

*   `( (a left parenthesis)`

*   `) (a right parenthesis)`

*   `[ (a left bracket)`

*   `] (a right bracket)`

*   `{ (a left brace)`

*   `} (a right brace)`

*   `\ (a backslash)`

*   `^ (a caret)`

*   `$ (a dollar sign)`

*   `| (a vertical bar)`

*   `? (a question mark)`

*   `* (an asterisk)`

*   `+ (an addition sign)`

*   `. (a dot or period)`

*   `< (a less-than sign)`

*   `> (a greater-than sign)`

*   `- (a hyphen)`

*   `= (an equal to sign)`

*   `! (an exclamation mark)`

## 字符类

元字符`[`和`]`(左右括号)用于指定正则表达式中的字符类。字符类是一组字符。正则表达式引擎将尝试匹配集合中的一个字符。请注意，在 Java 中，字符类与类结构或类文件没有关系。角色类别`"[ABC]"`将匹配角色`A`、`B`或`C`。例如，字符串`"A@V"`、`"B@V"`和`"C@V"`将匹配正则表达式`"[ABC]@."`。然而，字符串`"H@V"`将不匹配正则表达式`"[ABC]@."`，因为`@`前面没有`A`、`B`或`C`。作为另一个例子，字符串`"man"`或`"men"`将匹配正则表达式`"m[ae]n"`。

当我们使用“匹配”这个词时，我们的意思是模式存在于一个字符串中。我们并不是说整个字符串都匹配这个模式。例如，`"WEB@JDOJO.COM"`匹配模式`"[ABC]@."`，因为`@`在`B.`之前，即使字符串包含三个`@`符号，字符串`"A@BAND@YEA@U"`也匹配模式`"[ABC]@."`两次。第二个`@`不是匹配的一部分，因为它的前面是`D`，而不是`A`、`B,`或`C`。

您还可以使用字符类指定字符范围。范围用连字符(`-`)表示。例如，正则表达式中的`"[A-Z]"`代表任意大写英文字母；`"[0-9]"`代表`0`和`9`之间的任意数字。如果在一个字符类的开头使用`^`，表示补语(意为不)。例如，`"[^ABC]"`表示除了`A`、`B,`和`C`以外的任何字符。字符类`"[^A-Z]"`代表除大写英文字母以外的任何字符。如果您在字符类中除了开头以外的任何地方使用`^`，它将失去其特殊含义(即补码的特殊含义)，并且它只匹配一个`^`字符。例如，`"[ABC^]"`将匹配`A`、`B`、`C`或`^`。

您也可以在一个字符类中包含两个或多个范围。例如，`"[a-zA-Z]"`匹配从`a`到`z`的任意字符，`A`到`Z. "[a-zA-Z0-9]"`匹配从`a`到`z`的任意字符(大写和小写)以及从`0`到`9`的任意数字。表 [18-1](#Tab1) 中列出了一些字符类别的例子。

表 18-1

字符类的示例

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

字符类

 | 

意义

 | 

种类

 |
| --- | --- | --- |
| `[abc]` | 人物`a`、`b,`或`c` | 简单字符类 |
| `[^xyz]` | 除了`x`、`y`和`z`之外的一个角色 | 补充还是否定 |
| `[a-p]` | 字符`a`到`p` | 范围 |
| `[a-cx-z]` | 字符`a`至`c`或`x`至`z`，包括`a`、`b`、`c`、`x`、`y`或`z` | 联盟 |
| `[0-9&&[4-8]]` | 两个范围的交集(`4`、`5`、`6`、`7`或`8`) | 交集 |
| `[a-z&&[^aeiou]]` | 所有小写字母减去元音。换句话说，一个小写字母，它不是元音。也就是全部小写辅音。 | 减法 |

### 预定义的字符类

表 [18-2](#Tab2) 中列出了一些常用的预定义字符类。

表 18-2

预定义正则表达式字符类的列表

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

预定义的字符类

 | 

意义

 |
| --- | --- |
| `. (a dot)` | 任何字符(可能与行终止符匹配，也可能不匹配)。更多细节请参考`java.util.regex.Pattern`类的 API 文档中的“行终止符”一节。 |
| `\d` | 一个数字。同`[0-9]`。 |
| `\D` | 一个非数字。同`[^0-9]`。 |
| `\s` | 空白字符。同`[ \t\n\x0B\f\r]`。该列表包括一个空格、一个制表符、一个新行、一个垂直制表符、一个换页符和一个回车符。 |
| `\S` | 非空白字符。同`[^\s]`。 |
| `\w` | 一个单词字符。同`[a-zA-Z_0-9]`。该列表包括小写字母、大写字母、下划线和十进制数字。 |
| `\W` | 非单词字符。同`[^\w]`。 |

如果您允许在电子邮件地址验证中使用所有的大写和小写字母、下划线和数字，那么只验证三个字符的电子邮件地址的正则表达式应该是`"\w@\w"`。现在，您在电子邮件地址验证过程中领先一步。不再只允许在电子邮件的第一部分使用`A`、`B`或`C`(用正则表达式`[ABC]@.`来表示)，现在你允许任何单词字符作为第一部分和第二部分。

## 正则表达式的更多功能

到目前为止，您只看到了使用正则表达式的`String`类的三个方法。包`java.util.regex`包含三个类来支持正则表达式的完整版本。这些类别如下:

*   模式

*   制榫机

*   PatternSyntaxException

一个`Pattern`保存正则表达式的编译形式。正则表达式的编译形式是其专用的内存表示形式，以促进更快的字符串匹配。

一个`Matcher`将待匹配的字符串与一个`Pattern,`相关联，并执行实际的匹配。

一个`PatternSyntaxException`代表一个格式错误的正则表达式中的错误。

### 编译正则表达式

一个`Pattern`保存正则表达式的编译形式。它是不可改变的。可以分享。它没有`public`构造函数。该类包含一个静态的`compile()`方法，该方法返回一个`Pattern`对象。`compile()`方法被重载:

*   `static Pattern compile(String regex)`

*   `static Pattern compile(String regex, int flags)`

以下代码片段将一个正则表达式编译成一个`Pattern`对象:

```java
// Prepare a regular expression
String regex = "[a-z]@.";
// Compile the regular expression into a Pattern object
Pattern p = Pattern.compile(regex);

```

第二个版本的`compile()`方法允许您指定修改模式匹配方式的标志。`flags`参数是一个位掩码。这些标志被定义为`Pattern`类中的`int`常量，如表 [18-3](#Tab3) 所列。

表 18-3

模式类中定义的标志列表

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

旗

 | 

描述

 |
| --- | --- |
| `Pattern.CANON_EQ` | 启用规范等效。如果设置了此标志，则只有当两个字符的完全规范分解匹配时，它们才匹配。 |
| `Pattern.CASE_INSENSITIVE` | 启用不区分大小写的匹配。此标志仅为 US-ASCII 字符集设置不区分大小写的匹配。对于 Unicode 字符集的不区分大小写匹配，`UNICODE_CASE`标志也应该与该标志一起设置。 |
| `Pattern.COMMENTS` | 允许模式中有空白和注释。当设置了这个标志时，空白被忽略，以#开头的嵌入注释被忽略，直到一行结束。 |
| `Pattern.DOTALL` | 启用 *dotall* 模式。默认情况下，表达式`.`(一个点)不匹配行终止符。设置此标志时，表达式匹配任何字符，包括行终止符。 |
| `Pattern.LITERAL` | 启用模式的文字解析。当设置了该标志时，正则表达式中的字符被按字面意思处理。也就是说，元字符和转义序列没有特殊的含义。`CASE_INSENSTIVE`和`UNICODE_CASE`标志在与此标志一起使用时保持其效果。 |
| `Pattern.MULTILINE` | 启用多线模式。默认情况下，表达式`^`和`$`匹配整个输入序列的开头和结尾。当该标志被设置时，它们分别在一个行结束符或输入序列结束符之后和之前匹配。 |
| `Pattern.UNICODE_CASE` | 启用支持 Unicode 的大小写折叠。当该标志与`CASE_INSENSITIVE`标志一起设置时，根据 Unicode 标准执行不区分大小写的匹配。 |
| `Pattern.UNICODE_CHARACTER_CLASS` | 启用预定义字符类和`POSIX`字符类的 Unicode 版本。设置该标志也具有设置`UNICODE_CASE`标志的效果。设置此标志时,(仅限 US-ASCII)预定义字符类和`POSIX`字符类符合 Unicode 技术标准#18: Unicode 正则表达式附录 C——兼容性属性。 |
| `Pattern.UNIX_LINES` | 启用`UNIX`线条模式。设置该标志时，只有`\n`字符被识别为行结束符。 |

下面的代码片段编译了一个设置了`CASE_INSENSTIVE`和`DOTALL`标志的正则表达式，因此匹配 US-ASCII 字符集时不区分大小写，表达式`.`(一个点)将匹配一个行结束符。例如，`"A@\n"`将由以下模式匹配:

```java
// Prepare a regular expression
String regex = "[a-z]@.";
// Compile the regular expression into a Pattern object with
// the CASE_INSENSITIVE and DOTALL flags
Pattern p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE | Pattern.DOTALL);

```

### 创建匹配器

通过解释保存在`Pattern`对象中的编译模式，`Matcher`类的一个实例用于对一系列字符执行匹配。它没有`public`构造函数。`Pattern`类的`matcher()`方法用于获取`Matcher`类的实例。该方法将模式要匹配的字符串作为参数。下面的代码片段显示了如何获得一个`Matcher`:

```java
// Create a Pattern object and compile it into a Pattern
String regex = "[a-z]@.";
Pattern p = Pattern.compile(regex);
// String to perform the match
String str = "abc@yahoo.com,123@cnn.com,ksharan@jdojo.com";
// Get a matcher object using Pattern object p for str
Matcher m = p.matcher(str);

```

此时，`Matcher`对象`m`已经将`Pattern`对象`p`中表示的模式与`str`中的字符序列相关联。它准备好开始匹配操作。通常，`Matcher`对象用于在字符序列中寻找匹配。比赛可能成功也可能失败。如果匹配成功，您可能有兴趣知道匹配的开始和结束位置以及匹配的文本。您可以查询一个`Matcher`对象来获得所有这些信息。

### 匹配模式

你需要使用`Matcher`的以下方法来对输入执行匹配:

*   `find()`法

*   `start()`法

*   `end()`法

*   `group()`法

`find()`方法用于在输入中寻找模式的匹配。如果查找成功，则返回`true`。否则，它返回`false`。对该方法的第一次调用从输入的开始处开始搜索模式。如果上一次对此方法的调用成功，则下一次对此方法的调用将在前一次匹配后开始搜索。通常，在一个`while`循环中调用`find()`方法来查找所有匹配。这是一个重载的方法。另一个版本的`find()`方法采用整数参数，这是开始查找匹配的偏移量。

`start()`方法返回前一个匹配的起始索引。通常，它在成功的`find()`方法调用之后使用。

`end()`方法返回匹配字符串中最后一个字符的索引加 1。因此，在成功调用`find()`方法之后，`end()`和`start()`方法返回的值之间的差值将给出匹配字符串的长度。使用`String`类的`substring()`方法，可以得到如下匹配的字符串:

```java
// Continued from previous fragment of code
if (m.find()) {
    // str is the string we are looking into
    String foundStr = str.substring(m.start(), m.end());
    System.out.println("Found string is:" + foundStr);
}

```

`group()`方法返回通过先前成功的`find()`方法调用找到的字符串。回想一下，您还可以通过使用匹配的开始和结束，使用`String`类的`substring()`方法来获取之前匹配的字符串。因此，前面的代码片段可以替换为以下代码:

```java
if (m.find()) {
    String foundStr = m.group();
    System.out.println("Found text is:" + foundStr);
}

```

清单 [18-3](#PC11) 说明了这些方法的使用。为了清楚起见，省略了对方法参数的验证。程序试图在不同的字符串中找到`"[abc]@."`模式。

```java
// PatternMatcher.java
package com.jdojo.regex;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
public class PatternMatcher {
    public static void main(String[] args) {
        String regex = "[abc]@.";
        String source = "cric@jdojo.com is a valid email address";
        PatternMatcher.findPattern(regex, source);
        source = "kelly@jdojo.com is invalid";
        PatternMatcher.findPattern(regex, source);
        source = "a@band@yea@u";
        PatternMatcher.findPattern(regex, source);
        source = "There is an @ sign here";
        PatternMatcher.findPattern(regex, source);
    }
    public static void findPattern(String regex, String source) {
        // Compile regex into a Pattern object
        Pattern p = Pattern.compile(regex);
        // Get a Matcher object
        Matcher m = p.matcher(source);
        // Print regex and source text
        System.out.println("\nRegex: " + regex);
        System.out.println("Text: " + source);
        // Perform find
        boolean found = false;
        while (m.find()) {
            System.out.printf("Matched Text: %s, Start: %s, End: %s%n",
                    m.group(), m.start(), m.end());
            // We found at least one match. Set the found flag to true
            found = true;
        }
        if (!found) {
            // We did not find any match
            System.out.println("No match found");
        }
    }
}
Regex: [abc]@.
Text: cric@jdojo.com is a valid email address
Matched Text: c@j, Start: 3, End: 6
Regex: [abc]@.
Text: kelly@jdojo.com is invalid
No match found
Regex: [abc]@.
Text: a@band@yea@u
Matched Text: a@b, Start: 0, End: 3
Matched Text: a@u, Start: 9, End: 12
Regex: [abc]@.
Text: There is an @ sign here
No match found

Listing 18-3Using Pattern and Matcher Classes

```

## 查询匹配

在上一节中，我们向您展示了如何查询一个`Matcher`来获得一个匹配的状态(或细节)。获得这些状态的方法有`start()`、`end()`、`group()`和`groupCount()`。匹配状态也可以表示为`MatchResult`的实例，它是一个接口。您可以使用`MatchResult`的以下方法来获取匹配状态:

*   `int end()`

*   `int end(int group)`

*   `String group()`

*   `String group(int group)`

*   `int groupCount()`

*   `int start()`

*   `int start(int group)`

如何获得`MatchResult`的实例？调用`Matcher`的`toMatchResult()`方法得到匹配状态的副本:

```java
Matcher m = /* get a matcher here */
while (m.find()) {
    MatchResult result = m.toMatchResult();
    // Use result here...
}

```

为什么要使用`MatchResult`而不是`Matcher`中的方法来获取匹配状态？原因有二:

*   `Matcher`的`toMatchResult()`返回匹配状态的副本，这意味着`Matcher`的匹配状态的任何后续变化都不会影响`MatchResult`。在匹配过程中，您可以将所有匹配状态收集到`MatchResult`的实例中，然后在程序中进行分析。

*   A `MatchResult`是不可变的。如果您有处理器来处理匹配，您可以安全地将`MatchResult`实例传递给那些处理器。传递`Matcher`是不安全的，因为处理器可能会意外修改`Matcher`，这将在无意中影响您的程序。

在`Matcher`类中有一些方法可以和`MatchResult`一起工作。我们将在本章后面介绍它们。现在，只要记住一个`MatchResult`包含一场比赛的细节的拷贝。

## 当心反斜线

当心在正则表达式中使用反斜杠。字符类`\w`(即反斜杠后跟一个`w`)代表一个单词字符。回想一下，反斜杠字符也被用作转义字符的一部分。因此，`\w`必须写成`\\w`作为字符串文字。您还可以使用反斜杠来消除元字符的特殊含义。例如，一个`[`标志着一个角色类的开始。匹配括号中数字的正则表达式是什么，例如，`[1]`、`[5]`等。？注意，正则表达式`[0-9]`将匹配任何数字。数字可以用括号括起来，也可以不括起来。你可以考虑用`[[0-9]]`。它不会给你任何错误；然而，它也不能完成这项工作。您也可以将一个字符类嵌入到另一个字符类中。比如可以写`[a-z[0-9]]`，和`[a-z0-9]`一样。在这种情况下，`[[0-9]]`中的第一个`[`应该被视为普通字符，而不是元字符。必须使用反斜杠作为`\[[0-9]\]`。要将这个正则表达式写成字符串文字，需要在双引号中使用两个反斜杠作为`"\\[[0-9]\\]]"`。

## 正则表达式中的量词

您还可以指定正则表达式中的字符与字符序列匹配的次数。如果您想匹配所有两位数的整数，那么您的正则表达式应该是`\d\d`，与`[0-9][0-9]`相同。匹配任意整数的正则表达式是什么？你无法用你目前所掌握的知识写出匹配任何整数的正则表达式。您需要能够使用正则表达式来表达“一位数或更多位数”的模式。量词的概念就来了。表 [18-4](#Tab4) 列出了量词及其含义。

表 18-4

量词及其意义

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

数量词

 | 

意义

 |
| --- | --- |
| `*` | 零次或多次 |
| `+` | 一次或多次 |
| `?` | 一次或根本没有 |
| `{m}` | 恰好`m`次 |
| `{m, }` | 至少`m`次 |
| `{m, n}` | 至少`m`次，但不超过`n`次 |

值得注意的是，量词必须跟在它指定数量的字符或字符类之后。匹配任何整数的正则表达式是`\d+`，它将匹配一个或多个数字。这种匹配整数的解法正确吗？不，不是的。假设你的文本是“这是包含 10 和 120 的文本 123”。如果您对这个字符串运行您的模式`\d+`，它将匹配 123、10 和 120。注意`123`不是作为整数使用的；相反，它是单词`text123`的一部分。如果你在文本中寻找整数，那么`text123`中的 123 肯定不是整数。您希望匹配文本中构成一个单词的所有整数。

需要是发明之母。现在，您需要指定只在单词边界上执行匹配，而不是在嵌入了整数的文本中。这对于从先前的结果中排除整数 123 是必要的。下一节讨论使用元字符来匹配边界。

根据您在本节中学到的知识，让我们来改进您的电子邮件地址验证。在一个电子邮件地址中，必须有且只有一个`@`符号。要指定一个且仅一个字符，您可以在正则表达式中使用该字符一次，尽管您可以使用`{1}`作为量词。例如，`X{1}`和`X`在正则表达式中的意思是一样的。你在这方面很好。然而，到目前为止，您的解决方案只支持在`@`符号前后有一个字符。实际上，电子邮件地址中的`@`符号前后可以有多个字符。您可以将验证电子邮件地址的模式指定为`\w+@\w+`，这意味着一个或多个单词字符、一个`@`符号和一个或多个单词字符。

## 匹配边界

到目前为止，您并不关心文本中模式匹配的位置。有时，您可能想知道匹配是否发生在行首。您可能对查找和替换特定的匹配感兴趣，只要该匹配是在单词中找到的，而不是作为任何单词的一部分。例如，您可能希望将字符串中的单词`apple`替换为单词`orange`。假设你的字符串是“我有一个苹果和五个菠萝”。当然，您不希望在这个字符串中用`orange`替换所有出现的`apple`。如果你这样做，你的新字符串将是“我有一个橘子和五个菠萝”。事实上，你希望新的字符串是“我有一个橘子和五个菠萝”。你想匹配单词`apple`作为一个独立的单词，而不是任何其他单词的一部分。

表 [18-5](#Tab5) 列出了所有可以在正则表达式中使用的边界匹配器。

表 18-5

正则表达式中的边界观察器列表

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

边界匹配器

 | 

意义

 |
| --- | --- |
| `^` | 一行的开始 |
| `$` | 一行的结尾 |
| `\b` | 单词边界 |
| `\B` | 非单词边界 |
| `\A` | 输入的开始 |
| `\G` | 上一场比赛的结束 |
| `\Z` | 输入的结尾，但最后一个终止符除外，如果有的话 |
| `\z` | 输入的结束 |

在 Java 中，一个单词字符由`[a-zA-Z_0-9]`定义。字边界是零宽度匹配，可以匹配以下内容:

*   在单词字符和非单词字符之间

*   字符串的开头和一个单词字符

*   一个单词字符和字符串的结尾

非单词边界也是零宽度匹配，它与单词边界相反。它与以下内容匹配:

*   空字符串

*   两个单词字符之间

*   两个非单词字符之间

*   在非单词字符和字符串的开头或结尾之间

匹配单词`apple`的正则表达式是`\bapple\b`，意思如下:单词边界、单词`apple`和单词边界。清单 [18-4](#PC13) 演示了如何使用正则表达式匹配单词边界。

```java
// MatchBoundary.java
package com.jdojo.regex;
public class MatchBoundary {
    public static void main(String[] args) {
        // Prepare regular expression. Use \\b to get \b inside the string literal.
        String regex = "\\bapple\\b";
        String replacementStr = "orange";
        String inputStr = "I have an apple and five pineapples";
        String newStr = inputStr.replaceAll(regex, replacementStr);
        System.out.printf("Regular Expression: %s%n", regex);
        System.out.printf("Input String: %s%n", inputStr);
        System.out.printf("Replacement String: %s%n", replacementStr);
        System.out.printf("New String: %s%n", newStr);
    }
}
Regular Expression: \bapple\b
Input String: I have an apple and five pineapples
Replacement String: orange
New String: I have an orange and five pineapples

Listing 18-4Matching a Word Boundary

```

有两个边界匹配器:`^`(一行的开始)和`\A`(输入的开始)。一个输入字符串可以由多行组成。在这种情况下，`\A`将匹配整个输入字符串的开头，而`^`将匹配输入中每一行的开头。例如，正则表达式`"^The"`将匹配一个`the`输入字符串，它位于任何一行的开头。

## 组和反向引用

您可以将多个字符作为一个组来使用，从而将它们视为一个单元。通过将一个或多个字符括在括号内，可以在正则表达式中创建组。`(ab)`、`ab(z)`、`ab(ab)(xyz)`和`(the((is)(is)))`是组的例子。正则表达式中的每个组都有一个组号。组号从 1 开始。`Matcher`类有一个方法`groupCount()`，该方法返回与`Matcher`实例相关的模式中的组数。有一个特殊的群体叫 0 组(零)。它是指整个正则表达式。`groupCount()`方法不报告组 0。

每个组是如何编号的？正则表达式中的每个左括号标记一个新组的开始。表 [18-6](#Tab6) 列出了正则表达式中组编号的一些例子。注意，我们还列出了所有正则表达式的组 0，尽管它没有被`Matcher`类的`groupCount()`方法报告。列表中的最后一个示例显示存在组 0，即使正则表达式中没有显式组。

表 18-6

正则表达式中的组示例

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

正则表达式:AB(XY)

 |
| --- |
| 由`Matcher`类的`groupCount()`方法报告的组数:1 |
| **组号** | **群组文本** |
| `0` | `AB(XY)` |
| `1` | `(XY)` |
| **正则表达式:(AB)(XY)** |
| 由`Matcher`类的`groupCount()`方法报告的组数:2 |
| **组号** | **群组文本** |
| `0` | `(AB)(XY)` |
| `1` | `(AB)` |
| `2` | `(XY)` |
| **正则表达式:((A)((X)(Y)))** |
| 由`Matcher`类的`groupCount()`方法报告的组数:`5` |
| **组号** | **群组文本** |
| `0` | `((A)((X)(Y)))` |
| `1` | `((A)((X)(Y)))` |
| `2` | `(A)` |
| `3` | `((X)(Y))` |
| `4` | `(X)` |
| `5` | `(Y)` |
| **正则表达式:ABXY** |
| 由`Matcher`类的`groupCount()`方法报告的组数:0 |
| **组号** | **群组文本** |
| `0` | `ABXY` |

您还可以在正则表达式中反向引用组号。假设您想要匹配以`"ab"`开头，然后是`"xy"`，最后是`"ab"`的文本。你可以写一个正则表达式为`"abxyab"`。您也可以通过形成一个包含`"ab"`的组并将其反向引用为`"(ab)xy\1"`来获得相同的结果。这里，`"\1"`指的是组 1，在这种情况下是`"(ab)"`。可以用`"\2"`指代组 2，`"\3"`指代组 3，以此类推。正则表达式`"(ab)xy\12"`会如何解释？您已经使用`"\12"`作为组反向参考。正则表达式引擎足够聪明，可以检测到它只包含`"(ab)xy\12"`中的一个组。它使用`"\1"`作为第 1 组的后向引用，第 1 组是`"(ab)",`，第 2 组是普通字符。因此，正则表达式`"(ab)xy\12"`与`"abxyab2"`相同。如果正则表达式有 12 个或更多组，正则表达式中的\12 将指第 12 个组。

还可以通过在正则表达式中使用组号来获取匹配文本的一部分。`Matcher`类中的`group()`方法被重载。你已经看到了没有参数的`group()`方法。该方法的另一个版本将组号作为参数，并返回该组匹配的文本。假设您在输入文本中嵌入了电话号码。所有电话号码都是一个单词，长度为十位数。前三个数字是区号。正则表达式`\b\d{10}\b`将匹配输入文本中的所有电话号码。然而，要获得前三位数字(区号)，您必须编写额外的代码。如果使用组构成正则表达式，则可以使用组号获得区号。将电话号码的前三个数字放在一个组中的正则表达式是`\b(\d{3})\d{7}\b`。如果`m`是对与该模式相关联的`Matcher`对象的引用，则在成功匹配后，`m.group(1)`将返回电话号码的前三位数字。您也可以使用`m.group(0)`来获取整个匹配的文本。清单 [18-5](#PC14) 展示了在正则表达式中使用组来获取电话号码的区号部分。注意`2339829`与模式不匹配，因为它只有 7 个数字，而使用的模式只查找 10 个数字的电话号码。

```java
// PhoneMatcher.java
package com.jdojo.regex;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
public class PhoneMatcher {
    public static void main(String[] args) {
        // Prepare a regular expression: A group of 3 digits followed by 7 digits.
        String regex = "\\b(\\d{3})\\d{7}\\b";
        // Compile the regular expression
        Pattern p = Pattern.compile(regex);
        String source = "3342449027, 2339829, and 6152534734";
        // Get the Matcher object
        Matcher m = p.matcher(source);
        // Start matching and display the found area codes
        while (m.find()) {
            String phone = m.group();
            String areaCode = m.group(1);
            System.out.printf("Phone: %s, Area Code: %s%n", phone, areaCode);
        }
    }
}
Phone: 3342449027, Area Code: 334
Phone: 6152534734, Area Code: 615

Listing 18-5Using Groups in Regular Expressions

```

组也用于格式化或用另一个字符串替换匹配的字符串。假设您想要将所有十位数的电话号码格式化为`(xxx)` xxx `-xxxx`，其中 x 表示一个数字。如您所见，电话号码分为三组:前三位、后三位和后四位。您需要使用三个组组成一个正则表达式，这样您就可以通过它们的组号来引用这三个匹配的组。正则表达式应该是`\b(\d{3})(\d{3})(\d{4})\b`。开头和结尾的`\b`表示您只对匹配单词边界的十位数感兴趣。以下代码片段说明了如何显示格式化的电话号码:

```java
// Prepare the regular expression
String regex = "\\b(\\d{3})(\\d{3})(\\d{4})\\b";
// Compile the regular expression
Pattern p = Pattern.compile(regex);
String source = "3342449027, 2339829, and 6152534734";
// Get Matcher object
Matcher m = p.matcher(source);
// Start match and display formatted phone numbers
while (m.find()) {
    System.out.printf("Phone: %s, Formatted Phone: (%s) %s-%s%n",
            m.group(), m.group(1), m.group(2), m.group(3));
}
Phone: 3342449027, Formatted Phone: (334) 244-9027
Phone: 6152534734, Formatted Phone: (615) 253-4734

```

您也可以用格式化的电话号码替换输入文本中的所有十位数电话号码。您已经学习了如何使用`String`类的`replaceAll()`方法用另一个文本替换匹配的文本。`Matcher`类也有一个`replaceAll()`方法，它完成同样的事情。在用格式化的电话号码替换电话号码时，您面临的问题是获取匹配电话号码的匹配部分。在这种情况下，替换文本也包含匹配的文本。您事先不知道什么文本与模式匹配。团体来拯救你。`$n`，其中`n`为组号，内部替换文本为组`n`的匹配文本。例如，`$1`指第一个匹配的组。用格式化的电话号码替换电话号码的替换文本将是`($1) $2-$3`。清单 [18-6](#PC16) 展示了在替换文本中引用组的技术。

```java
// MatchAndReplace.java
package com.jdojo.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class MatchAndReplace {
    public static void main(String[] args) {
        // Prepare the regular expression
        String regex = "\\b(\\d{3})(\\d{3})(\\d{4})\\b";
        String replacementText = "($1) $2-$3";
        String source = "3342449027, 2339829, and 6152534734";
        // Compile the regular expression
        Pattern p = Pattern.compile(regex);
        // Get Matcher object
        Matcher m = p.matcher(source);
        // Replace the phone numbers by formatted phone numbers
        String formattedSource = m.replaceAll(replacementText);
        System.out.printf("Text: %s%n", source );
        System.out.printf("Formatted Text: %s%n", formattedSource );
    }
}
Text: 3342449027, 2339829, and 6152534734
Formatted Text: (334) 244-9027, 2339829, and (615) 253-4734

Listing 18-6Back Referencing a Group in Replacement Text

```

您也可以通过使用`String`类获得相同的结果。你根本不需要使用`Pattern`和`Matcher`类。下面的代码片段说明了相同的概念，但是使用了`String`类。`String`类在内部使用`Pattern`和`Matcher`类来获得结果:

```java
// Prepare the regular expression
String regex = "\\b(\\d{3})(\\d{3})(\\d{4})\\b";
String replacementText = "($1) $2-$3";
String source = "3342449027, 2339829, and 6152534734";
// Use replaceAll() method of the String class
String formattedSource = source.replaceAll(regex, replacementText)

```

`Matcher`类包含以下`replaceAll()`和`replaceFirst()`方法:

*   字符串替换全部(字符串替换)

*   字符串 replaceAll(函数 <matchresult>replacer)</matchresult>

*   字符串替换优先(字符串替换)

*   字符串 replaceFirst(函数 <matchresult>replacer)</matchresult>

    **提示**`replaceAll(Function<MatchResult,String> replacer)`和`replaceFirst(Function<MatchResult,String> replacer)`方法被添加到 Java 9 的`Matcher`类中。

正如我们在本节中解释的那样，`replaceAll(String)`和`replaceFirst(String)`方法的工作原理与`String`类中同名的方法相同。其他版本以一个`Function<MatchResult,String>`作为参数。`Function`接受一个`MatchResult`并返回一个替换字符串。这些方法让您有机会使用您在`Function`中的逻辑来获得替换字符串。在执行查找和替换之前，这四种方法都首先重置匹配器。`Function<T,R>`是`java.util.function`包中的一个接口。我们将在第 20 章[中详细讨论`Function`接口。](20.html)

假设您想在一个输入字符串中查找十位数的电话号码，并且您想用区号 334 屏蔽所有的电话号码。比如一个电话号码是 3342449027，你想用`(***) ***-****`代替。您可以在`Matcher`类中使用新的`replaceAll()`方法来实现。清单 [18-7](#PC18) 包含完整的程序。

```java
// MaskAndFormat.java
package com.jdojo.regex;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class MaskAndFormat {
    public static void main(String[] args) {
        // Prepare the regular expression
        String regex = "\\b(\\d{3})(\\d{3})(\\d{4})\\b";
        String source = "3342449027, 2339829, and 6152534734";
        // Compile the regular expression
        Pattern p = Pattern.compile(regex);
        // Get Matcher object
        Matcher m = p.matcher(source);
        // Replace the phone numbers by formatted phone numbers
        String formattedSource = m.replaceAll(MaskAndFormat::mask);
        System.out.printf("Text: %s%n", source );
        System.out.printf("Formatted Text: %s%n", formattedSource );
    }
    private static String mask(MatchResult result) {
        String replacementText = "($1) $2-$3";
        String areaCode = result.group(1);
        if("334".equals(areaCode)) {
            replacementText = "(***) ***-****";
        }
        return replacementText;
    }
}
Text: 3342449027, 2339829, and 6152534734
Formatted Text: (***) ***-****, 2339829, and (615) 253-4734

Listing 18-7Using Logic to Mask or Format Phone Number Depending on the Area Code

```

注意以下语句在`main()`方法中的使用:

```java
String formattedSource = m.replaceAll(MaskAndFormat::mask);

```

`replaceAll()`方法的参数是`MaskAndFormat::mask`，它是对`MaskAndFormat`类的`mask()`静态方法的方法引用。当找到匹配时，`MatchResult`被传递给`mask()`方法，从该方法返回的字符串被用作替换文本。注意您如何在`mask()`方法中用区号 334 屏蔽了电话号码。所有其他区号都使用与上一示例中相同的替换文字。

## 使用命名组

在一个大的正则表达式中使用组号很麻烦。Java 也支持命名组。您可以使用组名做任何事情，就像您在上一节中使用组号所做的那样:

*   您可以命名一个组。

*   您可以使用名称支持引用组。

*   您可以在替换文本中引用组名。

*   您可以使用组名获得匹配的文本。

和前面一样，您需要使用一对括号来创建一个组。开始括号后面是一个`?`和一个放在尖括号中的组名。定义命名组的格式如下:

```java
(?<groupName>pattern)

```

群组名称必须仅由字母和数字组成:`a`到`z`、`A`到`Z`和`0`到`9`。组名必须以字母开头。以下是使用三个命名组的正则表达式的示例。组名为`areaCode`、`prefix`和`lineNumber`。正则表达式匹配一个十位数的电话号码:

```java
\b(?<areaCode>\d{3})(?<prefix>\d{3})(?<lineNumber>\d{4})\b

```

您可以使用`\k<groupName>`反向引用名为`groupName`的组。电话号码中的区号和前缀部分使用相同的模式。您可以将前面反向引用`areaCode`组的正则表达式重写如下:

```java
\b(?<areaCode>\d{3})\k<areaCode>(?<lineNumber>\d{4})\b

```

您可以在替换文本中引用一个命名组作为`${groupName}`。下面的代码片段显示了一个正则表达式，其中包含三个命名组以及使用它们的名称引用这三个组的替换文本:

```java
String regex = "\\b(?<areaCode>\\d{3})(?<prefix>\\d{3})(?<lineNumber>\\d{4})\\b";
String replacementText = "(${areaCode}) ${prefix}-${lineNumber}";

```

当您命名一个组时，该组仍然会获得一个组号，如前一节所述。即使一个组有名称，您仍然可以通过它的组号来引用它。前面的代码片段重写如下，其中第三个组已被命名为`lineNumber`，在替换文本中使用其组号`$3`进行引用:

```java
String regex = "\\b(?<areaCode>\\d{3})(?<prefix>\\d{3})(?<lineNumber>\\d{4})\\b";
String replacementText = "(${areaCode}) ${prefix}-$3";

```

匹配成功后，您可以使用`Matcher`类的`group(String groupName)`方法来获取该组的匹配文本。

清单 [18-8](#PC25) 展示了如何在正则表达式中使用组名，以及如何在替换文本中使用组名。

```java
// NamedGroups.java
package com.jdojo.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class NamedGroups {
    public static void main(String[] args) {
        // Prepare the regular expression
        String regex =
            "\\b(?<areaCode>\\d{3})(?<prefix>\\d{3})(?<lineNumber>\\d{4})\\b";
        // Reference first two groups by names and the third one as its number
        String replacementText = "(${areaCode}) ${prefix}-$3";
        String source = "3342449027, 2339829, and 6152534734";
        // Compile the regular expression
        Pattern p = Pattern.compile(regex);
        // Get Matcher object
        Matcher m = p.matcher(source);
        // Replace the phone numbers by formatted phone numbers
        String formattedSource = m.replaceAll(replacementText);
        System.out.printf("Text: %s%n", source);
        System.out.printf("Formatted Text: %s%n", formattedSource);
    }
}
Text: 3342449027, 2339829, and 6152534734
Formatted Text: (334) 244-9027, 2339829, and (615) 253-4734

Listing 18-8Using Named Groups in Regular Expressions

```

在使用`Matcher`类的`find()`方法成功匹配之后，您可以使用它的`start()`和`end()`方法来知道组的匹配边界。这些方法是重载的:

*   `int start()`

*   `int start(int groupNumber)`

*   `int start(String groupName)`

*   `int end()`

*   `int end(int groupNumber)`

*   `int end(String groupName)`

不带参数的方法返回前一个匹配的起点和终点。其他两组方法返回前一个匹配中一个组的开始和结束。下面的代码片段使用了前面的例子，在一个字符串中匹配一个十位数的电话号码。它打印每个成功匹配的每个组的开始:

```java
// Prepare the regular expression
String regex = "\\b(?<areaCode>\\d{3})(?<prefix>\\d{3})(?<lineNumber>\\d{4})\\b";
String source = "3342449027, 2339829, and 6152534734";
System.out.println("Source Text: " + source);
// Compile the regular expression
Pattern p = Pattern.compile(regex);
// Get Matcher object
Matcher m = p.matcher(source);
while(m.find()) {
    String matchedText = m.group();
    int start1 = m.start("areaCode");
    int start2 = m.start("prefix");
    int start3 = m.start("lineNumber");
    System.out.printf("Matched Text: %s", matchedText);
    System.out.printf(". Area code start: %d", start1);
    System.out.printf(", Prefix start: %d", start2);
    System.out.printf(", Line Number start: %d%n", start3);
}
Source Text: 3342449027, 2339829, and 6152534734
Matched Text: 3342449027\. Area code start: 0, Prefix start: 3, Line Number start: 6
Matched Text: 6152534734\. Area code start: 25, Prefix start: 28, Line Number start: 31

```

## 重置匹配器

如果您已经完成了对输入文本的模式匹配，并且想要再次从输入文本的开头重新开始匹配，那么您需要使用`Matcher`类的`reset()`方法。在调用了`reset()`方法之后，下一个匹配模式的调用将从输入文本的开头开始。`reset()`方法被重载。另一个版本允许您将不同的输入文本与模式相关联。如果模式保持不变，这两个版本的`reset()`方法允许您重用任何现有的`Matcher`类实例。通过避免重新创建一个新的`Matcher`对象来执行相同模式的匹配，这增强了程序的性能。

## 电子邮件验证的最终结论

您现在已经学习了正则表达式的主要部分。您已经准备好完成您的电子邮件地址验证示例。请注意，我们只验证电子邮件地址的格式，而不验证它是否指向有效的电子邮件收件箱。您的电子邮件地址将根据以下规则进行验证:

*   所有电子邮件地址都将采用`name@domain`的形式。

*   名称部分必须以字母数字字符(`a-z, A-Z, 0-9`)开头。

*   名称部分必须至少有一个字符。

*   名称部分可以包含任何字母数字字符(`a-z, A-Z, 0-9`)、下划线、连字符或点号。

*   域部分必须至少包含一个点。

*   域部分中的点的前后必须至少有一个字母数字字符。

*   您还应该能够使用组号来引用名称和域部分。这种验证表明，您将名称和域部分作为组放在正则表达式中。

以下正则表达式将根据这些规则匹配一个电子邮件地址。组 1 是名称部分，而组 2 是域部分:

```java
([a-zA-Z0-9]+[\\w\\-.]*)@([a-zA-Z0-9]+\\.[a-zA-Z0-9\\-.]+)

```

添加的验证越多，正则表达式就越复杂。鼓励读者为电子邮件地址添加更多的验证，并相应地修改前面的正则表达式。这个正则表达式允许域部分有两个连续的点。你会如何阻止？

## 使用正则表达式查找并替换

查找和替换是正则表达式支持的一种非常强大的技术。有时您可能需要找到一个模式，并根据它匹配的文本替换它；也就是说，基于一些条件来决定替换文本。Java 正则表达式设计者看到了这种需求，他们在`Matcher`类中包含了两个方法，让您可以完成这项任务:

*   `Matcher appendReplacement(StringBuffer sb, String replacement)`

*   `Matcher appendReplacement(StringBuilder sb, String replacement)`

*   `StringBuffer appendTail(StringBuffer sb)`

*   `StringBuffer appendTail(StringBuilder sb)`

    **提示**Java 9 中增加了与`StringBuilder`一起工作的`appendReplacement()`和`appendTail()`方法的版本。

考虑以下文本:

一列载有 125 名男女的火车正以每小时 100 英里的速度行驶。火车票价是每人 75 美元。”

您想要查找文本中的所有数字(例如，125、100 和 75)并替换它们，如下所示:

*   一百乘以一百

*   “> 100”改为“超过 100”

*   “不足一百”改为“不足一百”

替换后，该案文应为:

一辆载有 100 多名男女的火车正以每小时 100 英里的速度行驶。火车票价每人不到 100 美元。”

要完成这项任务，您需要找到文本中嵌入的所有数字，将找到的数字与 100 进行比较，并决定替换文本。使用文本编辑器查找和替换文本时也会出现这种情况。文本编辑器突出显示您正在搜索的单词，您输入一个新单词，文本编辑器会为您进行替换。您也可以使用这两种方法创建一个在文本编辑器中找到的查找/替换程序。通常，这些方法与`Matcher`类的`find()`方法一起使用。下面概述了使用这两种方法完成文本查找和替换的步骤:

1.  创建一个`Pattern`对象。

2.  创建一个`Matcher`对象。

3.  创建一个`StringBuffer/StringBuilder`对象来保存结果。

4.  在循环中使用`find()`方法来匹配模式。

5.  根据找到的匹配位置调用`appendReplacement()`和`appendTail()`方法。

让我们通过编译正则表达式来创建一个`Pattern`。因为您想要查找所有的数字，所以您的正则表达式应该是`\b\d+\b`。注意第一个和最后一个`\b`。他们指出你只对单词边界上的数字感兴趣:

```java
String regex = "\\b\\d+\\b"; Pattern p = Pattern.compile(regex);

```

通过将图案与文本相关联来创建一个`Matcher`:

```java
String text = "A train carrying 125 men and women was traveling" +
              " at the speed of 100 miles per hour. The train" +
              " fare was 75 dollars per person.";
Matcher m = p.matcher(text);

```

创建一个`StringBuilder`来保存新文本:

```java
StringBuilder sb = new StringBuilder();

```

开始在`Matcher`对象上使用`find()`方法来寻找匹配。当您第一次调用`find()`方法时，数字 125 将与模式匹配。此时，您希望根据匹配的文本准备替换文本，如下所示

```java
String replacementText = "";
// Get the matched text. Recall that group() method returns the whole matched text
String matchedText = m.group();
// Convert the text into integer for comparison
int num = Integer.parseInt(matchedText);
// Prepare the replacement text
if (num == 100) {
    replacementText = "a hundred";
} else if (num < 100) {
    replacementText = "less than a hundred";
} else {
    replacementText = "more than a hundred";
}

```

现在，您将在`Matcher`对象上调用`appendReplacement()`方法，传递一个空的`StringBuilder`和`replacementText`作为参数。在本例中，`replacementText`有一个字符串`"more than hundred"`，因为`find()`方法调用匹配数字 125:

```java
m.appendReplacement(sb, replacementText);

```

知道`appendReplacement()`方法调用做什么是很有趣的。它检查是否有先前的匹配。因为这是对`find()`方法的第一次调用，所以没有先前的匹配。对于第一次匹配，它从输入文本的开头开始追加文本，直到匹配文本之前的字符。在您的情况下，以下文本被附加到`StringBuilder`。此时，`StringBuilder`中的文字是

```java
"A train carrying "

```

现在，`appendReplacement()`方法将`replacementText`参数中的文本追加到`StringBuilder`中。这将把`StringBuilder`的内容改为

```java
"A train carrying more than a hundred"

```

`appendReplacement()`方法还做了一件事。它将追加位置(即`Matcher`对象的内部状态)设置为第一个匹配文本之后的字符位置。在您的情况下，追加位置将被设置为 125 后面的字符，这是 125 后面的空格字符的位置。这就完成了第一个查找和替换步骤。

您将再次调用`Matcher`对象的`find()`方法。它会找到模式，也就是另一个数，是 100。您将使用与第一次匹配后相同的过程来计算替换文本的值。这一次，`replacementText`将包含字符串`"a hundred"`。您调用`appendReplacement()`方法如下:

```java
m.appendReplacement(sb, replacementText);

```

同样，它检查是否有先前的匹配。由于这是对`find()`方法的第二次调用，它将找到一个先前的匹配，并将使用上一次`appendReplacement()`调用保存的追加位置作为起始位置。要追加的最后一个字符将是第二次匹配之前的字符。它还会将追加位置设置为数字 100 后面的字符位置。此时，`StringBuilder`包含以下文字:

```java
"A train carrying more than a hundred men and women was traveling at the speed of a hundred"

```

第三次调用`find()`方法时，它会找到数字 75，替换后的`StringBuilder`内容如下。追加位置将被设置到数字`75`后面的字符位置:

```java
"A train carrying more than a hundred men and women was traveling at the speed of a hundred miles per hour. The train fare was less than a hundred"

```

如果再次调用`find()`方法，它将找不到任何匹配。然而，`StringBuilder`不包含最后一个匹配之后的文本，也就是“`dollars per person."`”要追加最后一个匹配之后的文本，需要调用`appendTail()`方法。它从追加位置开始向`StringBuilder`追加文本，直到输入字符串结束。对此方法的调用

```java
m.appendTail(sb);

```

将`StringBuilder`修改成这样:

```java
"A train carrying more than a hundred men and women was traveling at the speed of a hundred miles per hour. The train fare was less than a hundred dollars per person."

```

如果您在第二次调用`appendReplacement()`方法之后调用了`appendTail()`方法，那么`StringBuilder`的内容会是什么？完整的程序如清单 [18-9](#PC40) 所示。

```java
// AdvancedFindReplace.java
package com.jdojo.regex;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
public class AdvancedFindReplace {
    public static void main(String[] args) {
        String regex = "\\b\\d+\\b";
        StringBuilder sb = new StringBuilder();
        String text = "A train carrying 125 men and women was traveling at"
                + " the speed of 100 miles per hour. "
                + "The train fare was 75 dollars per person.";
        Pattern p = Pattern.compile(regex);
        Matcher m = p.matcher(text);
        while (m.find()) {
            String matchedText = m.group();
            // Convert the text into an integer for comparing
            int num = Integer.parseInt(matchedText);
            // Prepare the replacement text
            String replacementText;
            if (num == 100) {
                replacementText = "a hundred";
            } else if (num < 100) {
                replacementText = "less than a hundred";
            } else {
                replacementText = "more than a hundred";
            }
            m.appendReplacement(sb, replacementText);
        }
        // Append the tail
        m.appendTail(sb);
        // Display the old and new text
        System.out.printf("Old Text: %s%n", text);
        System.out.printf("New Text: %s%n", sb.toString());
    }
}
Old Text: A train carrying 125 men and women was traveling at the speed of 100 miles per hour. The train fare was 75 dollars per person.
New Text: A train carrying more than a hundred men and women was traveling at the speed of a hundred miles per hour. The train fare was less than a hundred dollars per person.

Listing 18-9Find-and-Replace Using Regular Expressions and appendReplacement() and appendTail() Methods

```

## 匹配结果流

在`Matcher`类中有一个方法返回一个`MatchResult`流:

```java
Stream<MatchResult> results()

```

Streams API 是一个庞大的主题，我们在第 16 章[中简单提到过。它允许您对数据流应用过滤-映射-归约操作。我们给出了一个使用`results()`方法来完成对`Matcher`类的讨论的例子。如果您在理解本节中的示例时有困难，请在阅读完 Streams API 之后重新阅读本节。](16.html)

`results()`方法在一个元素属于`MatchResult`类型的流中返回匹配结果。您可以查询`MatchResult`获取比赛详情。`results()`方法不会重置匹配器。如果你想重用匹配器，不要忘记调用它的`reset()`方法来重置它到一个期望的位置。当您使用`results()`方法时，诸如计算匹配数、获取匹配列表和查找不同的区号等操作变得很容易。清单 [18-10](#PC42) 展示了这种方法的一些有趣的用法。它在输入字符串中搜索十位数或七位数的电话号码。它获取所有格式化的匹配电话号码的列表。在第二个示例中，它在匹配结果中打印一组不同的区号。

```java
// DistinctAreaCode.java
package com.jdojo.regex;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
public class DistinctAreaCode {
    public static void main(String[] args) {
        // A regex to match 7-digit or 10-digit phone numbers
        String regex = "\\b(\\d{3})?(\\d{3})(\\d{4})\\b";
        // An input string
        String source = "1, 3342229999, 2330001, 6159996666, 123, 3340909090";
        System.out.println("Input: " + source);
        // Create a matcher
        Matcher matcher = Pattern.compile(regex)
                .matcher(source);
        // Collect formatted phone numbers into a list
        List<String> phones = matcher.results()
                .map(mr -> (mr.group(1) == null ? "" : "(" + mr.group(1) + ") ")
                      + mr.group(2) + "-" + mr.group(3))
                .collect(toList());
        System.out.println("Phones: " + phones);
        // Reset the matcher, so we can reuse it from start
        matcher.reset();
        // Get distinct area codes
        Set<String> areaCodes = matcher.results()
                .filter(mr -> mr.group(1) != null)
                .map(mr -> mr.group(1))
                .collect(toSet());
        System.out.println("Distinct Area Codes: " + areaCodes);
    }
}
Input: 1, 3342229999, 2330001, 6159996666, 123, 3340909090
Phones: [(334) 222-9999, 233-0001, (615) 999-6666, (334) 090-9090]
Distinct Area Codes: [334, 615]

Listing 18-10Using the results() Method of the Matcher Class

```

在`main()`方法中，下面的正则表达式将匹配七位数或十位数的电话号码:

```java
// A regex to match 7-digit or 10-digit phone numbers
String regex = "\\b(\\d{3})?(\\d{3})(\\d{4})\\b";

```

您想将一个十位数的电话号码格式化为`(xxx) xxx-xxxx`，将一个七位数的电话号码格式化为`xxx-xxxx`。最后，您希望将所有格式化的电话号码收集到一个`List<String>`中。“Collect”是一个终端操作，它接受一个收集器作为参数；如示例所示，我们导入了两个方法，这两个方法提供了收集器 toList()和 toSet()。以下语句执行此操作:

```java
 // Collect formatted phone numbers into a list
 List<String> phones = matcher.results()
                        .map(mr -> (mr.group(1) == null ? "" : "(" + mr.group(1) + ") ")
                                    + mr.group(2) + "-" + mr.group(3))
                        .collect(toList());

```

请注意`map()`方法的使用，它接受一个`MatchResult`并返回一个格式化的电话号码作为一个`String`。当匹配的是一个七位数的电话号码时，组 1 将是`null`。现在，您希望重用匹配器来查找十位数电话号码中不同的区号。您必须重置匹配器，以便下一个匹配从输入字符串的开头开始:

```java
// Reset the matcher, so we can reuse it from start
matcher.reset();

```

`MatchResult`中的第一组包含区号。您需要过滤掉七位数的电话号码，并将 group 1 的值收集到一个`Set<String>`中，以获得一组不同的区号。下面的语句可以做到这一点:

```java
// Get distinct area codes
Set<String> areaCodes = matcher.results()
                               .filter(mr -> mr.group(1) != null)
                               .map(mr -> mr.group(1))
                               .collect(toSet());

```

## 摘要

正则表达式是用作匹配某些文本的模式的字符序列。Java 通过`java.util.regex`包中的`Pattern`和`Matcher`类提供了对使用正则表达式的全面支持。在`String`类中有几种使用正则表达式的方便方法。

一个`Pattern`对象代表一个编译过的正则表达式。一个`Matcher`对象用于将一个`Pattern`与一个输入文本相关联，以搜索模式。`Matcher`类的`find()`方法用于在输入文本中查找模式的匹配。正则表达式允许您使用组。群组会自动从 1 到 n 编号。从左起的第一个群组编号为 1。存在包含整个正则表达式的特殊组 0。您也可以给组命名。您可以通过编号或名称来引用组。

Java 9 给`Matcher`类增加了一些有用的方法。`replaceAll()`和`replaceFirst()`方法被重载；现在他们用一个`Function<MatchResult,String>`作为匹配结果的替换符，允许您使用任何逻辑来生成匹配的替换文本。`results()`方法返回一个`Stream<MatchResult>`，允许您将操作流式传输到匹配的结果。

QUESTIONS AND EXERCISES

1.  什么是正则表达式？

2.  什么是元字符？如何在正则表达式中将元字符作为普通字符使用？

3.  你用什么类来编译一个模式？

4.  你用什么类来匹配一个编译模式？

5.  正则表达式`"[aieou]"`是什么意思？会和字符串`"Hello"`匹配吗？

6.  编写一个正则表达式，它将匹配任何以小写辅音开头，后跟一个或多个小写元音，再后跟一个小写辅音的单词。例如，它应该匹配猫，狗，酷，小床，厄运，认为等。，但不是可乐，猫，鱼，冷等。

7.  以下代码片段的输出会是什么:

    ```java
    String source = "I saw the rat running.";
    String regex = "r..";
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(source);
    while(m.find()) {
        System.out.println(m.group());
    }

    ```

8.  完成下面的代码片段，它将匹配输入中的两个单词— `cat`和`cot`。当代码运行时，它应该在两行上打印出`cat`和`cot`:

    ```java
    String source = "cat camera can pen cow cab cot";
    String regex = /* Your code goes here */;
    Pattern p = Pattern.compile(regex);
    Matcher m = /* Your code goes here */;
    while(m.find()) {
        System.out.println(m.group());
    }

    ```

9.  完成下面的代码片段，将所有以`c`开头的三个字母的单词替换为大写字母。代码应该打印`"CAT camera CAN pen COW CAB COT"`。

    ```java
    String source = "cat camera can pen cow cab cot";
    String regex = "/* You code goes here*/";
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(source);
    String str = m.replaceAll(mr -> mr.group().toUpperCase());
    System.out.println(str);

    ```

10.  编写以下代码片段的输出:

    ```java
    String source = "ABXXXABB";
    String regex = "AB*";
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(source);
    String str = m.replaceAll("Hello");
    System.out.println(str);

    ```

11.  编写以下代码片段的输出:

    ```java
    String source = "ABXXXABB";
    String regex = "AB?";
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(source);
    String str = m.replaceAll("Hello");
    System.out.println(str);

    ```

12.  编写以下代码片段的输出:

    ```java
    String source = "ABXXXABB";
    String regex = "AB+";
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(source);
    String str = m.replaceAll("Hello");
    System.out.println(str);

    ```

13.  描述以下代码片段的意图并写出输出:

    ```java
    String source = "I have 25 cents and 400 books.";
    String regex = "\\b(\\d+)\\b";
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(source);
    int sum = m.results()
               .mapToInt(mr -> Integer.parseInt(mr.group()))
               .sum();
    System.out.println(sum);

    ```

14.  以下正则表达式中有多少个组:

    ```java
    String regex = "\\b((\\d{3})(\\d{3})(\\d{4}))|((\\d{3})(\\d{4}))\\b";

    ```

15.  完成以下代码片段，以 xxx-xxxx 和(xxx) xxx-xxxx 格式打印七位数和十位数的电话号码。输出应该是`"(334) 233-0908, 233-7656, 234, (617) 908-6547, unknown"` :

    ```java
    String source = "3342330908, 2337656, 234, 6179086547, unknown";
    String regex = "/* Your code goes here*/";
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(source);
    StringBuilder sb = new StringBuilder();
    while(m.find()) {
        String replacement =
            m.group(1) != null ? /* Your code goes here*/;
        m.appendReplacement(sb, replacement);
    }
    m.appendTail(sb);
    System.out.println(sb.toString());

    ```

16.  完成下面的代码片段，它将在单独的一行上打印源字符串中的每个单词:

    ```java
    String source = "bug dug jug mug tug";
    String regex = "/*your code goes here*/";
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(source);
    while(m.find()) {
       System.out.println(m.group());
    }

    ```

17.  下面的代码片段试图计算并打印问号(？)在输入字符串中。完成下面的代码片段，因此输出是`3` :

    ```java
    String source = "What? How? I do not know. Why?";
    String regex = "/* Your code goes here */";
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(source);
    long questionMarkCount = m.results().count();
    System.out.println(questionMarkCount);

    ```