# 七、使用文件

在本章中，我们将解释以下内容:

*   文本文件和二进制文件的区别
*   内部文件名和外部文件名的区别
*   如何写一个程序来比较两个文本文件
*   `try . . . catch`构造
*   如何对二进制文件进行输入/输出
*   如何使用记录的二进制文件
*   什么是随机存取文件
*   如何从随机存取文件中创建和检索记录
*   什么是索引文件
*   如何使用索引更新随机存取文件

7.1 Java 中的输入/输出

Java 有广泛的用于执行输入/输出的类。我们已经使用`System.in`和`System.out`分别从标准输入读取和写入标准输出。

例如，我们使用了以下代码从文件中读取数据:

```java
        Scanner in = new Scanner(new FileReader("input.txt"));
```

此外，我们还使用了以下代码将输出发送到文件中，`output.txt:`

```java
        PrintWriter out = new PrintWriter(new FileWriter("output.txt"));
```

我们处理过的文件都是*文本*文件(字符文件)。在本章中，我们将看到如何处理*二进制*文件。

7.2 文本和二进制文件 和

一个*文本*文件是组织成行的字符序列。从概念上讲，我们认为每行都以换行符结束。但是，根据主机环境的不同，可能会发生某些字符转换。例如，如果我们将换行符`\n`写到一个文件中，它可以被翻译成两个字符——一个回车符和一个换行符。

因此，书写的字符和存储在外部设备上的字符之间不一定一一对应。同样，文件中存储的字符数和读取的字符数之间也可能没有一一对应的关系。

一个*二进制*文件仅仅是一个字节序列，在输入或输出中没有*字符转换。因此，这里的*就是*读取或写入的内容与文件中存储的内容一一对应。*

除了可能的字符翻译之外，文本文件和二进制文件之间还有其他区别。为了说明，使用 2 个字节(16 位)存储一个`short`整数；数字`3371`被存储为`00001101 00101011`。

如果我们把这个数写到一个文本文件中，它将被写成字符 3，接着是字符 3，接着是字符 7，接着是字符 1，总共占用 4 个字节。另一方面，我们可以简单地将这两个字节按原样写入二进制文件。

尽管我们仍然可以把它们看作是两个“字符”的序列，但是它们包含的值可能不代表任何有效的字符。其实在这种情况下，两个字节的十进制值是`13`和`43`，解释为两个 ASCII 字符，分别是回车符(CR)和`+`。

另一种理解方式是，通常，文本文件中的每个字节都包含一个人类可读的字符，而二进制文件中的每个字节都包含一个任意的位模式。二进制文件对于将数据从其内部表示形式直接写入外部设备(通常是磁盘文件)非常重要。

标准的输入和输出被认为是文本文件。磁盘文件可以创建为文本文件或二进制文件。我们将很快看到如何做到这一点。

7.3 内部与外部文件名

使用计算机的通常方式是通过它的操作系统。我们通常使用文字处理器或文本文件编辑器来创建和编辑文件。当我们创建一个文件时，我们给它一个名字，当我们需要对这个文件做任何事情时，我们就使用这个名字。这是操作系统识别文件的名称。

我们将这种名称称为*外部*文件名。(术语*外部*在这里表示“Java 程序的外部”)当我们写程序时，我们可能想要指定，比如说，从文件中读取数据。该程序将需要使用一个文件名，但是，出于几个原因，这个名称不应该是一个外部文件名。以下是主要原因:

*   要读取的文件可能尚未创建。
*   如果外部名称与程序相关联，程序将只能读取具有该名称的文件。如果数据在一个不同名称的文件中，要么改变程序，要么重命名文件。
*   由于不同的操作系统有不同的文件命名规则，所以程序的可移植性较差。一个系统上的有效外部文件名在另一个系统上可能无效。
*   由于这些原因，Java 程序使用内部文件名——我们通常使用 in 作为输入，out 作为输出。例如，当我们编写以下代码时，我们将内部名称`in`与外部文件`input.txt`相关联:

```java
        Scanner in = new Scanner(new FileReader("input.txt"));
```

这是唯一提到外部文件名的语句。剩下的程序是用`in`来写的。当然，我们可以更灵活地这样写:

```java
        Scanner in = new Scanner(new FileReader(fileName));
```

当程序运行时，我们在`fileName`中提供文件名，如下所示:

```java
        System.out.printf("Enter file name: ");
        String fileName = kb.nextLine();  //Scanner kb = new Scanner(System.in);
```

这个例子也说明了如何在同一个程序中从键盘*和*读取数据和文件。例如，`kb.nextInt()`将读取在键盘上键入的整数，`in.nextInt()`将从文件`input.txt`中读取一个整数。

7.4 示例:比较两个文件

考虑比较两个文件的问题。逐行进行比较，直到发现不匹配或其中一个文件结束。程序 P7.1 展示了我们如何解决这个问题。

***[程序 P7.1](#_list1)***

```java
        import java.io.*;
        import java.util.*;
        public class CompareFiles {
           public static void main(String[] args) throws IOException {
              Scanner kb = new Scanner(System.in);

              System.out.printf("First file? ");
              String file1 = kb.nextLine();
              System.out.printf("Second file? ");
              String file2 = kb.nextLine();

              Scanner f1 = new Scanner(new FileReader(file1));
              Scanner f2 = new Scanner(new FileReader(file2));

              String line1 = "", line2 = "";
              int numMatch = 0;

              while (f1.hasNextLine() && f2.hasNextLine()) {
                 line1 = f1.nextLine();
                 line2 = f2.nextLine();
                 if (!line1.equals(line2)) break;
                 ++numMatch;
              }
              if (!f1.hasNextLine() && !f2.hasNextLine())
                 System.out.printf("\nThe files are identical\n");
              else if (!f1.hasNextLine())   //first file ends, but not the second
                 System.out.printf("\n%s, with %d lines, is a subset of %s\n",
                             file1, numMatch, file2);
              else if (!f2.hasNextLine())   //second file ends, but not the first
                 System.out.printf("\n%s, with %d lines, is a subset of %s\n",
                             file2, numMatch, file1);
              else { //mismatch found
                 System.out.printf("\nThe files differ at line %d\n", ++numMatch);
                 System.out.printf("The lines are \n%s\n and \n%s\n", line1, line2);
              }
              f1.close();
              f2.close();
           } //end main

        } //end class CompareFiles
```

该程序执行以下操作:

*   它提示输入要比较的文件的名称；如果任何文件不存在，将抛出一个`FileNotFoundException`。
*   它创建两个`Scanner`、`f1`和`f2`，每个文件一个。
*   它使用`hasNextLine`来检查一个文件是否有更多的行需要读取；如果是`true`，至少还有一行要读，如果是`false`，则已经到了文件的末尾。
*   变量`numMatch`计算匹配行的数量。读取每个文件中的一行。如果匹配，`1`加到`numMatch`上，读取另一对行。如果一个(或两个)文件结束，循环自然退出；如果出现不匹配，我们就`break`退出循环。

如果第一个文件包含以下内容:

```java
one and one are two
two and two are four
three and three are six
four and four are eight
five and five are ten
six and six are twelve
```

第二个文件包含以下内容:

```java
one and one are two
two and two are four
three and three are six
four and four are eight
this is the fifth line
six and six are twelve
```

该程序将打印以下内容:

```java
The files differ at line 5
The lines are
five and five are ten
 and
this is the fifth line
```

7.5`try . . . catch`构造

当程序试图读取数据时，可能会出现错误。设备可能有问题，我们可能试图读取超出文件结尾的内容，或者我们要求读取的文件可能根本不存在。同样，当我们试图将数据写入文件时，设备可能被锁定或不可用，或者我们可能没有写权限。在这种情况下，Java 会抛出 IO(输入/输出)异常”。

每当一个方法有可能触发一个 I/O 错误时，无论是通过执行某个 I/O 操作本身还是通过调用一个触发错误的方法，Java 都要求该方法声明这一点。一种方法是在方法头中使用`throws IOException`，如下所示:

```java
        public static void main(String[] args) throws IOException{
```

处理输入/输出错误的另一种方法是使用`try . . . catch`构造。假设一个程序包含以下语句:

```java
        Scanner in = new Scanner(new FileReader("input.txt"));
```

运行时，如果程序找不到名为`input.txt`的文件，它将停止运行，并显示“文件未找到异常”错误消息。我们可以通过以下方式避免这种情况:

```java
        try {
           Scanner in = new Scanner(new FileReader("input.txt"));
        }
        catch (IOException e) {
           System.out.printf("%s\n", e);
           System.out.printf("Correct the problem and try again\n");
           System.exit(1);
        }
```

`try`块由单词`try`后跟一个块组成(用大括号括起来的零个或多个语句)。Java 试图执行块中的语句。

`catch`部分由单词`catch`组成，后面是括号中的“异常类型”,再后面是一个块。在这个例子中，我们预计可能会抛出一个 I/O 异常，所以我们在`catch`之后使用`IOException e`。如果确实抛出了异常，则执行`catch`块中的语句。

在这个例子中，假设文件`input.txt`存在。`Scanner in…`语句将成功，程序将在的`catch`块后继续执行*语句。但是如果这个文件不存在或者不可用，那么这个异常将被抛出并被部分 T3 捕获。*

当这种情况发生时，执行`catch`块中的语句(如果有的话)。Java 允许我们将任何语句放在一个`catch`块中。在这种情况下，我们打印异常对象`e`的内容和一条消息，程序退出。在没有文件`input.txt`的情况下运行时，该代码打印如下内容:

```java
        java.io.FileNotFoundException: input.txt
        Correct the problem and try again
```

程序没有*有*退出。如果省略了`exit`语句，程序将简单地继续执行`catch`块之后的语句(如果有的话)。如果我们愿意，我们也可以调用另一个方法来继续执行。

继续这个例子，考虑以下情况:

```java
        try {
           Scanner in = new Scanner(new FileReader("input.txt"));
           n = in.nextInt();
        }
```

我们试图从文件中读取下一个整数。现在，很多事情都可能出错:文件可能不存在，文件中的下一项可能不是有效的整数，或者文件中可能没有“下一”项。这些将分别抛出“找不到文件”、“输入不匹配”和“没有这样的元素”异常。因为这些都是类`Exception`的子类，我们可以用下面的代码来捕捉它们:

```java
        catch (Exception e) {
           System.out.printf("%s\n", e);
           System.out.printf("Correct the problem and try again\n");
           System.exit(1);
        }
```

当文件为空时，此代码打印如下内容:

```java
        java.util.NoSuchElementException
        Correct the problem and try again
```

当文件包含数字`5.7`(非整数)时，它打印如下:

```java
        java.util.InputMismatchException
        Correct the problem and try again
```

如果有必要，Java 允许我们单独捕捉每个异常。我们可以根据需要拥有任意多的`catch`构造。在本例中，我们可以编写以下内容:

```java
        try {
           Scanner in = new Scanner(new FileReader("input.txt"));
           n = in.nextInt();
        }
        catch (FileNotFoundException e) {
           //code for file not found
        }
        catch (InputMismatchException e) {
           //code for “invalid integer” found
        }
        catch (NoSuchElementException e) {
           //code for “end of file” being reached
        }
```

有时候，`catch`子句的顺序很重要。假设我们希望将“文件未找到”与所有其他异常分开捕获。我们可能会忍不住这样写:

```java
        try {
           Scanner in = new Scanner(new FileReader("input.txt"));
           n = in.nextInt();
        }
        catch (Exception e) {
           //code for all exceptions (except “file not found”, presumably)
        }
        catch (FileNotFoundException e) {
           //code for file not found
        }
```

这段代码甚至无法编译！Java 到最后一个`catch`的时候会抱怨`FileNotFoundException`已经被抓了。这是因为`FileNotFoundException`是`Exception`的子类。要解决这个问题，我们必须将`catch (FileNotFoundException e)` *放在* `catch (Exception e)`之前。

通常，子类异常必须出现在包含类之前。

7.6 二进制文件的输入/输出

如前所述，二进制文件包含的数据形式与数据的内部表示形式完全一致。例如，如果一个`float`变量占用了 4 个字节的内存，那么将它写入一个二进制文件只需要制作这 4 个字节的精确副本。另一方面，将其写入文本文件导致其被转换为字符形式，并且所获得的字符被存储在文件中。

通常，二进制文件只能从程序内部创建，并且其内容只能由程序读取。例如，列出一个二进制文件只会产生“垃圾”，有时还会产生错误。比较一个文本文件，它可以通过输入来创建，其内容可以被人类列出和阅读。但是，二进制文件具有以下优点:

*   由于不需要进行数据转换，数据在二进制文件之间的传输速度比文本文件快得多；数据按原样读写。
*   数组和结构等数据类型的值可以写入二进制文件。对于文本文件，必须写入单独的元素。
*   存储在二进制文件中的数据通常比存储在文本文件中的数据占用更少的空间。例如，整数–25367(六个字符)在文本文件中占 6 个字节，但在二进制文件中只占 2 个字节。

7.6.1 `DataOutputStream`和`DataInputStream`

考虑从文本文件`num.txt`中读取整数，并将它们以内部形式写入(二进制)文件`num.bin`的问题。我们假设`num.txt`中的数字以`0`结束，并且`0`不会被写入二进制文件。这可以通过[程序 P7.2](#list2) 来完成。

***[程序 P7.2](#_list2)***

```java
     import java.io.*;
     import java.util.*;
     public class CreateBinaryFile {

        public static void main(String[] args) throws IOException {
           Scanner in = new Scanner(new FileReader("num.txt"));
           DataOutputStream out = new DataOutputStream(new FileOutputStream("num.bin"));
           int n = in.nextInt();
           while (n != 0) {
              out.writeInt(n);
              n = in.nextInt();
           }
           out.close();
           in.close();
        } //end main
     } //end class CreateBinaryFile
```

假设`num.txt`包含以下内容:

```java
        25 18 47 96 73 89 82 13 39 0
```

运行[程序 P7.2](#list2) 时，数字(除`0`外)将以其内部形式存储在文件`num.bin`中。

[程序 P7.2](#list2) 中的新语句是:

```java
        DataOutputStream out = new DataOutputStream(new FileOutputStream("num.bin"));
```

数据输出流允许程序将原始 Java 数据类型写入输出流。文件输出流是用于将数据写入文件的输出流。下面的构造函数创建一个连接到文件`num.bin`的输出流:

```java
        new FileOutputStream("num.bin")
```

下面是`DataOutputStream`类中的一些方法。所有方法都写入基础输出流，所有值都从高字节开始写入(即从最高有效字节到最低有效字节)。

```java
        void writeInt(int v)       //write an int
        void writeDouble(double v) //write a double value
        void writeChar(int v)      //write a char as a 2-byte value
        void writeChars(String s)  //write a string as a sequence of chars
        void writeFloat(float v)   //write a float value
        void writeLong(long v)     //write a long value
        void write(int b)          //write the low 8-bits of b
```

在[程序 P7.2](#list2) 中，`out.writeInt(n)`将整数`n`写入文件`num.bin`。如果你试图查看`num.bin`的内容，你看到的都是废话。只有程序可以读取并理解文件中的内容。

考虑一下[程序 P7.3](#list3) ，它从文件`num.bin`中读取数字并打印出来。

***[程序 P7.3](#_list3)***

```java
        import java.io.*;
        public class ReadBinaryFile {
           public static void main(String[] args) throws IOException {
              DataInputStream in = new DataInputStream(new FileInputStream("num.bin"));
              int amt = 0;
              try {
                 while (true) {
                    int n = in.readInt();
                    System.out.printf("%d ", n);
                    ++amt;
                 }
              }
              catch (IOException e) { }
              System.out.printf("\n\n%d numbers were read\n", amt);
           } //end main
        } //end class ReadBinaryFile
```

如果`num.bin`包含来自[程序 P7.2](#list2) 的输出，那么[程序 P7.3](#list3) 产生如下输出:

```java
25 18 47 96 73 89 82 13 39

9 numbers were read
```

[程序 P7.3](#list3) 中的新语句是:

```java
        DataInputStream in = new DataInputStream(new FileInputStream("num.bin"));
```

数据输入流允许程序从作为数据输出流创建的输入流中读取原始 Java 数据类型。文件输入流是用于从文件中读取数据的输入流。下面的构造函数创建一个连接到文件`num.bin`的输入流:

```java
        new FileInputStream("num.bin")
```

以下是`DataInputStream`类中的一些方法:

```java
        int readInt()       //read 4 input bytes and return an int value
        double readDouble() //read 8 input bytes and return a double value
        char readChar()     //read a char as a 2-byte value
        void readFully(byte[] b) //read bytes and store in b until b is full
        float readFloat()        //read 4 input bytes and return a float value
        long readLong()          //read 8 input bytes and return a long value
        int skipBytes(int n)     //attempts to skip n bytes of data;
                                 //returns the number actually skipped
```

一般来说，这些方法用于从`DataOutputStream`读取使用相应“写入”方法写入的数据。

注意使用`try . . . catch`来读取数字，直到到达文件结尾。回想一下，文件中没有“数据结束”值，因此我们无法对此进行测试。`while`语句将连续从文件中读取。当到达文件结尾时，抛出一个`EOFException`。这是`IOException`的子类，因此被捕获。

`catch`块是空的，所以那里什么也没有发生。控制转到下面的语句，该语句打印读取的数字量。

7.6.2 记录的二进制文件

在上一节中，我们创建并读取了一个整数的二进制文件。我们现在讨论如何处理记录的二进制文件，其中一个记录可以包含两个或更多的字段。

假设我们想存储汽车零件的信息。现在，我们假设每个零件记录有两个字段——一个`int`零件号和一个`double`价格。假设我们有一个文本文件`parts.txt`，包含以下格式的零件数据:

```java
        4250    12.95
        3000    17.50
        6699    49.99
        2270    19.25
        0
```

我们读取这些数据，并用[程序 P7.4](#list4) 创建一个二进制文件`parts.bin`。

***[程序 P7.4](#_list4)***

```java
     import java.io.*;
     import java.util.*;
     public class CreateBinaryFile1 {
        public static void main(String[] args) throws IOException {
           Scanner in = new Scanner(new FileReader("parts.txt"));
           DataOutputStream out = new DataOutputStream(new FileOutputStream("parts.bin"));
           int n = in.nextInt();
           while (n != 0) {
              out.writeInt(n);
              out.writeDouble(in.nextDouble());
              n = in.nextInt();
           }
           in.close(); out.close();
        } //end main
     } //end class CreateBinaryFile1
```

`parts.bin`中的每条记录正好是 12 个字节(4 代表`int` + 8 代表`double`)。在本例中，有 4 条记录，因此文件的长度正好是 48 字节。我们知道第一条记录从字节 0 开始，第二条从字节 12 开始，第三条从字节 24 开始，第四条从字节 36 开始。下一条记录将从字节 48 开始。

在这个场景中，我们可以很容易地计算出记录 *n* 将从哪里开始；它将从字节数(*n*–1)* 12 开始。

为了给后面的内容做准备，我们将使用下面的`Part`类重写[程序 P7.4](#list4) :

```java
        class Part {
           int partNum;
           double price;

           public Part(int pn, double pr) {
              partNum = pn;
              price = pr;
           }

           public void printPart() {
              System.out.printf("\nPart number: %s\n", partNum);
              System.out.printf("Price: $%3.2f\n", price);
           }
        } //end class Part
```

[程序 P7.5](#list5) 从文本文件`parts.txt`中读取数据并创建二进制文件`parts.bin`。

***[程序 P7.5](#_list5)***

```java
     import java.io.*;
     import java.util.*;
     public class CreateBinaryFile2 {
        static final int EndOfData = 0;

        public static void main(String[] args) throws IOException {
           Scanner in = new Scanner(new FileReader("parts.txt"));
           DataOutputStream fp = new DataOutputStream(new FileOutputStream("parts.bin"));

           Part part = getPartData(in);
           while (part != null) {
              writePartToFile(part, fp);
              part = getPartData(in);
           }

           in.close();
           fp.close();
        } //end main

        public static Part getPartData(Scanner in) {
           int pnum = in.nextInt();
           if (pnum == EndOfData) return null;
           return new Part(pnum, in.nextDouble());
        }

        public static void writePartToFile(Part part, DataOutputStream f) throws IOException {
           f.writeInt(part.partNum);
           f.writeDouble(part.price);
           part.printPart(); //print data on standard input
        } //end writePartToFile

     } //end class CreateBinaryFile2

     //class Part goes here
```

运行时，[程序 P7.5](#list5) 产生如下输出:

```java
Part number: 4250
Price: $12.95

Part number: 3000
Price: $17.50

Part number: 6699
Price: $49.99

Part number: 2270
Price: $19.25
```

创建文件后，我们可以用下面的代码读取下一个`Part`记录:

```java
        public static Part readPartFromFile(DataInputStream in) throws IOException {
           return new Part(in.readInt(), in.readDouble());
        } //end readPartFromFile
```

这假设以下声明:

```java
        DataInputStream in = new DataInputStream(new FileInputStream("parts.bin"));
```

7.7 随机访问文件

在正常操作模式下，数据项是按照存储顺序从文件中读取的。当一个文件被打开时，人们会想到一个位于文件开头的假想指针。当从文件中读取项目时，该指针会按照读取的字节数移动。在任何时候，该指针指示下一个读(或写)操作将在哪里发生。

通常，这个指针是通过读或写操作隐式移动的。然而，Java 提供了将指针显式移动到文件中任何位置的工具。如果我们希望能够以随机顺序读取数据，而不是顺序读取数据，这是很有用的。

例如，考虑前面创建的部件二进制文件。每条记录的长度为 12 字节。如果第一条记录从字节 0 开始，那么第*n*T2 第条记录将从字节 12 开始(*n*–1)。假设我们想读取第 10 条<sup>记录，而不必读取前 9 条。我们算出第 10 个<sup>记录从字节 108 开始。如果我们可以将文件指针定位在字节 108，那么我们就可以读取第 10 个<sup>记录。</sup></sup></sup>

在 Java 中，`RandomAccessFile`类提供了处理随机访问文件的方法。以下语句声明`parts.bin`将被视为随机访问文件；`rw`是文件模式，意思是“读/写”——我们将被允许从文件*中读取，*向其中写入。

```java
        RandomAccessFile fp = new RandomAccessFile("parts.bin", "rw");
```

如果我们想以只读模式打开文件，我们使用`r`而不是`rw`。

最初，文件指针是 0，意味着它位于字节 0。

当我们从文件中读取数据或向文件中写入数据时，指针值会发生变化。在部件示例中，在我们读取(或写入)第一条记录后，指针值将是 12。在我们读取(或写入)第 5 个<sup>个</sup>记录后，该值将是 60。不过，请注意，第 5 个<sup>记录从字节 48 开始。</sup>

在任何时候，`fp.getFilePointer()`返回指针的当前值。我们可以用`seek`将指针定位在文件中的任意字节。以下语句将指针定位在字节`n`处:

```java
        fp.seek(n); //n is an integer; can be as big as a long integer
```

例如，我们可以将第 10 条<sup>条</sup>记录读入一个`Part`变量，如下所示:

```java
        fp.seek(108);  //the 10`th`record starts at byte 108
        Part part = new Part(fp.readInt(), fp.readDouble());
```

一般来说，我们可以这样来阅读第 *n* <sup>th</sup> 记录:

```java
        fp.seek((n – 1) * 12);  //the n`th`record starts at byte (n – 1) * 12
        Part part = new Part(fp.readInt(), fp.readDouble());
```

我们注意到,`12`通常应该由一个符号常数代替，比如`PartRecordSize`。

我们现在通过使用更真实的零件记录来扩展零件示例。假设每个零件现在有四个字段:六个字符的零件号、名称、库存量和价格。以下是一些示例数据:

```java
        PKL070 Park-Lens 8 6.50
        BLJ375 Ball-Joint 12 11.95
        FLT015 Oil-Filter 23 7.95
        DKP080 Disc-Pads 16 9.99
        GSF555 Gas-Filter 9 4.50
        END
```

零件名被写成一个单词，因此可以用`Scanner`方法`next`读取。请注意，零件名称的长度并不相同。记住，为了使用随机存取文件，所有的*记录*必须具有相同的长度——这样我们可以计算出记录在文件中的位置。那么，如果零件名长度不同，我们如何创建零件记录的随机存取文件呢？

诀窍是使用相同的固定存储量来存储每个名称。例如，我们可以用 20 个字符存储每个名字。如果一个名字短于 20，我们用空格填充它来组成 20。如果它更长，我们将其截断为 20。但是，最好使用能够容纳最长名称的长度。

如果我们用 20 个字符存储一个名称，零件记录的大小是多少？在 Java 中，每个字符存储在 2 个字节中。因此，零件号(6 个字符)将占用 12 个字节，名称将占用 40 个字节，库存数量(整数)将占用 4 个字节，价格(双精度)将需要 8 个字节。这为每个记录提供了总共 64 个字节。

我们如下编写`Part`类:

```java
        class Part {
           String partNum, name;
           int amtInStock;
           double price;

           public Part(String pn, String n, int a, double p) {
              partNum = pn;
              name = n;
              amtInStock = a;
              price = p;
           }

           public void printPart() {
              System.out.printf("Part number: %s\n", partNum);
              System.out.printf("Part name: %s\n", name);
              System.out.printf("Amount in stock: %d\n", amtInStock);
              System.out.printf("Price: $%3.2f\n", price);
           }

        } //end class Part
```

如果`EndOfData`的值为`END`，我们可以从零件文件中读取数据，假设它是以前的样本数据格式，如下所示:

```java
        public static Part getPartData(Scanner in) {
           String pnum = in.next();
           if (pnum.equals(EndOfData)) return null;
           return new Part(pnum, in.next(), in.nextInt(), in.nextDouble());
        }
```

如果没有更多的数据，该方法返回`null`。否则，它返回一个包含下一部分数据的`Part`对象。

如果`StringFixedLength`表示存储零件名称的字符数，我们可以将名称写入文件`f`，如下所示:

```java
        int n = Math.min(part.name.length(), StringFixedLength);
        for (int h = 0; h < n; h++) f.writeChar(part.name.charAt(h));
        for (int h = n; h < StringFixedLength; h++) f.writeChar(' ');
```

如果`n`表示名称的实际长度和`StringFixedLength`中较小的一个，我们首先将`n`字符写入文件。第二个`for`语句将空白写入文件，以补足所需的数量。注意，如果`StringFixedLength`比名字短，那么最后一个`for`不会写多余的空格。

要从文件中读取名称，我们将使用以下代码:

```java
        char[] name = new char[StringFixedLength];
        for (int h = 0; h < StringFixedLength; h++) name[h] = f.readChar();
        String hold = new String(name, 0, StringFixedLength);
```

这正好将文件中的`StringFixedLength`个字符读入一个数组。这然后被转换成一个`String`并存储在`hold`中；`hold.trim()`将删除尾随空格，如果有的话。我们将使用`hold.trim()`来创建`Part`对象 read。

[程序 P7.6](#list6) 从文本文件`parts.txt`中读取数据，并创建随机存取文件`parts.bin`。

***[程序 P7.6](#_list6)***

```java
   import java.io.*;
   import java.util.*;
   public class CreateRandomAccess {
      static final int StringFixedLength = 20;
      static final int PartNumSize = 6;
      static final int PartRecordSize = 64;
      static final String EndOfData = "END";

      public static void main(String[] args) throws IOException {
         Scanner in = new Scanner(new FileReader("parts.txt"));
         RandomAccessFile fp = new RandomAccessFile("parts.bin", "rw");
         Part part = getPartData(in);
         while (part != null) {
            writePartToFile(part, fp);
            part = getPartData(in);
         }
      } //end main

      public static Part getPartData(Scanner in) {
         String pnum = in.next();
         if (pnum.equals(EndOfData)) return null;
         return new Part(pnum, in.next(), in.nextInt(), in.nextDouble());
      } //end getPartData

      public static void writePartToFile(Part part, RandomAccessFile f) throws IOException {
         System.out.printf("%s %-11s %2d %5.2f %3d\n", part.partNum, part.name,
                                    part.amtInStock, part.price, f.getFilePointer());
         for (int h = 0; h < PartNumSize; h++) f.writeChar(part.partNum.charAt(h));
         int n = Math.min(part.name.length(), StringFixedLength);
         for (int h = 0; h < n; h++) f.writeChar(part.name.charAt(h));
         for (int h = n; h < StringFixedLength; h++) f.writeChar(' ');
         f.writeInt(part.amtInStock);
         f.writeDouble(part.price);
      } //end writePartToFile
   } //end class CreateRandomAccess

   //class Part goes here
```

当使用包含先前样本数据的`parts.txt`运行时，[程序 P7.6](#list6) 打印如下:

```java
PKL070 Park-Lens    8  6.50   0
BLJ375 Ball-Joint  12 11.95  64
FLT015 Oil-Filter  23  7.95 128
DKP080 Disc-Pads   16  9.99 192
GSF555 Gas-Filter   9  4.50 256
```

每行的最后一个值是文件指针；这是存储记录的字节位置。使用格式规范`%-11s`在字段宽度`11`中左对齐打印零件名称(`-`表示左对齐)。

我们现在编写[程序 P7.7](#list7) 来测试文件是否被正确存储。它提示用户输入记录号，并打印相应的零件记录。

***[程序 P7.7](#_list7)***

```java
    import java.io.*;
    import java.util.*;
    public class ReadRandomAccess {
       static final int StringFixedLength = 20;
       static final int PartNumSize = 6;
       static final int PartRecordSize = 64;

       public static void main(String[] args) throws IOException {
          RandomAccessFile fp = new RandomAccessFile("parts.bin", "rw");
          Scanner kb = new Scanner(System.in);
          System.out.printf("\nEnter a record number: ");
          int n = kb.nextInt();
          while (n != 0) {
             fp.seek(PartRecordSize * (n - 1));
             readPartFromFile(fp).printPart();
             System.out.printf("\nEnter a record number: ");
             n = kb.nextInt();
          }
       } //end main

       public static Part readPartFromFile(RandomAccessFile f) throws IOException {
          String pname = "";
          for (int h = 0; h < PartNumSize; h++) pname += f.readChar();
          char[] name = new char[StringFixedLength];
          for (int h = 0; h < StringFixedLength; h++) name[h] = f.readChar();
          String hold = new String(name, 0, StringFixedLength);
          return new Part(pname, hold.trim(), f.readInt(), f.readDouble());
       } //end readPartFromFile
    } //end class ReadRandomAccess

    // class Part goes here
```

以下是[程序 P7.7](#list7) 的运行示例:

```java
Enter a record number: 3
Part number: FLT015
Part name: Oil-Filter
Amount in stock: 23
Price: $7.95

Enter a record number: 1
Part number: PKL070
Part name: Park-Lens
Amount in stock: 8
Price: $6.50

Enter a record number: 4
Part number: DKP080
Part name: Disc-Pads
Amount in stock: 16
Price: $9.99
Enter a record number: 0
```

7.8 索引文件

上一节展示了如何在给定记录号的情况下检索零件记录。但是这不是检索记录的最自然的方式。更有可能的是，我们希望基于某个*键*来检索记录，在本例中，是部件号。更自然的问题是，“我们有多少 BLJ375？”而不是“我们有多少记录 2？”接下来的问题是如何在给定零件号的情况下检索记录。

一种方法是使用索引。就像书籍索引让我们快速找到书中的信息一样，文件索引让我们快速找到文件中的记录。加载文件时会创建索引。以后，当记录被添加到文件中或从文件中删除时，它必须被更新。在我们的例子中，一个索引条目将由一个零件号和一个记录号组成。

我们将使用下面的类来创建索引:

```java
        class Index {
           String partNum;
           int recNum;

           public Index(String p, int r) {
              partNum = p;
              recNum = r;
           }
        } //end class Index
```

我们将使用`MaxRecords`来表示我们将满足的最大记录数。我们声明一个数组`index`，如下所示:

```java
        Index[] index = new Index[MaxRecords + 1];
```

我们将使用`index[0].recNum`来保存`numRecords`，即文件中存储的记录数。索引条目将存储在`index[1]`到`index[numRecords]`中。

索引将按零件号有序保存。我们希望为以下记录创建索引:

```java
        PKL070 Park-Lens    8  6.50
        BLJ375 Ball-Joint  12 11.95
        FLT015 Oil-Filter  23  7.95
        DKP080 Disc-Pads   16  9.99
        GSF555 Gas-Filter   9  4.50
```

我们假设记录按照给定的顺序存储在文件中。当读取并存储第一条记录时，索引将包含以下内容:

```java
        PKL070   1
```

这意味着`PKL070`的记录是零件文件中的记录号 1。在第二个记录(`BLJ375`)被读取和存储后，索引将是这样的:

```java
        BLJ375   2
        PKL070   1
```

请记住，我们是按照零件号来保存索引的。在第三个记录(`FLT015`)被读取和存储后，索引将是这样的:

```java
        BLJ375   2
        FLT015   3
        PKL070   1
```

在第四个记录(`DKP080`)被读取和存储后，索引将是这样的:

```java
        BLJ375   2
        DKP080   4
        FLT015   3
        PKL070   1
```

最后，在第五个记录(`GSF555`)被读取和存储之后，索引将是这样的:

```java
        BLJ375   2
        DKP080   4
        FLT015   3
        GSF555   5
        PKL070   1
```

[程序 P7.8](#list8) 说明了如何按照描述创建索引。

***[程序 P7.8](#_list8)***

```java
   import java.io.*;
   import java.util.*;
   public class CreateIndex {
      static final int StringFixedLength = 20;
      static final int PartNumSize = 6;
      static final int PartRecordSize = 64;
      static final int MaxRecords = 100;
      static final String EndOfData = "END";

      public static void main(String[] args) throws IOException {
         RandomAccessFile fp = new RandomAccessFile("parts.bin", "rw");
         Index[] index = new Index[MaxRecords + 1];

         createMasterIndex(index, fp);
         saveIndex(index);
         printIndex(index);
         fp.close();
      } //end main

      public static void createMasterIndex(Index[] index,
                               RandomAccessFile f) throws IOException {
         Scanner in = new Scanner(new FileReader("parts.txt"));
         int numRecords = 0;
         Part part = getPartData(in);
         while (part != null) {
            int searchResult = search(part.partNum, index, numRecords);
            if (searchResult > 0)
               System.out.printf("Duplicate part: %s ignored\n", part.partNum);
            else { //this is a new part number; insert in location -searchResult
               if (numRecords == MaxRecords) {
                  System.out.printf("Too many records: only %d allowed\n", MaxRecords);
                  System.exit(1);
               }
               //the index has room; shift entries to accommodate new part
               for (int h = numRecords; h >= -searchResult; h--)
                     index[h + 1] = index[h];
               index[-searchResult] = new Index(part.partNum, ++numRecords);
               writePartToFile(part, f);
            }
            part = getPartData(in);
         } //end while
         index[0] = new Index("NOPART", numRecords);
         in.close();
      } //end createMasterIndex

      public static Part getPartData(Scanner in) {
         String pnum = in.next();
         if (pnum.equals(EndOfData)) return null;
         return new Part(pnum, in.next(), in.nextInt(), in.nextDouble());
      } //end getPartData

      public static void writePartToFile(Part part, RandomAccessFile f) throws IOException {
         for (int h = 0; h < PartNumSize; h++) f.writeChar(part.partNum.charAt(h));
         int n = Math.min(part.name.length(), StringFixedLength);
         for (int h = 0; h < n; h++) f.writeChar(part.name.charAt(h));
         for (int h = n; h < StringFixedLength; h++) f.writeChar(' ');
         f.writeInt(part.amtInStock);
         f.writeDouble(part.price);
      } //end writePartToFile

      public static void saveIndex(Index[] index) throws IOException {
         RandomAccessFile f = new RandomAccessFile("index.bin", "rw");
         int numRecords = index[0].recNum;
         //fill the unused index positions with dummy entries
         for (int h = numRecords+1; h <= MaxRecords; h++)
            index[h] = new Index("NOPART", 0);
         f.writeInt(MaxRecords);
         for (int h = 0; h <= MaxRecords; h++) {
            for (int i = 0; i < PartNumSize; i++)
                  f.writeChar(index[h].partNum.charAt(i));
            f.writeInt(index[h].recNum);
         }
         f.close();
      } //end saveIndex

      public static int search(String key, Index[] list, int n) {
      //searches list[1..n] for key. If found, it returns the location; otherwise
      //it returns the negative of the location in which key should be inserted.
         int lo = 1, hi = n;
         while (lo <= hi) {   // as long as more elements remain to consider
            int mid = (lo + hi) / 2;
            int cmp = key.compareToIgnoreCase(list[mid].partNum);
            if (cmp == 0) return mid;  // search succeeds
            if (cmp < 0) hi = mid - 1;   // key is 'less than' list[mid].partNum
            else lo = mid + 1;     // key is 'greater than' list[mid].partNum
         }
         return -lo;         // key not found; insert in location lo
      } // end search

      public static void printIndex(Index[] index) {
         System.out.printf("\nThe index is as follows: \n\n");
         int numRecords = index[0].recNum;
         for (int h = 1; h <= numRecords; h++)
            System.out.printf("%s %2d\n", index[h].partNum, index[h].recNum);
      } //end printIndex

   } //end class CreateIndex

   class Part {
      String partNum, name;
      int amtInStock;
      double price;

      public Part(String pn, String n, int a, double p) {
         partNum = pn;
         name = n;
         amtInStock = a;
         price = p;
      }

      public void printPart() {
         System.out.printf("Part number: %s\n", partNum);
         System.out.printf("Part name: %s\n", name);
         System.out.printf("Amount in stock: %d\n", amtInStock);
         System.out.printf("Price: $%3.2f\n", price);
      }
   } //end class Part

   class Index {
      String partNum;
      int recNum;

      public Index(String p, int r) {
         partNum = p;
         recNum = r;
      }
   } //end class Index
```

当读取零件号时，我们在索引中查找它。因为索引是按零件号排序的，所以我们使用二分搜索法来搜索它。如果零件号存在，则意味着该零件已经被存储，因此该记录被忽略。如果它不存在，这是一个新零件，所以它的记录存储在零件文件`parts.bin`中，假设我们还没有存储`MaxRecords`记录。

(在`numRecords`中)记录读取的记录数。然后将零件号和记录号插入到`index`数组的适当位置。

当所有记录都被存储后，索引被保存在另一个文件`index.bin`中。在保存之前，`index`(`index[numRecords]`之后的条目)的未使用部分被填充了虚拟记录。`MaxRecords`的值是发送到文件的第一个值。接下来是`index[0]`到`index[MaxRecords]`。记住`index[0].recNum`包含了`numRecords`的值。

假设`parts.txt`包含以下内容:

```java
        PKL070 Park-Lens 8 6.50
        BLJ375 Ball-Joint 12 11.95
        PKL070 Park-Lens 8 6.50
        FLT015 Oil-Filter 23 7.95
        DKP080 Disc-Pads 16 9.99
        GSF555 Gas-Filter 9 4.50
        FLT015 Oil-Filter 23 7.95
        END
```

当[程序 P7.8](#list8) 运行时，打印如下:

```java
Duplicate part: PKL070 ignored
Duplicate part: FLT015 ignored

The index is as follows:

BLJ375  2
DKP080  4
FLT015  3
GSF555  5
PKL070  1
```

接下来，我们编写一个程序，通过首先从文件中读取索引来测试我们的索引。然后要求用户输入零件号，一次一个。对于每个零件，它会在索引中搜索零件号。如果找到，索引条目将指示零件文件中的记录号。使用记录号，检索零件记录。如果在索引中找不到零件号，则没有该零件的记录。程序显示为[程序 P7.9](#list9) 。

***[程序 P7.9](#_list9)***

```java
        import java.io.*;
        import java.util.*;
        public class UseIndex {
           static final int StringFixedLength = 20;
           static final int PartNumSize = 6;
           static final int PartRecordSize = 64;
           static int MaxRecords;

           public static void main(String[] args) throws IOException {
              RandomAccessFile fp = new RandomAccessFile("parts.bin", "rw");
              Index[] index = retrieveIndex();
              int numRecords = index[0].recNum;
              Scanner kb = new Scanner(System.in);
              System.out.printf("\nEnter a part number (E to end): ");
              String pnum = kb.next();
              while (!pnum.equalsIgnoreCase("E")) {
                 int n = search(pnum, index, numRecords);
                 if (n > 0) {
                    fp.seek(PartRecordSize * (index[n].recNum - 1));
                    readPartFromFile(fp).printPart();
                 }
                 else System.out.printf("Part not found\n");
                 System.out.printf("\nEnter a part number (E to end): ");
                 pnum = kb.next();
              } //end while
              fp.close();
           } //end main

           public static Index[] retrieveIndex() throws IOException {
              RandomAccessFile f = new RandomAccessFile("index.bin", "rw");
              int MaxRecords = f.readInt();
              Index[] index = new Index[MaxRecords + 1];
              for (int j = 0; j <= MaxRecords; j++) {
                 String pnum = "";
                 for (int i = 0; i < PartNumSize; i++) pnum += f.readChar();
                 index[j] = new Index(pnum, f.readInt());
              }
              f.close();
              return index;
           } //end retrieveIndex

           public static Part readPartFromFile(RandomAccessFile f) throws IOException {
              String pname = "";
              for (int h = 0; h < PartNumSize; h++) pname += f.readChar();
              char[] name = new char[StringFixedLength];
              for (int h = 0; h < StringFixedLength; h++) name[h] = f.readChar();
              String hold = new String(name, 0, StringFixedLength);
              return new Part(pname, hold.trim(), f.readInt(), f.readDouble());
           } //end readPartFromFile

           public static int search(String key, Index[] list, int n) {
           //searches list[1..n] for key. If found, it returns the location; otherwise
           //it returns the negative of the location in which key should be inserted.
              int lo = 1, hi = n;
              while (lo <= hi) {   // as long as more elements remain to consider
                 int mid = (lo + hi) / 2;
                 int cmp = key.compareToIgnoreCase(list[mid].partNum);
                 if (cmp == 0) return mid;  // search succeeds
                 if (cmp < 0) hi = mid - 1;   // key is 'less than' list[mid].partNum
                 else lo = mid + 1;     // key is 'greater than' list[mid].partNum
              }
              return -lo;         // key not found; insert in location lo
           } // end search

        } //end class UseIndex

        // Part and Index classes go here
```

以下是[程序 P7.9](#list9) 的运行示例:

```java
Enter a part number (E to end): dkp080
Part number: DKP080
Part name: Disc-Pads
Amount in stock: 16
Price: $9.99

Enter a part number (E to end): GsF555
Part number: GSF555
Part name: Gas-Filter
Amount in stock: 9
Price: $4.50

Enter a part number (E to end): PKL060
Part not found

Enter a part number (E to end): pkl070
Part number: PKL070
Part name: Park-Lens
Amount in stock: 8
Price: $6.50

Enter a part number (E to end): e
```

请注意，可以使用任何大小写字母组合来输入零件号。

如果需要，我们可以使用索引按零件号顺序打印记录。我们只是按照记录在索引中出现的顺序打印它们。例如，使用我们的样本数据，我们有如下的索引:

```java
    BLJ375    2
    DKP080    4
    FLT015    3
    GSF555    5
    PKL070    1
```

如果我们打印记录 2，然后是记录 4，然后是记录 3，然后是记录 5，然后是记录 1，我们将按零件号升序打印它们。这可以通过以下函数来完成:

```java
   public static void printFileInOrder(Index[] index, RandomAccessFile f) throws IOException {
      System.out.printf("\nFile sorted by part number: \n\n");
      int numRecords = index[0].recNum;
      for (int h = 1; h <= numRecords; h++) {
         f.seek(PartRecordSize * (index[h].recNum - 1));
         readPartFromFile(f).printPart();
         System.out.printf("\n");
      } //end for
   } //end printFileInOrder
```

假设该函数被添加到[程序 P7.9](#list9) 中，并在检索到索引后用以下语句调用:

```java
        printFileInOrder(index, fp);
```

将打印以下内容:

```java
File sorted by part number:

Part number: BLJ375
Part name: Ball-Joint
Amount in stock: 12
Price: $11.95

Part number: DKP080
Part name: Disc-Pads
Amount in stock: 16
Price: $9.99

Part number: FLT015
Part name: Oil-Filter
Amount in stock: 23
Price: $7.95

Part number: GSF555
Part name: Gas-Filter
Amount in stock: 9
Price: $4.50

Part number: PKL070
Part name: Park-Lens
Amount in stock: 8
Price: $6.50
```

7.9 更新随机存取文件

文件中的信息通常不是静态的。它必须不时更新。对于我们的零件文件，我们可能希望更新它，以反映项目售出时的新库存数量，或者反映价格的变化。我们可能决定储存新零件，因此我们必须在文件中添加记录，并且我们可能停止销售某些产品，因此必须从文件中删除它们的记录。

添加新记录的方式与首先加载文件的方式类似。我们可以从逻辑上删除一条记录，方法是在索引中将它标记为已删除，或者简单地将它从索引中删除。稍后，当文件被重组时，记录可能被物理删除(即，不存在于新文件中)。但是我们怎样才能*改变*现有记录中的信息呢？为此，我们必须做到以下几点:

1.  在文件中找到记录。
2.  把它读入内存。
3.  更改所需的字段。
4.  将更新后的记录写入其来源文件的*相同位置*。

这要求我们的文件以读写方式打开。假设文件已经存在，必须用模式`rw`打开。我们解释如何更新零件号存储在`key`中的记录。

首先，我们在索引中搜索`key`。如果找不到，则不存在该零件的记录。假设在位置`k`找到它。然后`index[k].recNum`给出它在零件文件中的记录号(`n`)。然后我们进行如下操作(为了清楚起见，省略了错误检查):

```java
        fp.seek(PartRecordSize * (n - 1));
        Part part = readPartFromFile(fp);
```

该记录现在存储在变量`part`中。假设我们需要从库存数量中减去`amtSold`。这可以通过以下方式实现:

```java
        if (amtSold > part.amtInStock)
           System.out.printf("Cannot sell more than you have: ignored\n");
        else part.amtInStock -= amtSold;
```

其他字段(除了零件号，因为它用于识别记录)可以类似地更新。当所有的更改都完成后，更新的记录部分保存在内存中。现在必须将它写回到文件中它原来的位置。这可以通过以下方式实现:

```java
        fp.seek(PartRecordSize * (n - 1));
        writePartToFile(part, fp);
```

注意，我们必须再次调用`seek`，因为在第一次读取记录后，文件被定位在下一个记录的*的开始处。在写入更新的记录之前，我们必须将它重新定位在刚刚读取的记录的开头。最终结果是更新的记录覆盖了旧的记录。*

[程序 P7.10](#list10) 更新零件文件中记录的`amtInStock`字段。要求用户输入零件号和销售量。该程序使用二分搜索法在索引中搜索零件号。如果找到，则从文件中检索记录，在内存中更新，并写回文件。重复此过程，直到用户输入`E`。

***[程序 P7.10](#_list10)***

```java
   import java.io.*;
   import java.util.*;
   public class UpdateFile {
      static final int StringFixedLength = 20;
      static final int PartNumSize = 6;
      static final int PartRecordSize = 64;
      static int MaxRecords;

      public static void main(String[] args) throws IOException {
         Scanner in = new Scanner(System.in);
         Index[] index = retrieveIndex();
         int numRecords = index[0].recNum;

         System.out.printf("\nEnter part number (E to end): ");
         String pnum = in.next();
         while (!pnum.equalsIgnoreCase("E")) {
            updateRecord(pnum, index, numRecords);
            System.out.printf("\nEnter part number (E to end): ");
            pnum = in.next();
         } //end while
      } //end main

      public static void updateRecord(String pnum, Index[] index, int max)throws IOException {
         Scanner in = new Scanner(System.in);
         RandomAccessFile fp = new RandomAccessFile("parts.bin", "rw");

         int n = search(pnum, index, max);
         if (n < 0) System.out.printf("Part not found\n");
         else {
            fp.seek(PartRecordSize * (index[n].recNum - 1));
            Part part = readPartFromFile(fp);
            System.out.printf("Enter amount sold: ");
            int amtSold = in.nextInt();
            if (amtSold > part.amtInStock)
               System.out.printf("You have %d: cannot sell more, ignored\n",
                        part.amtInStock);
            else {
               part.amtInStock -= amtSold;
               System.out.printf("Amount remaining: %d\n", part.amtInStock);
               fp.seek(PartRecordSize * (index[n].recNum - 1));
               writePartToFile(part, fp);
               System.out.printf("%s %-11s %2d %5.2f\n", part.partNum, part.name,
                                                       part.amtInStock, part.price);
            } //end if
         } //end if
         fp.close();
      } //end updateRecord

      public static Index[] retrieveIndex() throws IOException {
         RandomAccessFile f = new RandomAccessFile("index.bin", "rw");
         int MaxRecords = f.readInt();
         Index[] index = new Index[MaxRecords + 1];
         for (int j = 0; j <= MaxRecords; j++) {
            String pnum = "";
            for (int i = 0; i < PartNumSize; i++) pnum += f.readChar();
            index[j] = new Index(pnum, f.readInt());
         }
         f.close();
         return index;
      } //end retrieveIndex

      public static Part readPartFromFile(RandomAccessFile f) throws IOException {
         String pname = "";
         for (int h = 0; h < PartNumSize; h++) pname += f.readChar();
         char[] name = new char[StringFixedLength];
         for (int h = 0; h < StringFixedLength; h++) name[h] = f.readChar();
         String hold = new String(name, 0, StringFixedLength);
         return new Part(pname, hold.trim(), f.readInt(), f.readDouble());
      } //end readPartFromFile

      public static void writePartToFile(Part part, RandomAccessFile f) throws IOException {
         for (int h = 0; h < PartNumSize; h++) f.writeChar(part.partNum.charAt(h));
         int n = Math.min(part.name.length(), StringFixedLength);
         for (int h = 0; h < n; h++) f.writeChar(part.name.charAt(h));
         for (int h = n; h < StringFixedLength; h++) f.writeChar(' ');
         f.writeInt(part.amtInStock);
         f.writeDouble(part.price);
      } //end writePartToFile

      public static int search(String key, Index[] list, int n) {
      //searches list[1..n] for key. If found, it returns the location; otherwise
      //it returns the negative of the location in which key should be inserted.
         int lo = 1, hi = n;
         while (lo <= hi) {   // as long as more elements remain to consider
            int mid = (lo + hi) / 2;
            int cmp = key.compareToIgnoreCase(list[mid].partNum);
            if (cmp == 0) return mid;    // search succeeds
            if (cmp < 0) hi = mid - 1;   // key is 'less than' list[mid].partNum
            else lo = mid + 1;           // key is 'greater than' list[mid].partNum
         }
         return -lo;                     // key not found; insert in location lo
      } // end search

   } //end class UpdateFile

   // Part and Index classes go here
```

以下是[程序 P7.10](#list10) 的运行示例:

```java
Enter part number (E to end): blj375
Enter amount sold: 2
Amount remaining: 10
BLJ375 Ball-Joint  10 11.95

Enter part number (E to end): blj375
Enter amount sold: 11
You have 10: cannot sell more, ignored

Enter part number (E to end): dkp080
Enter amount sold: 4
Amount remaining: 12
DKP080 Disc-Pads   12  9.99

Enter part number (E to end): gsf55
Part not found

Enter part number (E to end): gsf555
Enter amount sold: 1
Amount remaining: 8
GSF555 Gas-Filter   8  4.50

Enter part number (E to end): e
```

**练习 7**

1.  用`"r"`打开的文件和用`"rw"`打开的文件有什么区别？
2.  写一个程序来判断两个二进制文件是否相同。如果它们不同，打印它们不同的第一个字节数。
3.  写一个程序来读取整数的(二进制)文件，对整数进行排序，并把它们写回同一个文件。假设所有的数字都可以存储在一个数组中。
4.  重复(3 ),但假设在任何时候只有 20 个数字可以存储在内存中(在一个数组中)。提示:您将需要使用至少 2 个额外的临时输出文件。
5.  写一个程序来读取两个整数排序文件，并将值合并到第三个排序文件中。
6.  写一个程序来读取一个文本文件并产生另一个文本文件，其中所有的行都小于给定的长度。一定要在可感的地方断行；例如，避免断词或在行首放置孤立的标点符号。
7.  What is the purpose of creating an index for a file?

    以下是员工档案中的一些记录。这些字段是员工编号(键)、姓名、职称、电话号码、月薪和要扣除的税。

    `STF425, Julie Johnson, Secretary, 623-3321, 2500, 600`

    `COM319, Ian McLean, Programmer, 676-1319, 3200, 800`

    `SYS777, Jean Kendall, Systems Analyst, 671-2025, 4200, 1100`

    `JNR591, Lincoln Kadoo, Operator, 657-0266, 2800, 700`

    `MSN815, Camille Kelly, Clerical Assistant, 652-5345, 2100, 500`

    `STF273, Anella Bayne, Data Entry Manager, 632-5324, 3500, 850`

    `SYS925, Riaz Ali, Senior Programmer, 636-8679, 4800, 1300`

    假设记录按照给定的顺序存储在二进制文件中。

    1.  给定记录号，如何检索记录？
    2.  给定记录的键，如何检索记录？
    3.  加载文件时，创建一个索引，其中的键按给定的顺序排列。如何在这样的索引中搜索给定的键？
    4.  As the file is loaded, create an index in which the keys are sorted. Given a key, how is the corresponding record retrieved?

        讨论在文件中添加和删除记录时，必须对索引进行哪些更改。

8.  对于本章中讨论的“零件文件”应用程序，编写(I)添加新记录和(ii)删除记录的方法。