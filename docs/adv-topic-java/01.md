# 一、排序、搜索和合并

在本章中，我们将解释以下内容:

*   如何使用选择排序对项目列表进行排序
*   如何使用插入排序对项目列表进行排序
*   如何向排序列表中添加一个新项目，使列表保持排序
*   如何对字符串数组进行排序
*   如何对相关(并行)数组进行排序
*   如何使用二分搜索法搜索排序列表
*   如何搜索字符串数组
*   如何写一个程序来计算一篇文章中单词的频率
*   如何合并两个排序列表以创建一个排序列表

1.1 排序一个数组:选择排序

S *orting* 是将一组数值按升序或降序排列的过程。排序的原因有很多。有时我们排序是为了产生更可读的输出(例如，产生一个按字母顺序排列的列表)。教师可能需要按姓名或平均分对学生进行排序。如果我们有一个很大的值集，并且我们想要识别重复项，我们可以通过排序来实现；重复的值将一起出现在排序列表中。

排序的另一个优点是，对于排序后的数据，一些操作可以更快更有效地执行。例如，如果数据已经排序，可以使用二分搜索法搜索，这比使用顺序搜索要快得多。此外，合并两个单独的项目列表可以比列表未排序时快得多。

排序的方式有很多种。在这一章中，我们将讨论两种“简单”的方法:选择和插入排序。在第九章中，我们将会看到更复杂的排序方式。我们从选择排序开始。

考虑以下存储在 Java 数组中的数字列表，`num` :

![9781430266198_unFig01-01.jpg](img/9781430266198_unFig01-01.jpg)

使用选择排序按升序对`num`进行排序的过程如下:

**1**<sup>STT5**pass**</sup>

*   从位置`0`到`6`找到整个列表中最小的数字；最小的是`15`，位于`4`位置。
*   Interchange the numbers in positions `0` and `4`. This gives us the following:

    ![9781430266198_unFig01-02.jpg](img/9781430266198_unFig01-02.jpg)

**2**<sup>2通过</sup>

*   找出位置`1`到`6`的最小数字；最小的是`33`，位于`5`位置。
*   Interchange the numbers in positions `1` and `5`. This gives us the following:

    ![9781430266198_unFig01-03.jpg](img/9781430266198_unFig01-03.jpg)

**3**<sup>rdpass</sup>

*   找出位置`2`到`6`的最小数字；最小的是`48`，位于`5`位置。
*   Interchange the numbers in positions `2` and `5`. This gives us the following:

    ![9781430266198_unFig01-04.jpg](img/9781430266198_unFig01-04.jpg)

**4 次**<sup>3 次 5 次**过关**</sup>

*   找出位置`3`到`6`的最小数字；最小的是`52`，位于`6`位置。
*   Interchange the numbers in positions `3` and `6`. This gives us the following:

    ![9781430266198_unFig01-05.jpg](img/9781430266198_unFig01-05.jpg)

**5 次**<sup>3 次</sup> **过关**

*   找出位置`4`到`6`的最小数字；最小的是`57`，位于`4`位置。
*   Interchange the numbers in positions `4` and `4`. This gives us the following:

    ![9781430266198_unFig01-06.jpg](img/9781430266198_unFig01-06.jpg)

**6 次**<sup>3 次</sup> **过关**

*   找出位置`5`到`6`的最小数字；最小的是`65`，位于`6`位置。
*   Interchange the numbers in positions `5` and `6`. This gives us the following:

    ![9781430266198_unFig01-07.jpg](img/9781430266198_unFig01-07.jpg)

数组现在已经完全排序了。注意，一旦第 6 个<sup>最大的</sup>被放置在其最终位置(5)，最大的(79)将自动处于最后位置(6)。

在本例中，我们进行了六次传递。我们将通过让变量`h`从`0`到`5`来计算这些通道。在每一遍中，我们找到从位置`h`到`6`的最小数字。如果最小的数字在位置`s`，我们交换位置`h`和`s`的数字。

一般来说，对于大小为`n`的数组，我们进行`n-1`遍。在我们的例子中，我们对`6`通道中的`7`号进行了排序。下面是排序`num[0..n-1]` 的算法的伪代码概要:

```java
        for h = 0 to n - 2
           s = position of smallest number from num[h] to num[n-1]
           swap num[h] and num[s]
        endfor
```

我们可以使用通用参数`list`如下实现该算法:

```java
        public static void selectionSort(int[] list, int lo, int hi) {
        //sort list[lo] to list[hi] in ascending order
           for (int h = lo; h < hi; h++) {
              int s = getSmallest(list, h, hi);
              swap(list, h, s);
           }
        }
```

`for`循环中的两个语句可以替换为以下内容:

```java
        swap(list, h, getSmallest(list, h, hi));
```

我们可以把`getSmallest`和`swap`写成:

```java
        public static int getSmallest(int list[], int lo, int hi) {
        //return location of smallest from list[lo..hi]
           int small = lo;
           for (int h = lo + 1; h <= hi; h++)
              if (list[h] < list[small]) small = h;
           return small;
        }

        public static void swap(int list[], int i, int j) {
        //swap elements list[i] and list[j]
           int hold = list[i];
           list[i] = list[j];
           list[j] = hold;
        }
```

为了测试`selectionSort`是否正常工作，我们编写程序 P1.1 。仅显示了`main`。要完成程序，只需添加`selectionSort`、`getSmallest`和`swap`。

***程序 p 1.1***

```java
        import java.util.*;
        public class SelectSortTest {
           final static int MaxNumbers = 10;
           public static void main(String[] args) {
              Scanner in = new Scanner(System.in);
              int[] num = new int[MaxNumbers];
              System.out.printf("Type up to %d numbers followed by 0\n", MaxNumbers);
              int n = 0;
              int v = in.nextInt();
              while (v != 0 && n < MaxNumbers) {
                 num[n++] = v;
                 v = in.nextInt();
              }
              if (v != 0) {
                 System.out.printf("\nMore than %d numbers entered\n", MaxNumbers);
                 System.out.printf("First %d used\n", MaxNumbers);
              }
              if (n == 0) {
                 System.out.printf("\nNo numbers supplied\n");
                 System.exit(1);
              }
              //n numbers are stored from num[0] to num[n-1]
              selectionSort(num, 0, n-1);
              System.out.printf("\nThe sorted numbers are\n");
              for (v = 0; v < n; v++) System.out.printf("%d ", num[v]);
              System.out.printf("\n");
           } //end main

           // selectionSort, getSmallest and swap go here

        } //end class SelectSortTest
```

程序请求最多 10 个数字(由`MaxNumbers`定义)，将它们存储在数组`num`中，调用`selectionSort`，然后打印排序后的列表。

以下是该程序的运行示例:

```java
        Type up to 10 numbers followed by 0
        57 48 79 65 15 33 52 0

        The sorted numbers are
        15 33 48 52 57 65 79
```

请注意，如果用户输入了十个以上的数字，程序会识别出来，并且只对前十个进行排序。

1.1.1 选择排序分析

为了找到最小的 *k* 项，我们进行 *k* -1 比较。在第一遍中，我们进行 *n* -1 次比较，以找到 *n* 项中最小的一项。在第二遍中，我们进行第 *n* -2 次比较，以找到第 *n* -1 项中最小的一项。以此类推，直到最后一遍，我们进行一次比较，找出两个项目中较小的一个。一般来说，在第 *j* 遍时，我们进行 *n-j* 比较，以找到 *n-j* +1 项中最小的一项。因此，我们有了这个:

总比较次数= 1+2+…+*n*-1 =*n*(*n*-1)≈*n*<sup>*2*</sup>

我们说选择排序的顺序是 O( *n* <sup>*2*</sup> )(“大 on 的平方”)。常数在“大 O”符号中并不重要，因为随着 *n* 变得非常大，常数变得无关紧要。

每一次，我们用三个任务交换两个项目。因为我们做了 *n* -1 遍，所以我们总共做了 3( *n* -1)次分配。使用“大 O”符号，我们说赋值的个数是 O( *n* )。常数`3`和`1`并不重要，因为 *n* 变大了。

如果数据是有序的，选择排序的性能会更好吗？不。一种方法是给它一个排序列表，看看它做什么。如果你完成了这个算法，你会发现这个方法不考虑数据的顺序。不管数据如何，它每次都会进行相同次数的比较。

正如我们将看到的，一些排序方法(mergesort 和 quicksort 参见第五章和第九章需要额外的数组存储来实现它们。请注意，选择排序是在给定数组中“就地”执行的，不需要额外的存储。

作为一个练习，修改程序代码，使其计算使用选择排序对列表进行排序时的比较和赋值次数。

1.2 数组排序:插入排序

考虑与之前相同的阵列:

![9781430266198_unFig01-08.jpg](img/9781430266198_unFig01-08.jpg)

现在，把数字想象成桌子上的卡片，按照它们在数组中出现的顺序一次拿一张。因此，我们首先拿起`57`，然后是`48`，然后是`79`，以此类推，直到我们拿起`52`。然而，当我们拿起每一个新的数字时，我们把它加到我们手上，这样我们手上的数字都被排序了。

当我们拿起`57`时，我们手中只有一个数字。我们认为有一个数字需要排序。

当我们拿起`48`时，我们将它添加到`57`前面，因此我们的手包含以下内容:

`48 57`

当我们拿起`79`时，我们把它放在`57`之后，所以我们的手包含这个:

`48 57 79`

当我们拿起`65`时，我们把它放在`57`之后，所以我们的手包含这个:

`48 57 65 79`

在这个阶段，四个数字已经被捡起来了，我们的手按排序顺序包含它们。

当我们拿起`15`时，我们把它放在`48`之前，所以我们的手包含这个:

`15 48 57 65 79`

当我们拿起`33`时，我们把它放在`15`之后，所以我们的手包含这个:

`15 33 48 57 65 79`

最后，当我们拿起`52`时，我们把它放在`48`之后，所以我们的手包含这个:

`15 33 48 52 57 65 79`

这些数字已经按升序排序。

所描述的方法说明了*插入排序* 背后的思想。从左到右，一次处理一个数组中的数字。这相当于从表中一次选取一个数字。由于第一个数字本身是已排序的，我们将从第二个数字开始处理数组中的数字。

当我们开始处理`num[h]`时，我们可以假设`num[0]`到`num[h-1]`被排序。我们在`num[0]`到`num[h-1]`中插入`num[h]`，这样`num[0]`到`num[h]`就被排序了。然后我们继续处理`num[h+1]`。当我们这样做时，我们的假设`num[0]`到`num[h]`被排序将为真。

使用插入排序按升序对`num`排序的过程如下:

**1**<sup>STT5**pass**</sup>

*   Process `num[1]`, that is, `48`. This involves placing `48` so that the first two numbers are sorted; `num[0]` and `num[1]` now contain the following:

    ![9781430266198_unFig01-09.jpg](img/9781430266198_unFig01-09.jpg)

数组的其余部分保持不变。

**2**<sup>2通过</sup>

*   Process `num[2]`, that is, `79`. This involves placing `79` so that the first three numbers are sorted; `num[0]` to `num[2]` now contain the following:

    ![9781430266198_unFig01-10.jpg](img/9781430266198_unFig01-10.jpg)

数组的其余部分保持不变。

**3**<sup>rdpass</sup>

*   Process `num[3]`, that is, `65`. This involves placing `65` so that the first four numbers are sorted; `num[0]` to `num[3]` now contain the following:

    ![9781430266198_unFig01-11.jpg](img/9781430266198_unFig01-11.jpg)

数组的其余部分保持不变。

**4 次**<sup>3 次 5 次**过关**</sup>

*   Process `num[4]`, that is, `15`. This involves placing `15` so that the first five numbers are sorted. To simplify the explanation, think of 15 as being taken out and stored in a simple variable (`key`, say) leaving a “hole” in `num[4]`.  We can picture this as follows:

    ![9781430266198_unFig01-12.jpg](img/9781430266198_unFig01-12.jpg)

将`15`插入其正确位置的过程如下:

*   Compare `15` with `79`; it is smaller, so move `79` to location `4`, leaving location `3` free. This gives the following:

    ![9781430266198_unFig01-13.jpg](img/9781430266198_unFig01-13.jpg)

*   Compare `15` with `65`; it is smaller, so move `65` to location `3`, leaving location `2` free. This gives the following:

    ![9781430266198_unFig01-14.jpg](img/9781430266198_unFig01-14.jpg)

*   Compare `15` with `57`; it is smaller, so move `57` to location `2`, leaving location `1` free. This gives the following:

    ![9781430266198_unFig01-15.jpg](img/9781430266198_unFig01-15.jpg)

*   Compare `15` with `48`; it is smaller, so move `48` to location `1`, leaving location `0` free. This gives the following:

    ![9781430266198_unFig01-16.jpg](img/9781430266198_unFig01-16.jpg)

*   There are no more numbers to compare with `15`, so it is inserted in location `0`, giving the following:

    ![9781430266198_unFig01-17.jpg](img/9781430266198_unFig01-17.jpg)

*   我们可以把`15` ( `key`)的摆放逻辑用它和它左边的数字比较来表达，从最近的一个开始。只要`key`小于`num[k]`，对于某些`k`，我们就把`num[k]`移到`num[k + 1]`位置，继续考虑`num[k-1]`，前提是它存在。当`k`实际上是`0`的时候就不会存在了。在这种情况下，过程停止，并且`key`插入位置`0`。

**5 次**<sup>3 次</sup> **过关**

*   流程`num[5]`，即`33`。这包括放置`33`,以便对前六个数字进行排序。这是按如下方式完成的:

*   将`33`存储在`key`中，留下位置`5`空闲。
*   比较`33`和`79`；它变小了，所以把`79`移到位置`5`，留下位置`4`空闲。
*   比较`33`和`65`；它变小了，所以把`65`移到位置`4`，留下位置`3`空闲。
*   比较`33`和`57`；它变小了，所以把`57`移到位置`3`，留下位置`2`空闲。
*   比较`33`和`48`；它变小了，所以把`48`移到位置`2`，留下位置`1`空闲。
*   Compare `33` with `15`; it is bigger, so insert `33` in location `1`. This gives the following:

    ![9781430266198_unFig01-18.jpg](img/9781430266198_unFig01-18.jpg)

*   我们可以通过与它左边的数字比较来表达放置`33`的逻辑，从最近的一个开始。只要`key`小于`num[k]`，对于某些`k`，我们就把`num[k]`移到位置`num[k + 1]`，继续考虑`num[k-1]`，前提是它存在。如果某些`k`的`key`大于或等于`num[k]`，则`key`插入`k+1`位置。这里，`33`大于`num[0]`，所以插入`num[1]`。

**6 次**<sup>3 次</sup> **过关**

*   流程`num[6]`，即`52`。这包括放置`52`,以便对前七个(所有)数字进行排序。这是按如下方式完成的:

*   将`52`存储在`key`中，留下位置`6`空闲。
*   比较`52`和`79`；它变小了，所以把`79`移到位置`6`，留下位置`5`空闲。
*   比较`52`和`65`；它变小了，所以把`65`移到位置`5`，留下位置`4`空闲。
*   比较`52`和`57`；它变小了，所以把`57`移到位置`4`，留下位置`3`空闲。
*   Compare `52` with `48`; it is bigger; so insert `52` in location `3`. This gives the following:

    ![9781430266198_unFig01-19.jpg](img/9781430266198_unFig01-19.jpg)

数组现在已经完全排序了。

以下是如何使用插入排序对数组`num`的前`n`个元素进行排序的概述:

```java
        for h = 1 to n - 1 do
           insert num[h] among num[0] to num[h-1] so that num[0] to num[h] are sorted
        endfor
```

使用这个大纲，我们使用参数`list` 编写函数`insertionSort`。

```java
        public static void insertionSort(int list[], int n) {
        //sort list[0] to list[n-1] in ascending order
           for (int h = 1; h < n; h++) {
              int key = list[h];
              int k = h - 1; //start comparing with previous item
              while (k >= 0 && key < list[k]) {
                 list[k + 1] = list[k];
                 --k;
              }
              list[k + 1] = key;
           } //end for
        } //end insertionSort
```

`while`语句是该排序的核心。它声明，只要我们在数组(`k >= 0`)中，并且当前数字(`key`)小于数组(`key < list[k]`)中的数字，我们就将`list[k]`向右移动(`list[k+1] = list[k]`)，并继续移动到左边的下一个数字(`--k`)。

对于某些`k`，如果`k`等于`-1`或者如果`key`大于或等于`list[k]`，我们退出`while`循环。无论哪种情况，`key`都被插入到`list[k+1]`中。

如果`k`为`-1`，则表示当前数字小于列表中所有之前的数字，必须插入到`list[0]`中。但是`list[k + 1]` *是* `list[0]`当`k`是`-1`时，那么`key`在这种情况下是正确插入的。

该函数按升序排序。要按降序排序，我们所要做的就是将`while`条件中的`<`改为`>`，就像这样:

```java
        while (k >= 0 && key > list[k])
```

现在，如果*比*大，一个键会向左移动。

我们编写程序 P1.2 来测试`insertionSort`是否正常工作。仅显示了`main`。添加功能`insertionSort`完成程序。

***程序 P1.2***

```java
        import java.util.*;
        public class InsertSortTest {
           final static int MaxNumbers = 10;
           public static void main(String[] args) {
              Scanner in = new Scanner(System.in);
              int[] num = new int[MaxNumbers];
              System.out.printf("Type up to %d numbers followed by 0\n", MaxNumbers);
              int n = 0;
              int v = in.nextInt();
              while (v != 0 && n < MaxNumbers) {
                 num[n++] = v;
                 v = in.nextInt();
              }
              if (v != 0) {
                 System.out.printf("\nMore than %d numbers entered\n", MaxNumbers);
                 System.out.printf("First %d used\n", MaxNumbers);
              }
              if (n == 0) {
                 System.out.printf("\nNo numbers supplied\n");
                 System.exit(1);
              }
              //n numbers are stored from num[0] to num[n-1]
              insertionSort(num, n);
              System.out.printf("\nThe sorted numbers are\n");
              for (v = 0; v < n; v++) System.out.printf("%d ", num[v]);
              System.out.printf("\n");
           } //end main

           public static void insertionSort(int list[], int n) {
           //sort list[0] to list[n-1] in ascending order
              for (int h = 1; h < n; h++) {
                 int key = list[h];
                 int k = h - 1; //start comparing with previous item
                 while (k >= 0 && key < list[k]) {
                    list[k + 1] = list[k];
                    --k;
                 }
                 list[k + 1] = key;
              } //end for
           } //end insertionSort

        } //end class InsertSortTest
```

程序请求最多十个数字(由`MaxNumbers`定义)，将它们存储在数组`num`中，调用`insertionSort`，然后打印排序后的列表。

以下是该程序的运行示例:

```java
Type up to 10 numbers followed by 0
57 48 79 65 15 33 52 0
The sorted numbers are
15 33 48 52 57 65 79
```

请注意，如果用户输入了十个以上的数字，程序会识别出来，并且只对前十个进行排序。

我们可以很容易地推广`insertionSort`来排序列表的*部分*。为了举例说明，我们重写了`insertionSort`(称之为`insertionSort1`)来将`list[lo]`排序为`list[hi]`，其中`lo`和`hi`作为参数传递给函数。

由于元素`lo`是第一个，我们从`lo+1`开始处理元素，直到元素`hi`。这在`for`语句中有所体现。还有现在，下标最低的是`lo`，而不是`0`。这反映在`while`状态`k >= lo`中。其他一切都和以前一样。

```java
        public static void insertionSort1(int list[], int lo, int hi) {
        //sort list[lo] to list[hi] in ascending order
           for (int h = lo + 1; h <= hi; h++) {
              int key = list[h];
              int k = h - 1; //start comparing with previous item
              while (k >= lo && key < list[k]) {
                 list[k + 1] = list[k];
                 --k;
              }
              list[k + 1] = key;
           } //end for
        } //end insertionSort1
```

我们可以用程序 P1.2a 来测试`insertionSort1`。

***程序 p 1.2a***

```java
        import java.util.*;
        public class InsertSort1Test {
           final static int MaxNumbers = 10;
           public static void main(String[] args) {
              Scanner in = new Scanner(System.in);
              int[] num = new int[MaxNumbers];
              System.out.printf("Type up to %d numbers followed by 0\n", MaxNumbers);
              int n = 0;
              int v = in.nextInt();
              while (v != 0 && n < MaxNumbers) {
                 num[n++] = v;
                 v = in.nextInt();
              }
              if (v != 0) {
                 System.out.printf("\nMore than %d numbers entered\n", MaxNumbers);
                 System.out.printf("First %d used\n", MaxNumbers);
              }
              if (n == 0) {
                 System.out.printf("\nNo numbers supplied\n");
                 System.exit(1);
              }
              //n numbers are stored from num[0] to num[n-1]
              insertionSort1(num, 0, n-1);
              System.out.printf("\nThe sorted numbers are\n");
              for (v = 0; v < n; v++) System.out.printf("%d ", num[v]);
              System.out.printf("\n");
           } //end main

           // insertionSort1 goes here

        } //end class InsertSort1Test
```

1.2.1 插入排序分析

在处理项目 *j* 时，我们可以少做 1 次比较(如果`num[j]`大于`num[j-1]`)或多做 *j* -1 次比较(如果`num[j]`小于前面所有项目)。对于随机数据，我们期望平均进行( *j* -1)次比较。因此，对 *n* 项进行排序的平均总比较次数为:

![pg11.jpg](img/pg11.jpg)

我们说插入排序的顺序是 O(n <sup>2</sup> )(“大 O ^ n 的平方”)。当 n 变大时，常数并不重要。

每次我们做一个比较，我们也做一个分配。因此，分配的总数也是 n(n-1) ≈ n <sup>2</sup> 。

我们强调这是随机数据的平均值。与选择排序不同，插入排序的实际性能取决于所提供的数据。如果给定的数组已经排序，插入排序将通过进行 n-1 次比较来快速确定这一点。在这种情况下，它以 O(n)时间运行。人们会认为，数据中的顺序越多，插入排序的性能就越好。

如果给定的数据是降序排列的，插入排序的性能最差，因为每个新数字都必须一直移动到列表的开头。在这种情况下，比较的次数是 n(n-1) ≈ n <sup>2</sup> 。分配数也是 n(n-1) ≈ n <sup>2</sup> 。

因此，通过插入排序进行比较的次数从 n-1(最佳)到 n <sup>2</sup> (平均)到 n <sup>2</sup> (最差)。赋值的次数总是与比较的次数相同。

与选择排序一样，插入排序的实现不需要额外的数组存储。

作为一个练习，修改程序代码，使其计算使用插入排序对列表进行排序时的比较和赋值次数。

1.3 在 处插入一个元素

插入排序使用向已经排序的列表中添加新元素的思想，以便列表保持排序。我们可以把它本身当作一个问题(与插入排序无关)。具体来说，给定一个从`list[m]`到`list[n]`的排序列表，我们想要向列表中添加一个新的条目(比如说`newItem`)，以便对`list[m]`到`list[n+1]`进行排序。

添加新项目会使列表的大小增加 1。我们假设数组有空间容纳新的项目。我们编写函数`insertInPlace`来解决这个问题。

```java
        public static void insertInPlace(int newItem, int list[], int m, int n) {
        //list[m] to list[n] are sorted
        //insert newItem so that list[m] to list[n+1] are sorted
           int k = n;
           while (k >= m && newItem < list[k]) {
              list[k + 1] = list[k];
              --k;
           }
           list[k + 1] = newItem;
        } //end insertInPlace
```

使用`insertInPlace`，我们可以将`insertionSort`(称之为`insertionSort2`)重写如下:

```java
        public static void insertionSort2(int list[], int lo, int hi) {
        //sort list[lo] to list[hi] in ascending order
           for (int h = lo + 1; h <= hi; h++)
              insertInPlace(list[h], list, lo, h - 1);
        } //end insertionSort2
```

我们可以用程序 P1.2b 来测试`insertionSort2`。

***程序 p 1.2b***

```java
        import java.util.*;
        public class InsertSort2Test {
           final static int MaxNumbers = 10;
           public static void main(String[] args) {
              Scanner in = new Scanner(System.in);
              int[] num = new int[MaxNumbers];
              System.out.printf("Type up to %d numbers followed by 0\n", MaxNumbers);
              int n = 0;
              int v = in.nextInt();
              while (v != 0 && n < MaxNumbers) {
                 num[n++] = v;
                 v = in.nextInt();
              }
              if (v != 0) {
                 System.out.printf("\nMore than %d numbers entered\n", MaxNumbers);
                 System.out.printf("First %d used\n", MaxNumbers);
              }
              if (n == 0) {
                 System.out.printf("\nNo numbers supplied\n");
                 System.exit(1);
              }
              //n numbers are stored from num[0] to num[n-1]
              insertionSort2(num, 0, n-1);
              System.out.printf("\nThe sorted numbers are\n");
              for (v = 0; v < n; v++) System.out.printf("%d ", num[v]);
                 System.out.printf("\n");
           } //end main

           public static void insertionSort2(int list[], int lo, int hi) {
           //sort list[lo] to list[hi] in ascending order
              for (int h = lo + 1; h <= hi; h++)
                 insertInPlace(list[h], list, lo, h - 1);
           } //end insertionSort2

           public static void insertInPlace(int newItem, int list[], int m, int n) {
           //list[m] to list[n] are sorted
           //insert newItem so that list[m] to list[n+1] are sorted
              int k = n;
              while (k >= m && newItem < list[k]) {
                 list[k + 1] = list[k];
                 --k;
              }
              list[k + 1] = newItem;
           } //end insertInPlace

        } //end class InsertSort2Test
```

1.4 对字符串数组进行排序

考虑按字母顺序排列姓名列表的问题。在 Java 中，一个名字存储在一个`String`变量中，我们需要一个`String`数组来存储这个列表。在大多数情况下，我们可以像处理一个原始类型一样处理`String`,但是有时候记住严格来说，它是一个类是很有用的。在必要的地方，我们会指出区别。

这里我们关心的一个区别是，我们不能使用关系运算符(`==`、`<`、`>`等等)来比较字符串。我们必须使用`String`类中的函数(或者自己编写)。常用功能有`equals`、`equalsIgnoreCase`、`compareTo`、`compareToIgnoreCase`。我们编写一个函数，使用插入排序对字符串数组进行排序。我们称之为`insertionSort3`。

```java
        public static void insertionSort3(String[] list, int lo, int hi) {
        //sort list[lo] to list[hi] in ascending order
           for (int h = lo + 1; h <= hi; h++) {
              String key = list[h];
              int k = h - 1; //start comparing with previous item
              while (k >= lo && key.compareToIgnoreCase(list[k]) < 0) {
                 list[k + 1] = list[k];
                 --k;
              }
              list[k + 1] = key;
           } //end for
        } //end insertionSort3
```

除了声明`list`和使用`compareToIgnoreCase`来比较两个字符串之外，该函数与前面的函数非常相似。如果情况紧急，你可以使用`compareTo`。

我们用程序 P1.3 测试`insertionSort3`。

***程序 P1.3***

```java
        import java.util.*;
        public class SortStrings {
           final static int MaxNames = 8;
           public static void main(String[] args) {
              String name[] = {"Graham, Ariel", "Perrott, Chloe",
                     "Charles, Kandice", "Seecharan, Anella", "Reyes, Aaliyah",
                     "Graham, Ashleigh", "Reyes, Ayanna", "Greaves, Sherrelle" };

              insertionSort3(name, 0, MaxNames - 1);

              System.out.printf("\nThe sorted names are\n\n");
              for (int h = 0; h < MaxNames; h++)
                 System.out.printf("%s\n", name[h]);
           } //end main

           // insertionSort3 goes here

        } //end class SortStrings
```

运行时，程序 P1.3 产生如下输出:

```java
The sorted names are

Charles, Kandice
Graham, Ariel
Graham, Ashleigh
Greaves, Sherrelle
Perrott, Chloe
Reyes, Aaliyah
Reyes, Ayanna
Seecharan, Anella
```

1.5 排序并行数组

在不同的数组中有相关的信息是很常见的。例如，假设除了`name`，我们还有一个整数数组`id`，使得`id[h]`是与`name[h]`关联的标识号，如图图 1-1 所示。

![9781430266198_Fig01-01.jpg](img/9781430266198_Fig01-01.jpg)

图 1-1 。包含相关信息的两个数组

考虑按字母顺序排列名字的问题。最后，我们希望每个名字都有正确的 ID 号。因此，例如，在排序完成后，`name[0]`应该包含“查尔斯，坎蒂斯”,`id[0]`应该包含`4455`。

为此，在排序过程中，每次移动一个姓名时，相应的 ID 号也必须移动。因为姓名和 ID 号必须“并行”移动，所以我们说我们正在进行“并行排序”或者我们正在排序“并行数组”。

我们重写`insertionSort3`来说明如何对并行数组进行排序。我们只需添加代码，以便在移动名称时移动 ID。我们称之为`parallelSort`。

```java
        public static void parallelSort(String[] list, int id[], int lo, int hi) {
        //Sort the names in list[lo] to list[hi] in alphabetical order,
        //ensuring that each name remains with its original id number.
           for (int h = lo + 1; h <= hi; h++) {
              String key = list[h];
              int m = id[h];  // extract the id number
              int k = h - 1; //start comparing with previous item
              while (k >= lo && key.compareToIgnoreCase(list[k]) < 0) {
                 list[k + 1] = list[k];
                 id[k+ 1] = id[k];  //move up id number when we move a name
                 --k;
              }
              list[k + 1] = key;
              id[k + 1] = m; //store the id number in the same position as the name
           } //end for
        } //end parallelSort
```

我们通过编写程序 P1.4 来测试`parallelSort`。

***程序 P1.4***

```java
        import java.util.*;
        public class ParallelSort {
           final static int MaxNames = 8;
           public static void main(String[] args) {
              String name[] = {"Graham, Ariel", "Perrott, Chloe",
                     "Charles, Kandice", "Seecharan, Anella", "Reyes, Aaliyah",
                     "Graham, Ashleigh", "Reyes, Ayanna", "Greaves, Sherrelle" };
              int id[] = {3050,2795,4455,7824,6669,5000,5464,6050};

              parallelSort(name, id, 0, MaxNames - 1);

              System.out.printf("\nThe sorted names and IDs are\n\n");
              for (int h = 0; h < MaxNames; h++)
                 System.out.printf("%-20s %d\n", name[h], id[h]);
           } //end main

           // parallelSort goes here

        } //end class ParallelSort
```

当程序 P1.4 运行时，它产生以下输出:

```java
The sorted names and IDs are

Charles, Kandice     4455
Graham, Ariel        3050
Graham, Ashleigh     5000
Greaves, Sherrelle   6050
Perrott, Chloe       2795
Reyes, Aaliyah       6669
Reyes, Ayanna        5464
Seecharan, Anella    7824
```

我们顺便注意到，如果我们有几组相关的项目要处理，那么将每一组存储在一个单独的数组中并不是最好的处理方式。最好将项目分组到一个类中，并像处理单个项目一样与该组一起工作。我们将在 2.14 节向您展示如何做到这一点。

1.6 二分搜索法

*是一种快速搜索给定项目列表的方法，*提供列表排序*(升序或降序)。为了说明该方法，考虑一个由 13 个数字组成的列表，按升序排序并存储在数组`num[0..12]`中。*

 *![9781430266198_unFig01-20.jpg](img/9781430266198_unFig01-20.jpg)

假设我们要搜索`66`。搜索过程如下:

1.  我们找到了列表中的中间项。这是在位置`6`的`56`。我们将`66`与`56`相比较。由于`66`更大，我们知道如果`66`在列表中，那么*一定是在*位置`6`之后的*，因为数字是按升序排列的。下一步，我们将搜索范围限制在位置`7`到`12`。*
2.  我们从位置`7`到`12`找到中间的项目。在这种情况下，我们可以选择项目`9`或项目`10`。我们要写的算法会选择`9`项，也就是`78`。
3.  我们比较`66`和`78`。由于`66`较小，我们知道如果`66`在列表中，那么*必须在*位置`9`之前，因为数字是按升序排列的。下一步，我们将搜索范围限制在位置`7`到`8`。
4.  我们从位置`7`到`8`找到中间的项目。在这种情况下，我们可以选择项目`7`或项目`8`。我们要写的算法会选择`7`项，也就是`66`。
5.  我们比较`66`和`66`。由于它们是相同的，我们的搜索成功结束，在位置`7`找到了所需的项目。

假设我们正在搜索`70`。搜索将如上所述继续进行，直到我们将`70`与`66`(在位置`7`)进行比较。

*   由于`70`更大，我们知道如果`70`在列表中，那么*必须在*位置`7`之后*，因为数字是升序排列的。下一步，我们将搜索范围限制在`8`到`8`的地点。这只是一个地点。*
*   我们将`70`与`8`项进行比较，即`72`。由于`70`较小，我们知道如果`70`在列表中，那么*必须在*位置`8`之前在*位置。由于它不可能在位置`7`之后*和位置`8`之前*，所以我们断定它不在列表中。*

在搜索的每个阶段，我们将搜索限制在列表的某个部分。让我们使用变量`lo`和`hi`作为定义这一部分的下标。换句话说，我们的搜索将局限于`num[lo]`到`num[hi]`。

最初，我们想要搜索整个列表，因此在本例中，我们将把`lo`设置为`0`，把`hi`设置为`12`。

我们如何找到中项的下标？我们将使用以下计算方法:

```java
       mid = (lo + hi) / 2;
```

因为将执行整数除法，所以分数(如果有的话)将被丢弃。例如，当`lo`为`0`、`hi`为`12`时，`mid`变为`6`；当`lo`为`7`且`hi`为`12`时，`mid`变为`9`；当`lo`为`7`且`hi`为`8`时，`mid`变为`7`。

只要`lo`小于或等于`hi`，它们就定义了要搜索的列表的非空部分。当`lo`等于`hi`时，它们定义了要搜索的单个项目。如果`lo`变得比`hi`大，这意味着我们已经搜索了整个列表，但没有找到该项目。

基于这些想法，我们现在可以编写一个函数`binarySearch`。更一般地说，我们将编写它，以便调用例程可以指定它希望搜索数组的哪个部分来查找该项。

因此，必须给该函数指定要搜索的项(`key`)、数组(`list`)、搜索的开始位置(`lo`)和搜索的结束位置(`hi`)。例如，为了在上面的数组`num`中搜索数字`66`，我们可以发出调用`binarySearch(66, num, 0, 12)`。

这个函数必须告诉我们搜索的结果。如果找到了该项，该函数将返回它的位置。如果没有找到，将返回`-1`。

```java
        public static int binarySearch(int key, int[] list, int lo, int hi) {
        //search for key from list[lo] to list[hi]
        //if found, return its location; otherwise, return -1
           while (lo <= hi) {
              int mid = (lo + hi) / 2;
              if (key == list[mid]) return mid; // found
              if (key < list[mid]) hi = mid - 1;
              else lo = mid + 1;
           }
           return -1; //lo and hi have crossed; key not found
        }
```

如果`item`包含一个要搜索的数字，我们可以编写如下代码:

```java
        int ans = binarySearch(item, num, 0, 12);
        if (ans == -1) System.out.printf("%d not found\n", item);
        else System.out.printf("%d found in location %d\n", item, ans);
```

如果我们想从位置`i`到`j`搜索`item`，我们可以写如下:

```java
        int ans = binarySearch(item, num, i, j);
```

我们可以用程序 P1.5 来测试`binarySearch`。

***程序 p 1.5***

```java
        public class BinarySearchTest {
           public static void main(String[] args) {
              int[] num = {17, 24, 31, 39, 44, 49, 56, 66, 72, 78, 83, 89, 96};
              int n = binarySearch(66, num, 0, 12);
              System.out.printf("%d\n", n);   //will print 7; 66 in pos. 7
              n = binarySearch(66, num, 0, 6);
              System.out.printf("%d\n", n);   //will print -1; 66 not in 0 to 6
              n = binarySearch(70, num, 0, 12);
              System.out.printf("%d\n", n);   //will print -1; 70 not in list
              n = binarySearch(89, num, 5, 12);
              System.out.printf("%d\n", n);   //will print 11; 89 in pos. 11
           } //end main

           // binarySearch goes here
        } //end class BinarySearchTest
```

运行时，该程序将打印以下内容:

```java
7
-1
-1
11
```

1.7 搜索字符串数组

我们可以使用与搜索整数数组相同的技术来搜索字符串的排序数组(比如按字母顺序排列的名称)。主要区别在于数组的声明和使用`String`函数`compareTo`，而不是`==`或`<`，来比较两个字符串。以下是`binarySearch`的字符串版本:

```java
        public static int binarySearch(String key, String[] list, int lo, int hi) {
        //search for key from list[lo] to list[hi]
        //if found, return its location; otherwise, return -1
           while (lo <= hi) {
              int mid = (lo + hi) / 2;
              int cmp = key.compareTo(list[mid]);
              if (cmp == 0) return mid;   // search succeeds
              if (cmp < 0) hi = mid -1;   // key is ‘less than’ list[mid]
              else lo = mid + 1;          // key is ‘greater than’ list[mid]
           }
           return -1; //lo and hi have crossed; key not found
        } //end binarySearch
```

因为我们需要知道一个字符串是等于还是小于另一个，所以最好使用`compareTo`方法。

注意，我们只调用了一次`compareTo`。返回值(`cmp`)告诉了我们需要知道的一切。如果我们在比较单词或名字，并且希望在比较中忽略字母的大小写，我们可以使用`compareToIgnoreCase`。

可以用 P `r`程序 P1.6 测试该功能。

***程序 p 1.6***

```java
    import java.util.*;
    public class BinarySearchString {
       final static int MaxNames = 8;
       public static void main(String[] args) {
          String name[] = {"Charles, Kandice", "Graham, Ariel",
                 "Graham, Ashleigh", "Greaves, Sherrelle", "Perrott, Chloe",
                 "Reyes, Aaliyah", "Reyes, Ayanna", "Seecharan, Anella"};

          int n = binarySearch("Charles, Kandice", name, 0, MaxNames - 1);
          System.out.printf("%d\n", n);
                     //will print 0, location of Charles, Kandice

          n = binarySearch("Reyes, Ayanna", name, 0, MaxNames - 1);
          System.out.printf("%d\n", n);
                     //will print 6, location of Reyes, Ayanna

          n = binarySearch("Perrott, Chloe", name, 0, MaxNames - 1);
          System.out.printf("%d\n", n);
                     //will print 4, location of Perrott, Chloe

          n = binarySearch("Graham, Ariel", name, 4, MaxNames - 1);
          System.out.printf("%d\n", n);
                     //will print -1, since Graham, Ariel is not in locations 4 to 7

          n = binarySearch("Cato, Brittney", name, 0, MaxNames - 1);
          System.out.printf("%d\n", n);
                     //will print -1 since Cato, Brittney is not in the list

       } //end main

       // binarySearch goes here

    } //end class BinarySearchString
```

这将按照字母顺序设置名称数组`name`。然后它用不同的名字调用`binarySearch`并打印每个搜索的结果。

人们可能想知道这样的呼叫会发生什么:

```java
        n = binarySearch("Perrott, Chloe", name, 5, 10);
```

这里，我们告诉`binarySearch`在给定数组的位置`5`到`10`中寻找`"Perrott, Chloe"`。然而，位置`8`到`10`在数组中不存在。搜索的结果将是不可预测的。程序可能会崩溃或返回不正确的结果。确保用有效的参数调用`binarySearch`(或任何其他函数)是调用程序的责任。

1.8 示例:词频统计

让我们写一个程序来阅读一篇英语文章，并统计每个单词出现的次数。输出由单词及其频率的字母列表组成。

我们可以使用以下大纲来开发我们的程序:

```java
        while there is input
           get a word
           search for word
           if word is in the table
              add 1 to its count
           else
              add word to the table
              set its count to 1
           endif
        endwhile
        print table
```

这是典型的“搜索并插入”情况。我们在目前存储的单词中搜索下一个单词。如果搜索成功，唯一要做的就是增加它的计数。如果搜索失败，该单词将被放入表中，并且其计数设置为 1。

这里的一个主要设计决策是如何搜索表，这反过来又取决于新单词在表中的插入位置和插入方式。以下是两种可能性:

1.  在表格的下一个空闲位置插入一个新单词。这意味着必须使用顺序搜索来查找输入的单词，因为这些单词没有任何特定的顺序。这种方法具有简单和易于插入的优点，但是随着更多的单词被放入表中，搜索需要更长的时间。
2.  在表格中插入一个新单词时，单词总是按字母顺序排列。这可能需要移动已经存储的单词，以便可以将新单词插入正确的位置。但是，由于表是有序的，所以可以使用二分搜索法来搜索输入的单词。

对于(2)，搜索速度更快，但插入速度比(1)慢。因为一般来说，搜索比插入更频繁，(2)可能更好。

(2)的另一个优点是，在最后，单词已经按字母顺序排列，不需要排序。如果使用(1)，则需要对单词进行排序，以获得字母顺序。

我们将使用(2)中的方法编写程序。完整的程序如程序 P1.7 所示。

***程序 P1.7***

```java
        import java.io.*;
        import java.util.*;
        public class WordFrequency {
           final static int MaxWords = 50;
           public static void main(String[] args) throws IOException {
              String[] wordList = new String[MaxWords];
              int[] frequency = new int[MaxWords];
              FileReader in = new FileReader("passage.txt");
              PrintWriter out = new PrintWriter(new FileWriter("output.txt"));

              for (int h = 0; h < MaxWords; h++) {
                 frequency[h] = 0;
                 wordList[h] = "";
              }
              int numWords = 0;
              String word = getWord(in).toLowerCase();
              while (!word.equals("")) {
                 int loc = binarySearch(word, wordList, 0, numWords-1);
                 if (word.compareTo(wordList[loc]) == 0) ++frequency[loc]; //word found
                 else //this is a new word
                    if (numWords < MaxWords) { //if table is not full
                       addToList(word, wordList, frequency, loc, numWords-1);
                       ++numWords;
                    }
                    else out.printf("'%s' not added to table\n", word);
                 word = getWord(in).toLowerCase();
              }
              printResults(out, wordList, frequency, numWords);
              in.close();
              out.close();
           } // end main

           public static int binarySearch(String key, String[] list, int lo, int hi){
           //search for key from list[lo] to list[hi]
           //if found, return its location;
           //if not found, return the location in which it should be inserted
           //the calling program will check the location to determine if found
              while (lo <= hi) {
                 int mid = (lo + hi) / 2;
                 int cmp = key.compareTo(list[mid]);
                 if (cmp == 0) return mid;   // search succeeds
                 if (cmp < 0) hi = mid -1;   // key is 'less than' list[mid]
                 else lo = mid + 1;      // key is 'greater than' list[mid]
              }
              return lo; //key must be inserted in location lo
           } //end binarySearch

           public static void addToList(String item, String[] list, int[] freq, int p, int n) {
           //adds item in position list[p]; sets freq[p] to 1
           //shifts list[n] down to list[p] to the right
              for (int h = n; h >= p; h--) {
                 list[h + 1] = list[h];
                 freq[h + 1] = freq[h];
              }
              list[p] = item;
              freq[p] = 1;
           } //end addToList

           public static void printResults(PrintWriter out, String[] list, int freq[], int n) {
              out.printf("\nWords             Frequency\n\n");
              for (int h = 0; h < n; h++)
                 out.printf("%-20s %2d\n", list[h], freq[h]);
           } //end printResults

           public static String getWord(FileReader in) throws IOException {
           //returns the next word found
              final int MaxLen = 255;
              int c, n = 0;
              char[] word = new char[MaxLen];
              // read over non-letters
              while (!Character.isLetter((char) (c = in.read())) && (c != -1)) ;
              //empty while body
              if (c == -1) return ""; //no letter found
              word[n++] = (char) c;
              while (Character.isLetter(c = in.read()))
                 if (n < MaxLen) word[n++] = (char) c;
              return new String(word, 0, n);
           } // end getWord

        } //end class WordFrequency
```

假设以下数据存储在`passage.txt`中:

```java
        Be more concerned with your character than your reputation,
        because your character is what you really are,
        while your reputation is merely what others think you are.
        Our character is what we do when we think no one is looking.
```

当程序 P1.7 运行时，它将其输出存储在`output.txt`中。以下是输出:

```java
        Words             Frequency

        are                   2
        be                    1
        because               1
        character             3
        concerned             1
        do                    1
        is                    4
        looking               1
        merely                1
        more                  1
        no                    1
        one                   1
        others                1
        our                   1
        really                1
        reputation            2
        than                  1
        think                 2
        we                    2
        what                  3
        when                  1
        while                 1
        with                  1
        you                   2
        your                  4
```

以下是对程序 P1.7 的一些评论:

*   出于我们的目的，我们假设一个单词以字母开头，并且只由字母组成。如果您想包含其他字符(如连字符或撇号)，您只需更改`getWord`功能。
*   `MaxWords`表示满足的不同单词的最大数量。为了测试程序，我们使用了`50`作为这个值。如果文章中不同单词的数量超过了`MaxWords`(比如说 50)，那么第 50 个<sup>之后的所有单词都将被读取，但不会被存储，并且会打印一条大意如此的消息。然而，如果再次遇到，已经存储的单词的计数将增加。</sup>
*   `main`将频率计数初始化为`0`并将`String`数组中的项目初始化为空字符串。然后，它根据 1.8 节开头所示的大纲处理文章中的单词。
*   `getWord`读取输入文件并返回找到的下一个单词。
*   所有单词都被转换成小写，例如，`The`和`the`被视为同一个单词。
*   `binarySearch`是这样写的，如果找到这个单词，就返回它的位置。如果没有找到该单词，则返回其应该插入*的位置。函数`addToList`被赋予插入新单词的位置。该位置右侧的单词(包括该位置)将移动一个位置，以便为新单词腾出空间。*

1.9 合并有序列表

合并是将两个或多个有序列表合并成一个有序列表的过程。例如，给定两个数字列表，`A`和`B`，如下所示:

`A: 21 28 35 40 61 75`

`B: 16 25 47 54`

它们可以组合成一个有序列表，C:

`C: 16 21 25 28 35 40 47 54 61 75`

列表`C`包含列表`A`和`B`中的所有数字。如何执行合并？

一种思考方式是想象给定列表中的数字存储在卡片上，每张卡片一个，卡片面朝上放在桌子上，最小的放在顶部。我们可以想象列表`A`和`B`如下:

`21      16`

`28      25`

`35      47`

`40      54`

`61`

`75`

我们看最上面的两张卡，`21`和`16`。较小的`16`被移除并放置在`C`中。这就暴露了`25`这个数字。

现在最上面的两张卡是`21`和`25`。较小的`21`被移除并添加到`C`，?? 现在包含了`16 21`。这就暴露了数字`28`。

现在最上面的两张卡是`28`和`25`。较小的`25`被移除并添加到`C`，?? 现在包含了`16 21 25`。这就暴露了数字`47`。

现在最上面的两张卡是`28`和`47`。较小的`28`被移除并添加到`C`，?? 现在包含了`16 21 25 28`。这就暴露了数字`35`。

现在最上面的两张卡是`35`和`47`。较小的`35`被移除并添加到`C`，?? 现在包含了`16 21 25 28 35`。这就暴露了数字`40`。

现在最上面的两张卡是`40`和`47`。较小的`40`被移除并添加到`C`，?? 现在包含了`16 21 25 28 35 40`。这就暴露了数字`61`。

现在最上面的两张卡是`61`和`47`。较小的`47`被移除并添加到`C`，?? 现在包含了`16 21 25 28 35 40 47`。这就暴露了数字`54`。

现在最上面的两张卡是`61`和`54`。较小的`54`被移除并添加到`C`，?? 现在包含了`16 21 25 28 35 40 47 54`。列表`B`没有更多数字。

我们将`A`的剩余元素(`61 75`)复制到`C`，现在包含以下内容:

`16 21 25 28 35 40 47 54 61 75`

合并已完成。

在合并的每一步，我们将最小剩余数`A`与最小剩余数`B`进行比较。其中较小的被添加到`C`。如果较小的数字来自于`A`，我们继续前进到`A`的下一个数字；如果较小的数字来自`B`，我们将继续处理`B`中的下一个数字。

重复这一过程，直到使用完`A`或`B`中的所有号码。如果`A`中的所有号码都已被使用，我们将从`B`到`C`的剩余号码相加。如果`B`中的所有数字都已被使用，我们将从`A`到`C`的剩余数字相加。

我们可以将合并的逻辑表达如下:

```java
        while (at least one number remains in both A and B) {
           if (smallest in A < smallest in B)
              add smallest in A to C
              move on to next number in A
           else
              add smallest in B to C
              move on to next number in B
           endif
        }
        if (A has ended) add remaining numbers in B to C
        else add remaining numbers in A to C
```

1.9.1 实现合并

假设数组`A`包含存储在`A[0]`到`A[m-1]`中的 *m 个*数，数组`B`包含存储在`B[0]`到`B[n-1]`中的 *n 个*数。假设数字按升序存储。我们希望将`A`和`B`中的数字合并到另一个数组`C`中，这样`C[0]`到`C[m+n-1]`就包含了`A`和`B`中按升序排序的所有数字。

我们将使用整数变量`i`、`j`和`k`来分别下标数组`A`、`B`和`C`。在数组中“移动到下一个位置”可以通过给下标变量加上`1`来完成。我们可以用这个函数实现合并:

```java
        public static int merge(int[] A, int m, int[] B, int n, int[] C) {
           int i = 0;  //i points to the first (smallest) number in A
           int j = 0;  //j points to the first (smallest) number in B
           int k = -1; //k will be incremented before storing a number in C[k]
           while (i < m && j < n) {
              if (A[i] < B[j]) C[++k] = A[i++];
              else C[++k] = B[j++];
           }
           if (i == m) ///copy B[j] to B[n-1] to C
              for ( ; j < n; j++) C[++k] = B[j];
           else // j == n, copy A[i] to A[m-1] to C
              for ( ; i < m; i++) C[++k] = A[i];
           return m + n;
        } //end merge
```

该函数接受参数`A`、`m`、`B`、`n`和`C`，执行合并，并返回`C`中的元素数量`m + n`。

程序 P1.8 显示了一个简单的`main`函数，用于测试`merge`的逻辑。它设置数组`A`和`B`，调用`merge`，打印`C`。运行时，该程序打印以下内容:

```java
        16 21 25 28 35 40 47 54 61 75

```

***程序 P1.8***

```java
        public class MergeTest {
           public static void main(String[] args) {
              int[] A = {21, 28, 35, 40, 61, 75};   //size 6
              int[] B = {16, 25, 47, 54};      //size 4
              int[] C = new int[20];   //enough to hold all the elements
              int n = merge(A, 6, B, 4, C);
              for (int j = 0; j < n; j++) System.out.printf("%d ", C[j]);
              System.out.printf("\n");
           } //end main

           // merge goes here

        } //end class MergeTest
```

有趣的是，我们也可以如下实现`merge`:

```java
        public static int merge(int[] A, int m, int[] B, int n, int[] C) {
           int i = 0;  //i points to the first (smallest) number in A
           int j = 0;  //j points to the first (smallest) number in B
           int k = -1; //k will be incremented before storing a number in C[k]
           while (i < m || j < n) {
              if (i == m) C[++k] = B[j++];
              else if (j == n) C[++k] = A[i++];
              else if (A[i] < B[j]) C[++k] = A[i++];
              else C[++k] = B[j++];
           }
           return m + n;
        }
```

`while`循环表达了以下逻辑:只要在`A` *或* `B`中至少有一个元素要处理，我们就进入循环。如果我们完成了`A` ( `i == m`，从`B`到`C`复制一个元素。如果我们完成了`B` ( `j == n`)，将一个元素从`A`复制到`C`。否则，将`A[i]`和`B[j]`中较小的一个复制到`C`。每当我们从一个数组中复制一个元素，我们就给这个数组的下标加 1。

虽然以前的版本以一种简单的方式实现了合并，但是说这个版本更简洁似乎是合理的。

**练习 1**

1.  A survey of 10 pop artists is made. Each person votes for an artist by specifying the number of the artist (a value from 1 to 10). Each voter is allowed one vote for the artist of their choice. The vote is recorded as a number from `1` to `10`. The number of voters is unknown beforehand, but the votes are terminated by a vote of `0`. Any vote that is not a number from `1` to `10` is a spoiled vote. A file, `votes.txt`, contains the names of the candidates. The first name is considered as candidate 1, the second as candidate 2, and so on. The names are followed by the votes. Write a program to read the data and evaluate the results of the survey.

    按艺术家姓名的字母顺序和收到的票数顺序打印结果(票数最多者优先)。打印所有输出到文件，`results.txt`。

2.  写一个程序将名字和电话号码读入两个数组。询问对方的姓名，并打印出他的电话号码。使用二分搜索法查找该名称。
3.  写一个程序，把英语单词和它们对应的西班牙语单词读入两个数组。要求用户键入几个英语单词。对于每一项，打印相应的西班牙语单词。选择合适的数据结束标记。使用二分搜索法搜索键入的单词。修改程序，让用户键入西班牙语单词。
4.  一组 *n 个*数(不一定是截然不同的)的*中位数*是将数按顺序排列，取中间的数得到的。如果 *n* 是奇数，则有一个唯一的中间数。如果 *n* 是偶数，那么两个中间值的平均值就是中位数。写程序读取一组 *n* 正整数(假设*n*100)并打印它们的中位数； *n* 未给出，但`0`表示数据结束。
5.  一组 *n* 数字的*模式*是出现频率最高的数字。比如`7 3 8 5 7 3 1 3 4 8 9`的模式是`3`。写程序读取一组 *n* 正整数(假设*n*100)并打印出它们的模式； *n* 未给出，但`0`表示数据结束。
6.  数组`chosen`包含`n`个不按特定顺序排列的不同整数。另一个名为`winners`的数组包含按照*升序*排列的`m`个不同的整数。编写代码来确定`chosen`中有多少个数字出现在`winners`中。
7.  A multiple-choice examination consists of 20 questions. Each question has five choices, labeled A, B, C, D, and E. The first line of data contains the correct answers to the 20 questions in the first 20 *consecutive* character positions, for example:

    BECDCBAADEBACBAEDDBE

    随后的每一行都包含候选人的答案。一行中的数据由一个候选数字(一个整数)组成，后面是一个或多个空格，再后面是候选人在接下来的 20 个*连续*字符位置给出的 20 个答案。如果候选人没有回答特定的问题，则使用 X。您可以假设所有数据都是有效的，并存储在文件`exam.dat`中。示例行如下:

    4325 BECDCBAXDEBACCAEDXBE

    最多有 100 名候选人。包含“候选编号”`0`的行仅表示数据的结束。

    一个问题的分值授予如下—正确答案:4 分；回答错误:-1 分；没有回答:0 分。

    编写一个程序来处理数据，并打印一份报告，该报告由候选人编号和候选人获得的总分数组成，按候选人编号升序排列。最后，打印候选人获得的平均分数。

8.  `A`是按降序排序的数组。`B`是一个降序排列的数组。将`A`和`B`合并成`C`，使`C`按照*递减*的顺序。
9.  `A`是按降序排序的数组。`B`是一个降序排列的数组。将`A`和`B`合并为`C`，使`C`按照*升序*排列。
10.  `A`是按升序排序的数组。`B`是一个降序排列的数组。将`A`和`B`合并为`C`，使`C`按照*升序*排列。
11.  An array A contains integers that first increase in value and then decrease in value. Here’s an example:

    ![9781430266198_unFig01-21.jpg](img/9781430266198_unFig01-21.jpg)

    不知道从哪一点开始数量开始减少。编写高效的代码将 A 中的数字复制到另一个数组 B 中，使 B 按升序排序。您的代码必须利用数字在。

12.  Two words are anagrams if one word can be formed by rearranging all the letters of the other word, for example: section, notices. Write a program to read two words and determine whether they are anagrams.

    编写另一个程序来读取单词列表并找到所有单词集合，使得一个集合中的单词是彼此的变位词。*