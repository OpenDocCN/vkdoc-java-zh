# 八、DC 电机控制器

在这一章中，我们将根据您在前面章节中所学的知识开发一个基于 diozero 的设备库。我选择了一个机器人常用的设备，一个 DC 电机控制器，更确切地说，是一个通过串行 I/O 访问的设备。也就是说，本章涵盖了适用于使用*任何*形式的基本 I/O 为*任何*类型的设备开发设备库的主题，从而为后面的章节建立了重要的背景。所以，你至少应该浏览一下这一章，即使你的项目不针对机器人，不使用本章所考察的电机控制器，不使用电机控制器，或者不使用串行设备。

具体来说，在本章中，您将学习

*   当存在多个候选设备时，如何选择要移植的设备库

*   移植现有设备库的一些通用指南

*   如何使用*深度优先*的方法逐步移植设备库

*   如何使用 diozero 串行 I/O 支持

*   帮助您了解设备和移植库的其他活动

## 选择设备

假设您的项目需要一个 DC 电机控制器。从简单的 H 桥到实现复杂 PID 电机控制算法的高端器件，您可以找到各种各样的控制器。一如既往，项目的最佳选择是满足项目功能和成本需求的选择。在这一章中，我们将看看我用来建造自主漫游车的 DC 电机控制器。 <sup>[1](#Fn1)</sup> 我选择了一个高端的控制器，来自 Basicmicro ( [`www.basicmicro.com/RoboClaw-2x15A-Motor-Controller_p_10.html`](http://www.basicmicro.com/RoboClaw-2x15A-Motor-Controller_p_10.html) )的 RoboClaw 2x15A 电机控制器。在本章中使用它有几个原因:

*   它的功能卸载了树莓派的工作，将更多的 CPU 周期用于计算任务和任务协调。

*   我发现它是一个优秀的运动控制器。

*   Basicmicro 的技术支持非常好。

*   它支持 USB 接口，因此您可以体验 diozero 串行 I/O 支持。

*   这个特定控制器的设备库应该适用于 RoboClaw 控制器系列。

*   这是我在第 [1](01.html) 章提出的设备库匮乏的反例。

*   这是一个复杂的设备，需要多管齐下的方法来移植设备库。

在本书中，我不会过多地描述 RoboClaw 或者如何使用它来帮助设计、实现和测试设备库。

## 了解设备

我强调过，你必须了解你的设备。当然，在为项目选择设备时，您必须在一定程度上了解设备的功能。您可能已经浏览了数据手册甚至用户手册来帮助做出选择，但可能更关注设备功能而不是如何使用这些功能。然而，即使你不必为它移植或创建库，你仍然必须很好地理解设备*才能正确地使用它*。我建议您在寻找现有器件库之前，尤其是在从头开始编写器件库之前，阅读并吸收所有数据手册、用户手册、应用笔记等。，你可以找到。这在复杂设备的情况下尤其重要，在这种情况下，你可能会跳过“无聊”但关键的细节，因为，正如一些智者所说，“魔鬼在细节中。”**

 **RoboClaw 是这句格言的一个很好的例子。我声称机器人法律是一个复杂的装置。以下是一些证据:

*   数据表长达 16 页。请参见产品网页上的*下载*选项卡(如前所述)。

*   用户手册长达 101 页，描述了 130 多条命令。请参见产品网页上的*下载*选项卡。

**用户手册**中的几个章节有助于您识别一些对理解该设备非常重要的“魔鬼细节”:

*   *USB 控制*部分:您必须在“数据包串行”模式下运行设备。不需要担心找不到树莓派 OS 的底层设备驱动。你不需要设置波特率；USB 连接将尽可能快地运行。

*   *包序列*部分:“基本命令结构由地址字节、命令字节、数据字节和 CRC16 16 位校验和组成。”对于 USB 连接，地址字节可以是 0x 80–0x 87，因为 USB 连接是唯一的(这消除了所谓的*多单元包串行*模式)。该部分包含有关数据包超时、只写命令的数据包确认、CRC 计算、<sup>T5】2</sup>以及处理数据类型长度的附加信息。它还包含关于最基本命令的信息。

*   *高级分组串行、编码器、高级电机控制*部分:这些包含命令的详细数据要求。您应该浏览这些部分，主要是为了了解一些现有的库代码的复杂性，尤其是围绕单个命令中的多种数据类型。

*   *高级电机控制*:相关的命令描述解释了命令缓冲是如何操作的，这是 RoboClaw 的一个重要但未得到充分重视的功能。

充分掌握设备功能及其 I/O 要求将有助于您理解可能使用或移植的设备库，有助于您在必要时开发自己的库，并有助于您在任何情况下确定合适的设备库接口。

## 查找设备库

为了找到要使用或移植的设备库，我将遵循第 [6](06.html) 章中概述的过程。

### 搜索 Java 库

首先，看看 diozero 设备库。在撰写本文时，diozero 文档和 Javadoc 描述了一些支持 PWM 驱动的 DC 电机和伺服系统的接口和具体实现。跟机器人法律没什么关系。

接下来结合 RoboClaw 搜索其他树莓派串行 I/O Java 库。在撰写本文时，我一无所获。

接下来搜索 RoboClaw 和 Java。那次搜索产生了一些值得考虑的结果:

*   snackbot ( [`https://github.com/jarney/snackbot/blob/master/src/main/java/org/ensor/robots/roboclawdriver/RoboClaw.java`](https://github.com/jarney/snackbot/blob/master/src/main/java/org/ensor/robots/roboclawdriver/RoboClaw.java) ):设备库似乎只是部分完整，而且至少有六年历史了。它被嵌入到一个更大的框架中，尽管可能需要大量的工作才能提取出来。包括*批次*的班级；例如，每个实现的命令都有一个类(不是所有的都有)。有可能，但肯定不理想。

*   myrobotlab ( [`https://github.com/MyRobotLab/myrobotlab/blob/develop/src/main/java/org/myrobotlab/service/RoboClaw.java`](https://github.com/MyRobotLab/myrobotlab/blob/develop/src/main/java/org/myrobotlab/service/RoboClaw.java) ):设备库看起来既完整又是最新的。它也嵌入在一个更大的框架中；试图提取它可能会适得其反。在很大程度上，它看起来结构良好。我认为这是比 snackbot 更好的起点。

*   project-capo ( [`https://github.com/project-capo/amber-java-clients/blob/master/amber-java-roboclaw/src/main/java/pl/edu/agh/amber/roboclaw/RoboclawProxy.java`](https://github.com/project-capo/amber-java-clients/blob/master/amber-java-roboclaw/src/main/java/pl/edu/agh/amber/roboclaw/RoboclawProxy.java) ):设备库似乎不完整；有些课我找不到。它至少有五年了。可能不是一个好的起点。

在这三个热门作品中，似乎只有 myrobotlab 值得考虑。唯一显著的缺点是拖着整个框架，这无疑包括不需要的功能。我个人不倾向于引入大量几乎肯定不会被使用的额外内容。因此，我至少会在检查完非 Java 库之后再做决定。

### 搜索非 Java 库

当你查看 RoboClaw 产品页面上的**下载**选项卡时(链接在本章的顶部)，你会发现*有五个不同编程语言的*设备库(或驱动程序):

*   *Python* 用于树莓派操作系统和其他平台

*   *Python* 用于机器人操作系统(ROS)

*   *C#* 用于 Windows

*   用于 Arduino 的 *C++*

*   用于 LabVIEW 的*【G】*

您如何选择一个(或多个)来播种您的移植工作呢？如果你对一种语言的了解远胜于其他语言，那通常是最好的选择。如果不是这样，你必须评估所有的库来选择。这就是我要做的。在这样做的同时，我将提出一些具体的问题，您可以将这些问题推广到其他语言和其他设备。

我从简单的开始。据我所知,“G”LabVIEW 驱动程序下载只包含可执行文件，没有源代码；这使得它对移植毫无用处。ROS 的 Python 库似乎是由与 Basicmicro 无关的人编写的；至少四年没有更新；简单看一下它就知道它和树莓派 OS 的 Python 库没有太大区别，后者来自 Basicmicro 并受支持。因此，ROS Python 库不是一个好的候选。

#### 看看 C#库

我有些懊恼地承认，我从未用过 C#。快速浏览一下我下载的源代码(见文件`Roboclaw.cs`)可以看出，C#展示了 C 血统，但具有 Java 的一些特征。可以理解，它有一些我不完全理解的“视窗主义”，但我认为可以安全地忽略，尽管它们确实使代码更难理解。

该文件包括一个定义命令常量的`Commands`类；它似乎很容易被复制到 Java 类中；很好，除了它包括明显用于其他 Basicmicro 设备的命令，所以要小心。该文件包含一个`SerialPort`类，该类定义了一些用于读写字节的*低级*方法。低级方法似乎与第 [7](07.html) 章中描述的 diozero `SerialDevice`的方法相似。

`Roboclaw.cs`文件当然包括了`Roboclaw`类，它扩展了`SerialPort`。现在事情变得有趣了。该类定义了三个*中级*方法`ReadLenCmd`、`ReadCmd`和`Write_CRC`，处理命令中的多种数据类型，进行 CRC 生成和验证，并使用低级方法与设备交互。最后，`Roboclaw`定义了与设备命令对应的*接口级*方法；使用设备库的应用程序调用接口级方法。绝大多数接口级方法使用中间层方法；一种是使用低级方法(接口级方法获得 RoboClaw 固件版本，机器人程序不太可能对此感兴趣)。

通过搜索`Roboclaw`源代码中的中级命令，可以确定只有四个接口级方法调用`ReadLenCmd`，而在 RoboClaw **用户手册**中没有一个！这是因为`Roboclaw`类支持广泛的 Basicmicro 设备。从根本上说，这意味着你只需要担心如何移植`ReadCmd`和`Write_CRC`来支持 RoboClaw 2x15A。

综上所述，C# `Roboclaw`类展现了*三层*:

*   用于基本串行通信的*低级*方法；这是你插入 diozero `SerialDevice`当量的地方。

*   处理字节数组和多字节数据类型之间转换的*中间层*方法`ReadCmd`和`Write_CRC`；两者都需要移植。

*   实现 RoboClaw 命令的*接口级*方法；您可以根据项目需要实现任意多的功能，并在以后添加更多功能。

所以，C#库看起来是一个很好的移植候选。然而，可怕的细节再次出现。`ReadCmd`方法的签名包含一个 C# `ref`。当像`GetM1Encoder`这样的方法调用`ReadCmd`时，前者必须将参数从原始形式(例如 Java `int`)转换为对象(例如 Java `Integer`，或者更类似的`Object`)，并将它们添加到`ArrayList`。`ReadCmd`检查列表中每个参数的类型，以确定字节长度。虽然这是一个优雅的设计，实现起来也相当简单，但看起来开销很大，对性能有潜在的显著影响。对于 Windows 机器来说，这可能是一个合理的权衡，因为 Windows 机器的性能可能是树莓派的许多倍。

Note

我在 C#设备库下载中找不到使用示例。你可以通过更广泛的搜索找到一些。

#### 看看 C++库

C++库(文件`RoboClaw.cpp`)当然包含一些 Arduino-ism。和 C#库一样，有*三层*。有类似 diozero `SerialDevice`提供的低级方法。有一些中级方法(`write_n`、`read_n`)处理 CRC 生成和验证，并使用低级方法向设备发送或从设备接收字节数组。还有另外一些处理特定数据交换模式的中级方法(`Read1`、`Read2`、`Read4`、`Read4_1`)。对应于 RoboClaw 命令的接口级方法使用中级方法。中级方法`write_n`和`read_n`多次使用。`Read1`使用 1 次，`Read2`使用 8 次，`Read4`使用 12 次，`Read4_1`使用 6 次。

C++架构与 C#架构基本相同，但实现方式不同。中层表现出更多的专业化，因而方法也更多。但是 C++中间层把一些数据类型的工作推到了接口层；接口级方法可以负责转换数据类型，例如，将 32 位整数转换为 4 个字节的列表。

总之，C++ `RoboClaw`类还展示了*三层*:

*   用于基本串行通信的*低级*方法，您可以插入 diozero `SerialDevice`等效物。

*   *中层*方法`write_n`、`read_n`、`Read1`、`Read2`、`Read4`和`Read4_1`，用于写入或读取一个字节数组，并用于处理特定的数据交换模式；除了`Read1`之外，所有都需要移植。

*   实现 RoboClaw 命令的*接口级*方法；您可以根据项目需要实现任意多的功能，并在以后添加更多功能。

所以，C++库看起来也是一个很好的移植对象。整体设计不如 C#优雅。您可能需要编写比 C#更多的代码。不过我觉得，性能会更好，内存要求会更低(周围不会有一堆参数对象)。也就是说，串行通信相当慢的性能可能使这种差异可以忽略不计。

Note

C++下载包括几个例子，可以帮助你理解甚至实验 RoboClaw。当然，您必须将 RoboClaw 连接到 Arduino 才能使用这些示例。

#### Python 库一览

树莓派的 Python 下载包含 Python2 和 Python3 的代码。我只讨论后者。

Python 库(文件`roboclaw_3.py`)在架构上类似于 C#和 C++库，因为有三层*，低级、中级和接口级。接口级的实现与其他两个库的实现类似，因为接口级方法使用中间层方法。但是其他两个层次的相似性充其量也是微不足道的；由于与 Python 的数据处理有关的原因，下面两层的实现似乎由有符号数据和无符号数据主导。大致有九种低级方法来处理数据的字节长度和符号。中间层实现了 30 多种方法来处理不同的数据模式，以及数据是有符号的还是无符号的。*

 *考虑到这种额外的复杂性似乎不适用于继承了 C 语言的语言，Python 库似乎不是移植的好选择。

Note

Python 下载包括几个例子，可以帮助您理解甚至试验 RoboClaw。尽管不建议移植，但您可以加载库并运行示例，因为您已经需要将 RoboClaw 连接到您的 Raspberry Pi。

### 答案是…

在我看来

*   来自 myrobotlab 的 Java 库是一个可接受的移植候选库**。**

***   C#库是一个很好的**移植候选。**

    ***   C++库是一个很好的**移植候选。**

    ***   Python3 库是一个 ***坏*** 的移植候选。****** 

 ****Java 库拖了很多框架。除了很少的附加值(从我的角度来看)，我担心框架引入的额外复杂性会导致性能问题。

C#和 C++库展示了相同的架构。我认为 C#实现更优雅，实现起来更简单。我认为 C++实现提供了更高的性能和更低的内存消耗，尽管它可能需要更多的编码。

虽然您可能会得出不同的结论，但基于性能和对 C++的进一步熟悉，我选择 C++库作为主要库，为 RoboClaw 的 Java 设备库的开发埋下种子。当然，您并不局限于只利用一个库，事实上，我还将使用 C#库的某些方面。

本章的其余部分描述了使用 diozero `SerialDevice`作为底层的移植过程。在继续之前，如有必要，您应该回顾一下第 [7 章](07.html)中的材料，其中涵盖了树莓派串行 I/O 功能和广泛的 diozero 串行设备支持。

## 移植问题

确定了要移植的设备库之后，您现在应该考虑一下从任何语言移植时出现的一些一般性问题，以及从 C/C++移植时出现的一些问题。

### 设备库接口

一个非常重要的问题是你的 Java 设备库公开的接口*。有三个相互关联的方面需要考虑:*

*   *来源*指的是什么界面模型引导你的界面。

*   *范围*指的是你的接口暴露了多少设备功能。一个设备可以做的比您的项目需要的更多。

*   *粒度*指的是在对接口的单次调用中完成了多少功能或任务。

可能有许多来源来指导您的接口定义，但我认为最重要的是

*   设备本身

*   现有的设备库

*   您的要求

我的经验表明，第一个和第二个来源通常是一致的。换句话说，设备库接口公开了设备本身公开的相同接口，至少在很大程度上是这样。因此，它们具有相同的范围(通常是一切)和相同的粒度。这是有意义的，因为现有设备库的开发人员非常积极地做尽可能少的工作，以尽可能多的灵活性公开尽可能多的功能，当然，开发人员不能知道*您的*需求。

对于第一个和第二个来源的广泛概括，有时也有例外。有时设备接口过于精细，例如，您必须写入多个寄存器才能完成一项任务。在这种情况下，设备库可能会隐藏设备本身的一些细节，并公开一个更大粒度的接口，从而减少库用户的“繁忙工作”。有时，现有设备库的开发人员变得“懒惰”,公开了设备功能的子集。

第三个来源做出了合理的假设，即您头脑中有某种接口来表示您需要的功能，而不依赖于提供这些功能的特定设备。我断言，在大多数情况下，你的*理想*接口将比设备或现有设备库的接口粒度更大。在某些情况下，甚至可能是大多数情况下，您的接口范围会更小。

那么，你是如何进行的呢？在我看来，如果你找到一个现有的设备库来移植，它应该是你的库接口的主要指南。显然，如果您只需要设备功能的一个子集(根据您的需求)，您可能需要对其进行子集化。您可以做一些合理的小调整来降低粒度。当您发现缺少所需的功能时，您可能需要扩展接口。但是总的来说，模仿一个现有的接口并在背后实现它会导致更少的开发时间和更灵活的结果。如果您需要一个更大粒度的接口，您可以根据您的需求在移植的接口之上创建一个包装器。

如果您没有找到值得移植的现有库，适当的指导就不太清楚了。如果您只希望在一个项目中使用该设备，那么最好的来源可能就是您的需求。如果您希望在许多项目中使用该设备，灵活性可能是有益的，并且该设备本身可能是最佳来源。您的里程可能会有所不同！

对于 RoboClaw，存在合理的设备库，因此将它们用作模型是有意义的。对于 130 多个命令，似乎只需要设备功能的一个子集，所以新库将只实现现有库的一个子集。由于 RoboClaw 如此复杂，新接口的粒度将与现有的库相同。

一个相关的问题是是否将库接口与接口的实现分开。分离的主要动机是您是否计划拥有几个接口的“提供者”。通常答案是“不”，但你的项目可能不同。

### 设备实例

您的设备库应该只支持设备的一个实例还是多个实例？一个实例是只被一个线程使用还是被多个线程共享？正如在第 7 章中提到的，这个问题迫使我们考虑 Java 并发性，这个主题超出了本书的范围。

在机器人法律的背景下，四轮驱动机器人显然需要*两个*装置，六轮驱动机器人需要*三个*装置。因此，一个项目中可以存在该设备的多个实例。如果使用多单元模式，可以通过单个串行连接向多个设备发送命令(参见**用户手册**中的*多单元包串行布线*部分)；这说明了 C++库的接口级方法中的地址参数。相反，C#库不允许在接口级方法中使用地址参数，所以它不支持多单元模式。在任何情况下，期望使用 RoboClaw USB 连接，它消除了多单元模式，导致每个设备一个库(类)实例。树莓派操作系统防止多个*进程*共享一个设备。我找不到一个合理的理由来允许多个线程使用一个库实例，所以并发应该是没有实际意义的。

第 7 章讨论了一个关于同一个 USB 设备的多个实例的有趣难题。仅使用 *USB 设备标识*，不可能区分一个机器人法律的多个实例；例如，您必须能够区分前轮控制器和后轮控制器。那么，如何区分两种不同的 RoboClaws 呢？**用户手册**指出，当通过 USB 连接时，RoboClaw 可以响应地址 0x 80–0x 87。使用 Basicmicro *Motion Studio* 配置工具设置机器人法律响应的地址(参见**用户手册**)。我通过测试确定，并得到 Basicmicro 技术支持部门的确认，当你通过 USB 向错误的地址发送命令时，RoboClaw 只是*没有响应*。因此，您必须小心尝试读取任何预期的响应，因为 diozero `SerialDevice`只实现无超时的阻塞读取。这很重要，因为设备库应该提供一种方法来验证连接到特定 USB 端口的 RoboClaw 的*设备实例 ID* ，实现第 [7](07.html) 章中提到的身份验证的第二阶段。

### 逐字与清洗端口

一个有趣的问题是你对移植的代码做了什么和多少自愿的修改。这个问题有几个方面。

考虑命名。你是否尽可能使用常量名、变量名、方法名等。，还是“净化”它们？清理可以像遵循 Java 命名约定一样简单。或者，它可能会更改名称，以便对您或您的设备库的其他用户更友好。

考虑设计变更。您是否尽可能地维护现有的设计，或者在可能的情况下增强它，也许是为了提高性能，或者更像 Java？

在 RoboClaw 的上下文中，由于需要生成一个 CRC，`RoboClaw.cpp`中的一些中级方法向 CRC 添加一个字节，然后写入该字节，然后对其他字节重复。该设计中显然存在可避免的开销。对于这种情况，我试图遵循很久以前给我的建议:“首先让它工作，然后让它快速工作。”

还有其他例子。注意，`Roboclaw.cs`和`RoboClaw.cpp`都没有引入“数据类”来处理参数或返回的数据，这种做法在 Java 中很常见。我相信原因是 C#和 C++都允许指针或引用原始类型，这在 Java 中是不可能的。例如，当`RoboClaw.cpp`中的一个方法需要返回多个原始类型的变量时，它可以使用指向这些变量的指针来完成。如果要返回的变量都是同一类型，在 Java 中你可以使用一个数组；如果它们不是同一类型，在 Java 中你有两个选择:你可以使用多个数组，或者你可以定义一个新的类。

`RoboClaw.cpp`中的大多数接口级方法和`Roboclaw.cs`中的所有方法都返回一个布尔值，指示设备读写操作的成功或失败。这当然消除了通过参数以外的方式返回数据的能力。在典型的 Java 库中，异常被用来代替状态返回，使得返回数据成为可能(尽管只是一个基本类型、一个数组或一个数据类)。

对于这个问题，很明显，除了基本需求之外，您所做的任何事情都会增加完成 Java 移植所需的工作和时间。但是，正如我前面所暗示的，有时“清理”或“增强”现有的库是有益的，尤其是如果您可以验证性能优势，期望其他人使用该库，或者如果您期望在长时间内在多个项目中使用该库。只有你能决定什么对你的项目是正确的。

### 移植方法

我想讨论一些设备库的开发理念(以及其他开发活动)。我认为有两种基本方法:*广度优先*和*深度优先*。广度优先意味着一旦你完成了界面分析，你就“开始行动”应用于前面描述的 RoboClaw 库，首先实现构造器。然后实现底层方法(当 diozero 功能不匹配时，根据需要进行增强)。然后实现中级方法。然后实现必要的接口级方法。然后你开始调试整个事情。

深度优先意味着您对接口做更多的分析，以识别一两个“简单的”接口级方法以及它们需要的中级和低级方法。然后实现我称之为*核心*的东西，它指的是用深度优先的方法支持有意义测试的最少代码。这意味着构造器和所选接口级方法的“调用栈”。然后你开始调试。一旦核心工作，你可以选择更多的接口级方法并重复。

广度优先的优势是能够在任何层面上更加整体化；因此，你可能会减少设计上的调整。另一方面，如果你犯了一个错误，你可能直到你写了很多代码才发现它。深度优先的优势在于缩小了初始编码的范围，并且可以更快地找到工作代码。另一方面，您可能会发现，当您处理下一个“调用栈”时，您必须做比广度优先更多的调整。

我一般更喜欢深度优先，但移植时尤其喜欢深度优先。这种方法的渐进本质使得它更容易实现早期成功(一个巨大的心理提升)，测试处理语言差异的技术，以及验证设计决策。在最初的成功之后，我有时会先做深度，有时会先做广度。

当然，您不必严格遵循这两种方法中的任何一种。变化是可行的，而且可能更好。

## 玩设备

我需要提到一个活动，无论是移植现有的设备库还是从头开始开发设备库，它都适用—*用设备玩*。玩，我的意思是忽略正式的开发步骤，只与设备交互，给你继续正式开发的信心。当使用不熟悉的基本 I/O 形式时，Playing 特别有用。

为了播放，该设备必须提供一些非常简单的功能，例如，读取一个已知值，无需大量配置等。，以启用它。您不需要为诸如命令、寄存器等工件定义形式常量。您不必担心类、变量等的好名字。您可能只在主类中编写了几行代码。

你可以在任何时候玩，只要你对这个设备有足够的了解。这通常意味着在您阅读了部分或全部相关文档之后。所以，你可以在寻找现有设备库之前，在做接口分析之前，或者在开始库开发之前玩。在某些情况下，甚至在您开始库开发之后，您可能还会玩，尽管这通常是为了玩复杂的东西而不是简单的东西。

如果你看看机器人法律的材料，你可能会意识到它并不适合玩。CRC 的存在消除了任何非常简单的交互。所以，很遗憾，我们将不得不开始正式开发。然而，我们将能够使用后面章节中用到的设备。

## 设备库开发

如何开始构建新的设备库？我建议首先选择接口级命令。研究**用户手册**以确定你需要什么命令来满足你的项目需求。

表 [8-1](#Tab1) 显示了我将执行的命令的名称和代码(均来自**用户手册**)，以及`RoboClaw.cpp`中使用的相应方法名称。列出的命令是我在我的自主漫游车中使用的命令；如你所见，我只用了 130+条命令中的 12 条！

表 8-1

使用的 RoboClaw 命令

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

命令名称

 | 

密码

 | 

方法名

 |
| --- | --- | --- |
| 设定速度 PID 常量 M1 | Twenty-eight | `SetM1VelocityPID` |
| 设定速度 PID 常量 M2 | Twenty-nine | `SetM2VelocityPID` |
| 读取电机 1 速度 PID 和 QPPS 设置 | Fifty-five | `ReadM1VelocityPID` |
| 读取电机 2 速度 PID 和 QPPS 设置 | fifty-six | `ReadM2VelocityPID` |
| 带符号速度、加速度和距离的缓冲驱动 M1 / M2 | Forty-six | `SpeedAccelDistanceM1M2` |
| 以标示的速度驾驶 M1 / M2 | Thirty-seven | `SpeedM1M2` |
| 以指定的速度和加速度驾驶 M1 / M2 | Forty | `SpeedAccelM1M2` |
| 带符号速度和距离的缓冲驱动 M1 / M2 | Forty-three | `SpeedDistanceM1M2` |
| 读取编码器计数/值 M1 | Sixteen | `ReadEncM1` |
| 读取编码器计数器 | seventy-eight | `ReadEncoders` |
| 重置正交编码器计数器 | Twenty | `ResetEncoders` |
| 读取主电池电压水平 | Twenty-four | `ReadMainBatteryVoltage` |

接下来，您应该确定由接口级方法调用的中级(和低级，如果适用的话)方法。表 [8-2](#Tab2) 显示了表 [8-1](#Tab1) 中所列命令的中级方法。表 [8-2](#Tab2) 中的结果相当有趣。这 12 个命令只需要 4 个中级方法！接受小的性能下降允许你通过使用`ReadEncoders`而不是`ReadEncM1`来消除`Read4_1`的使用。如果你愿意放弃知道主电池电压，你也可以取消使用`Read_2`。

表 8-2

接口级方法(命令)调用的 RoboClaw.cpp 中级方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

中级方法

 | 

界面级方法

 |
| --- | --- |
| `write_n` | `SetM1VelocityPID, SetM2VelocityPID, SpeedAccelDistanceM1M2, SpeedM1M2, SpeedAccelM1M2, SpeedDistanceM1M2, ResetEncoders` |
| `read_n` | `ReadM1VelocityPID, ReadM2VelocityPID, ReadEncoders` |
| `Read4_1` | `ReadEncM1` |
| `Read_2` | `ReadMainBatteryVoltage` |

在我看来，掉`ReadEncM1`是可以接受的。如果出现性能问题，您可以稍后实现它。然而，这里有一个微妙的权衡。编码器计数是 32 位*无符号*值。`ReadEncM1`除了计数之外还返回一个状态字节；状态表示计数的符号。`ReadEncoders`不返回任何状态，因此调用者必须了解运动方向(向前/向后)才能正确解释计数。

放弃`ReadMainBatteryVoltage`是一个非常不同的故事。由于过度消耗，我已经杀死了一些脂肪电池，所以我认为频繁检查主电池电压是谨慎的，支持命令是值得的额外工作。

接下来，您应该为核心选择一两个简单的接口级方法(在本例中是命令)，这是深度优先方法所要求的。当然，最好是从您希望在项目中使用的方法/命令中进行选择。该准则的一个合理例外是，如果您需要的方法都不简单；那么选择一些简单的东西开始是一个好主意，即使你不打算以后使用它。

表格 [8-2](#Tab2) 可以帮助你选择机器人法律。该表显示了`write_n`和`read_n`的实现提供了很多价值。四种方法使用`write_n`驱动电机；他们不是核心的好候选人。有两种方法写入速度 PID 值，因此它们是候选方法，但需要大量数据。`ResetEncoders`看起来是最佳人选；然而，由于马达不会运行，测试它是有问题的。

表 [8-2](#Tab2) 显示了使用`read_n`读取速度 PID 值的两种方法；这些都是候选，但需要大量的数据。`ReadEncoders`看起来是最佳人选；然而，和`ResetEncoders`一样，测试它是有问题的。读取主电压电池非常简单，所以它是一个候选，但不提供使用`read_n`实现一个方法的值。

查看**用户手册**和`RoboClaw.cpp`，你会发现有设置单个编码器值的命令，它们使用`write_n`！因此，测试读取和写入数据的一对非常好的命令是表 [8-1](#Tab1) 中的命令 78，它使用`read_n`，以及命令 22("设置正交编码器 1 值"，`SetEncM1`)，它使用`write_n`。

### 机器人法律课

现在你可以开始核心的编码了。与任何基于 diozero 的新项目一样，您必须创建一个新的 NetBeans 项目、包和类。然后在您的树莓派上配置项目进行远程开发；然后将项目配置为使用 diozero。步骤总结参见第 [7](07.html) 章，详细参见第 [5](05.html) 和 [6](06.html) 章。我将调用我的项目 **RoboClaw** ，我的包`org.gaf.roboclaw`，我的类`RoboClaw`。

在你创建了`RoboClaw`之后，你应该确保它实现了`AutoCloseable`以遵循第 [7 章](07.html)中的安全网指导方针。由于机器人自动驱动马达，它很容易出现那一章中描述的那种不愉快的情况；因此，您应该在任何使用`RoboClaw`的应用程序中启用 Java 关闭安全网。

接下来，您应该处理 RoboClaw 命令代码。`RoboClaw.h` (C++下载)有一个`enum`定义命令代码。`Roboclaw.cs` (C#下载)有一个定义命令代码的内部类。我认为两者都遵循了将命令类型代码整合在一个地方的最佳实践，而不是将代码分散在接口级方法中。内部类(`Commands`)更加 Java 友好，代码名称与`RoboClaw.cpp`中的代码名称相同。因此，简单地复制内部类是非常方便的。我将只复制前面提到的 13 个命令的命令代码，只是为了使代码清单简短；你应该简单地注释掉那些你不需要的，以防你以后需要它们(就像我对代码 16 所做的那样)。认识到我使用了逐字逐句的方法；我留下了一个普通的类，而没有使用 Java enum，并且我使用了现有的命令代码名，尽管它们不符合 Java 中普遍接受的命名约定。从`Roboclaw.cs`复制内部类后，必须将`Roboclaw.cs`中找到的`public const`改为`static final`，不过那在 NetBeans 中真的很容易。

Note

并非**用户手册**中描述的所有命令都在`RoboClaw.h`或`Roboclaw.cs`中定义了代码。我从 Basicmicro 技术支持部门了解到，大部分缺失的命令只供他们的 Motion Studio 应用程序使用。您极有可能不需要任何缺少的命令。

清单 [8-1](#PC1) 显示了`RoboClaw`的初始代码，包括`Commands`内部类。

```java
package org.gaf.roboclaw;

public class RoboClaw implements AutoCloseable {

    private class Commands {
//        static final int GETM1ENC = 16;
        static final int RESETENC = 20;
        static final int SETM1ENCCOUNT = 22;
        static final int GETMBATT = 24;
        static final int SETM1PID = 28;
        static final int SETM2PID = 29;
        static final int MIXEDSPEED = 37;
        static final int MIXEDSPEEDACCEL = 40;
        static final int MIXEDSPEEDDIST = 43;
        static final int MIXEDSPEEDACCELDIST = 46;
        static final int READM1PID = 55;
        static final int READM2PID = 56;
        static final int GETENCODERS = 78;
    }

Listing 8-1RoboClaw class

```

Note

源代码清单*不包含 Javadoc 或注释(大部分)。这本书的代码库中的源代码包括这两者。*您应该*在移植或编写代码时包含这两者！*

### 构造器分析和实现

通常有许多与设备库构造器的实现相关的考虑事项。本小节讨论一些与 RoboClaw 相关的 USB 串行设备。

#### 身份

如前所述，一个项目中可能存在多个 RoboClaw 实例。此外，每个 RoboClaw 应该分配一个唯一的*设备地址*(0x 80–0x 87)；设备地址实际上是第 [7](07.html) 章中提到的设备实例 ID。这意味着构造器应该有一个设备地址参数。在构造器上设置设备地址有一个重要的副作用:接口级命令*不需要地址参数*！

根据前面的讨论，设备库应该支持设备实例 ID 的验证。身份验证应该在构造器内部进行还是在外部进行？我个人认为最好的选择是外在。在这一章的后面我会告诉你怎么做。

Caution

请记住，USB 连接*不支持 RoboClaw 的多单元模式。这允许设计中每个单元有一个类实例，而接口级方法没有地址。对于多单元模式，正确的设计需要支持所有单元的单个类实例和每个接口级方法上的单元地址。*

#### 系列特征

一般来说，对于串行设备来说，至少在您可以控制连接两端的情况下，值得考虑可能需要定制的串行连接的几个特征。示例包括波特率、奇偶校验位和停止位。

根据 RoboClaw **用户手册**，有了 USB 连接，就不需要在构造器上包含波特率，因为设备运行得尽可能快。此外，其他序列特征不会改变，因此在构造器中不需要它们。事实上，串行特征与`SerialDevice`的默认值相匹配，因此可以使用最简单的形式。

`RoboClaw.cpp`和`Roboclaw.cs`都规定了读取超时。由于`SerialDevice`不支持超时，所以构造器不需要有超时参数。

#### 其他注意事项

清单 [8-2](#PC2) 显示了由`AutoCloseable`授权的`RoboClaw`构造器和`close`方法。因为构造器必须创建一个`SerialDevice`的实例，所以您必须向`RoboClaw`构造器提供一个设备文件。因为我们想要支持多个设备，所以您也必须提供一个地址参数。注意`RoboClaw.h`为用于与 RoboClaw 通信的串行端口定义了一个变量。类似地，您需要一个类变量来引用您在构造器中创建的`SerialDevice`的实例。

`SerialDevice`构造器抛出未检查的`RuntimeIOException`。我决定抓住它，然后抛出选中的`IOException`，以确保明确失败的知识。你可能会决定做一些不同的事情。

```java
import com.diozero.api.SerialDevice;
import com.diozero.util.RuntimeIOException;
import java.io.IOException;

private final SerialDevice device;
private final int address;

public RoboClaw(String deviceFile,
        int deviceAddress)
    throws IOException {
    try {
        this.device = new
            SerialDevice(deviceFile);
        this.address = deviceAddress;
    } catch (RuntimeIOException ex) {
        throw new IOException(ex.getMessage());
    }
}

@Override
public void close() {
    if (this.device != null) {
        // stop the motors, just in case
        speedM1M2(0, 0);
        // close SerialDevice
        this.device.close();
        this.device = null;
    }
}

Listing 8-2RoboClaw constructor and close method

```

作为一个自主运动控制器，RoboClaw 提供了一个潜在“不愉快后果”的好例子，在第 [7](07.html) 章中讨论，与未检查的`RuntimeIOException`或其他条件相关。出现状况时，马达可能正在运转。因此，`RoboClaw.close`必须确保电机停止。最简单的 RoboClaw 命令是表 [8-1](#Tab1) 中提到的“SpeedM1M2”，因此`close`方法使用了方法的 Java 实现`speedM1M2`。当然，该方法尚未实现，所以在实现该方法之前，您需要对语句进行注释。根据章节 [7](07.html) , `close`也调用`SerialDevice.close`，防止被多次调用。

### 中级方法分析

现在你必须看一下`write_n`和`read_n`的实现，以确定它们调用的是什么底层方法。`write_n`的实现非常简单。它写入代表地址、命令代码和命令参数的字节数组，同时计算 CRC，然后写入 CRC，然后读取返回状态以验证传输。实现需要 CRC 相关的方法,“写入字节”方法和“超时读取字节”方法。

`read_n`实现写入地址和命令字节，更新 CRC。然后，它一次一个字节地读取给定数量的四字节整数，同时更新每个字节的 CRC。它最后读取两个字节的 CRC 并检查它。实现需要 CRC 相关的方法,“写入字节”方法和“超时读取字节”方法。注意`read_n`也使用了一个`flush`方法；这种能力似乎是 Arduino 独有的。diozero `SerialDevice`不支持它，其他可用的 Java 库也不支持；我将忽略它。

这两种中级方法的低级需求碰巧是相同的。两者都需要与 CRC 相关的方法(清除、更新、获取)、“写入字节”方法和“超时读取字节”方法。

### CRC 相关方法

我将首先处理与 CRC 相关的方法。所有的工作都在一个类变量上(`RoboClaw.h`中的`crc`和`RoboClaw.java`)。你可以复制 CRC 相关的方法，然后对 Java 进行适当的修改，比如对数据类型；我还决定做一些清理，使用符合 Java 命名约定的方法和变量名。这些方法应该是私有的。清单 [8-3](#PC3) 显示了支持 CRC 使用的代码。

```java
private int crc = 0;

private void crcClear() {
    this.crc = 0;
}

private void crcUpdate(byte data) {
    this.crc = this.crc ^ (data << 8);
    for (int i = 0; i < 8; i++) {
        if ((this.crc & 0x8000) == 0x8000) {
            this.crc = (this.crc << 1) ^ 0x1021;
        } else {
            this.crc <<= 1;
        }
    }
}

private int crcGet() {
     return this.crc;
}

Listing 8-3RoboClaw CRC-related methods

```

在实施 CRC 方法时，有几件事值得注意。CRC 只有 16 位(2 字节)。Java 没有 16 位无符号数据类型；使用 Java `int`来保存 CRC 是最简单的。在整个库实现过程中，您必须认识到这种差异。这种差异的一个很好的例子是`crcUpdate`中的`if`语句，它必须使用与`crc_update`稍有不同的测试。

### 低级方法分析

“写入字节”方法(`RoboClaw.cpp`中的`write()`)写入单个字节，并返回写入的字节数。在 Arduino 环境中，似乎没有失败的预期，因此没有报告失败的机制。因此，中级方法只是希望它能够工作。diozero `SerialDevice.writeByte`方法不返回任何内容；然而，如果出现错误，它可以抛出未检查的*`RuntimeIOException`，就像下面提到的读取方法一样。*

 *“超时读取字节”方法(`RoboClaw.cpp`中的`read(uint32_t timeout)`)需要一些思考。鉴于`SerialDevice`不支持超时，问题就变成了是实现超时功能还是忽略缺席。当然有可能实现类似于`RoboClaw.cpp`所做的事情，但是它会消耗大量的 CPU 周期。无论如何，我建议忽略缺席，除非这样做被证明是有问题的。

还要注意，`read(uint32_t timeout)`返回一个`int`而不是一个`byte`(读取的字节在`int`的最低有效字节中)。此外，如果读取因任何原因失败，该方法将返回-1。diozero `SerialDevice.read`方法的行为完全相同。

### 中级方法实现

在实现`write_n`和`read_n`的等价物之前，您必须研究几个其他主题。这两种方法都允许在“超时读取”方法失败的情况下进行*重试*。因此，您需要一个设置重试次数的类常量。在`RoboClaw.cpp`中该值被设置为 2，所以我将使用它。前一小节显示了低级方法传播未检查的`RuntimeIOException`来指示写或读错误。因此，异常处理应该包含在重试机制中。

#### 写 _n

write_n 使用 C++ *变量参数列表*。`write_n`的列表类型是字节。然而，检查接口级命令表明，在预处理过程中，宏被用来产生逗号分隔的字节串。Java 没有标准的预处理器。我认为最简单的方法是使用 Java *varargs* 功能，列出单个字节，或者在接口级方法中创建一个数组。

清单 [8-4](#PC4) 显示了与`write_n`等价的 Java。如前所述，`writeN`方法使用 varargs(一个`byte`数组)作为参数。它捕捉未检查的异常，并在发生异常时重试整个操作。`MAX_RETRIES`就是前面讨论的常量。

```java
private final int MAX_RETRIES = 2;

private boolean writeN(byte... data) {

    int trys = MAX_RETRIES;

    do { // retry per desired number
        crcClear();
        try {
            for (byte b : data) {
                crcUpdate(b);
                device.writeByte(b);
            }
            int crcLocal = crcGet();
            device.writeByte(
                (byte) (crcLocal >> 8));
            device.writeByte((byte) crcLocal);
            if (device.readByte() ==
                ((byte) 0xFF)) return true;
        } catch (RuntimeIOException ex) {
            // do nothing but retry
        }
    } while (trys-- != 0);
    return false;
}

Listing 8-4RoboClaw writeN method

```

`writeN`方法使用没有“超时保护”的`SerialDevice`阻塞读取这被认为是有风险的。然而，我发现，通常假设成功并适应失败更好。在这种情况下，首先假设设备总是响应，如果偶尔不响应，则实施“超时阻止读取”

请注意清单 [8-4](#PC4) 中的内部循环，它用一个字节更新 CRC，然后写入该字节。一个潜在的性能改进是使用一个循环来更新 CRC，然后写入整个字节数组。根据之前的指导方针，这应该是次要活动。

#### 阅读 _n

`read_n`还使用了 C++ *变量参数列表*。`read_n`的变量参数列表类型是`uint32_t`的*地址*。Java 不支持地址，也不支持无符号 32 位整数。我推荐的方法是使用一个`int`数组，按照调用接口级方法的要求处理有符号和无符号问题。

清单 [8-5](#PC5) 展示了`read_n`的 Java 等价物。`readN`方法使用一个`int`数组作为返回结果的参数。它捕捉未检查的异常，并在发生异常时重试整个操作。

```java
private boolean readN(int commandCode,
    int[] response) {

    int trys = MAX_RETRIES;

    do { // retry per desired number
        crcClear();
        try {
            device.writeByte((byte) address);
            crcUpdate((byte) address);
            device.writeByte((byte) commandCode);
            crcUpdate((byte) commandCode);
            for (int i = 0; i < response.length;
                i++) {
                byte data = device.readByte();
                crcUpdate(data);
                int value =
                    Byte.toUnsignedInt(data) << 24;
                data = device.readByte();
                crcUpdate(data);
                value |=
                    Byte.toUnsignedInt(data) << 16;
                data = device.readByte();
                crcUpdate(data);
                value |=
                    Byte.toUnsignedInt(data) << 8;
                data = device.readByte();
                crcUpdate(data);
                value |= Byte.toUnsignedInt(data);
                response[i] = value;
            }
            dataI = device.read();
            int crcDevice = dataI << 8;
            dataI = device.read();
            crcDevice |= dataI;
            return ((crcGet() & 0x0000ffff) ==
                (crcDevice & 0x0000ffff));
        } catch (RuntimeIOException ex) {
            // do nothing but retry
        }
    } while (trys-- != 0);
    return false;
}

Listing 8-5RoboClaw readN method

```

清单 [8-5](#PC5) 中的内部循环为性能改进提供了另一个选择。它也将被推迟。

### 完成核心

现在可以完成核心了。之前我得出结论，最好的测试是命令 22("设置正交编码器 1 值"，`SetEncM1`)向电机 1 编码器写入一个值，命令 78("读取编码器计数器"，`ReadEncoders`)读取两个电机编码器的值。

首先，我们将研究 Java 中的`SetEncM1`。**用户手册**说，“正交编码器的范围是 0 到 4，294，967，295”(见命令 16 的描述)。由于编码器计数由 32 位值表示，因此必须将其视为无符号的。在 Java 中，这意味着使用一个`long`类型而不是一个`int`。

因为`writeN`接受`byte` varargs，所以参数和命令代码必须插入到一个数组中。这对于地址参数和命令代码来说很容易。四字节编码器计数参数必须一次一个字节地插入到数组中。我决定创建一个私有的 helper 方法来完成这项工作，这样它就可以在其他方法中使用。

清单 [8-6](#PC6) 显示了`setEncoderM1`方法，相当于具有 Java 友好名称的`SetEncM1`。该清单还包括 helper 方法。

```java
public boolean setEncoderM1(long count){
    byte[] buffer = new byte[6];
    buffer[0] = (byte) address;
    buffer[1] = (byte) Commands.SETM1ENCCOUNT;
    insertIntInBuffer((int) count, buffer, 2);
    return writeN(buffer);
}

private void insertIntInBuffer(int value,
    byte[] buffer, int start) {
    buffer[start] = (byte) (value >>> 24);
    buffer[start + 1] = (byte) (value >>> 16);
    buffer[start + 2] = (byte) (value >>> 8);
    buffer[start + 3] = (byte) (value);
}

Listing 8-6RoboClaw setEncoderM1

```

现在我们将研究 Java 中的`ReadEncoders`。在`ReadEncoders`中，两个计数参数是*地址*。因为 Java 不处理地址，所以我将使用一个两元素数组。记住编码器计数必须是`long`类型。

清单 [8-7](#PC7) 展示了`getEncoders`方法，相当于具有 Java 友好名称的`ReadEncoders`。注意`long`数组必须由调用者而不是方法创建。

```java
public boolean getEncoders(long[] encoderCount) {
    int[] response = new int[2];
    boolean valid = readN(address,
            Commands.GETENCODERS, response);
    if (valid) {
        encoderCount[0] = Integer.toUnsignedLong(
                response[0]);
        encoderCount[1] = Integer.toUnsignedLong(
                response[1]);
    }
    return valid;
}

Listing 8-7RoboClaw getEncoders

```

### 测试核心

现在是考验核心的时候了！测试需要一个 main 方法。它应该位于哪里？有一些选项:

1.  在`RoboClaw`本身:这意味着在运行时，当`RoboClaw`被加载时，测试实现也被加载。

2.  在与`RoboClaw`相同的包中的一个类中:这意味着测试类包含在设备库的 jar 文件中。

3.  在 **RoboClaw** 项目中不同*源*包的一个类中:这会产生与 2 相同的结果。

4.  在 **RoboClaw** 项目的*测试*包中的一个类中:正如在第 [5](05.html) 章中提到的，测试包*中的类*不会包含在 jar 文件中，这意味着它们不会被下载到树莓派中，因此*不能*支持远程开发。

5.  在不同 NetBeans 项目的类中:这意味着测试类放在不同于设备库的 jar 文件中；这提供了库和测试类的清晰分离。

选项 5 是最佳选项。选项 4 不起作用。 <sup>[3](#Fn3)</sup> 选项 1 是可行的选项中最不可取的。我觉得选项 2 是“污染性的”并且容易出错，因为它将不必要的类放在同一个包中，并且可能无法捕获访问错误。选项 3 是次佳选项。我建议您在实际项目中使用选项 5。我会用选项 3，因为我懒；我还可以断言，有时用库下载一个测试类是有用的。

按照第 [5](05.html) 章中的说明，在 **RoboClaw** 中为新的主类创建一个新的源包，然后在这个包中创建一个新的主类。我将包命名为`org.gaf.roboclaw.test`，类命名为`TestRoboClawCore`。

`TestRoboClawCore`该怎么办？显然它必须实例化一个`RoboClaw`。它应该练习两种方法，`setEncoderM1`和`getEncoders`。`TestRoboClawCore`还应该处理第 [7](07.html) 章中讨论的身份验证。

#### 身份验证

身份验证的第一阶段由方法`SerialUtil`提供。`findDeviceFiles`在第七章[中讨论](07.html)。这意味着您必须将**实用程序**项目作为库添加到 **RoboClaw** 项目中。参见第 [5](05.html) 章了解如何添加库的说明。

你怎样才能完成机器人法律的第二阶段？正如在**用户手册**中所述以及前面所讨论的，RoboClaw 的所有命令都需要编写命令并读取响应。此外，每个命令都包含一个地址(将其视为设备实例 ID)。如果命令地址与 RoboClaw 中配置的地址相匹配，RoboClaw 会做出响应。如果不匹配，则没有响应，读取响应的尝试将失败。

第二阶段的一个简单方法是发出一个“无害的”命令，然后等待响应。不幸的是，可能没有响应的事实需要超时的阻塞读取，而`SerialDevice`不支持。此外，所有命令都实现了重试机制，如果第一次失败，就没有理由再次重试已知会失败的操作。

设计解决方案有几种方法。我选择了一个最小化代码重复的方法。首先，我查看了表 [8-1](#Tab1) 中的命令。就写入和读取的字节数而言，绝对最简单的是“复位正交编码器计数器”命令，该命令需要内核中的中级方法`writeN`(见表 [8-2](#Tab2) )。这么好的运气！第二，您可以重新设计`writeN`来消除阻塞读取和必要时的重试。第三，您可以实现超时的阻塞读取。最后，您可以创建一个方法来实现整个第二阶段。

清单 [8-8](#PC8) 显示了对`RoboClaw`的修改结果。第一个`writeN`反映了对清单 [8-4](#PC4) 中原始`writeN`的更改，以消除重试和阻塞读取。第二个`writeN`保留了原`writeN`的签名，这样接口级方法就不需要使用更复杂的签名。

```java
import com.diozero.util.SleepUtil;

private boolean writeN(int retries,
        boolean readResponse, byte ... data) {

    do { // retry per desired number
        crcClear();
        try {
            for (byte b : data) {
                crcUpdate(b);
                device.writeByte(b);
            }
            int crcLocal = crcGet();
            device.writeByte((byte)
                (crcLocal >> 8));
            device.writeByte((byte) crcLocal);
            if (readResponse) {
                if (device.readByte() ==
                        ((byte) 0xFF)) return true;
            }
        } catch (RuntimeIOException ex) {
            // do nothing but retry
        }
    } while (retries-- != 0);
    return false;
}

private boolean writeN(byte ... data) {
    return writeN(MAX_RETRIES, true, data);
}

private int readWithTimeout(int timeout)
        throws RuntimeIOException {
    int count = 0;
    while(device.bytesAvailable() < 1) {
        SleepUtil.sleepMillis(1);
        if (++count >= timeout) break;
    }
    if (count >= timeout) return -1;
    else return device.read();
}

public boolean verifyIdentity() throws IOException {
    try {
        writeN(0, false, (byte) address,
               (byte) Commands.RESETENC);
        return readWithTimeout(20) >= 0;
    } catch (RuntimeIOException ex) {
        throw new IOException(ex.getMessage());
    }
}

Listing 8-8Changes to RoboClaw to support identity verification

```

清单 [8-8](#PC8) 中的`readWithTimeout`方法实现了一个简单的“超时读取”有两个方面值得注意:第一，它使用 diozero `SleepUtil`类来避免处理`InterruptedException`(见第 [7 章](07.html))；第二，如果找到预期的可用单字节，该方法读取该字节以保持串行通信同步。

清单 [8-8](#PC8) 中的`verifyIdentity`方法首先使用新的`writeN`方法从`RoboClaw`构造器向设备地址发出“重置正交编码器计数器”命令。然后它调用`readWithTimeout`来获得任何响应。它做出了一个合理的假设，即任何响应都会验证身份。

为了形式化 RoboClaw 的两阶段身份验证，我决定创建一个新的实用方法来实现身份验证。清单 [8-9](#PC9) 显示了包含`static`方法`findDeviceFile`的类`RoboClawUtil`。对于第一阶段，该方法利用`SerialUtil.findDeviceFiles`来产生匹配 USB 设备身份的设备文件列表。该方法遍历执行身份验证第二阶段的设备文件列表，使用`RoboClaw.verifyIdentity`检查 USB 设备的设备实例 ID。请注意，无论验证成功与否，该方法都会关闭设备。当成功时，它返回设备文件。这允许在创建实际使用的`RoboClaw`实例时使用 try-with-resources。

```java
package org.gaf.roboclaw;

import java.io.IOException;
import java.util.List;
import org.gaf.util.SerialUtil;

public class RoboClawUtil {

    public static String findDeviceFile(
            String usbVendorId, String usbProductId,
            int instanceId) throws IOException {
        // identity verification - phase 1
        List<String> deviceFles =
                SerialUtil.findDeviceFiles(
                        usbVendorId, usbProductId);
        // identity verification - phase 2
        if (!deviceFles.isEmpty()) {
            for (String deviceFile : deviceFles) {
                System.out.println(deviceFile);
                RoboClaw claw =
                        new RoboClaw(
                             deviceFile,
                             instanceId);
                boolean verified =
                    claw.verifyIdentity();
                claw.close();
                if (verified) return deviceFile;
            }
        }
        return null;
    }
}

Listing 8-9RoboClawUtil

```

Note

在`findDeviceFile`中使用 USB 设备标识的参数可能是多余的。USB 设备身份可以在该方法中被硬编码。

#### TestRoboClawCore 实现

列表 [8-10](#PC10) 显示`TestRoboClawCore`。该类必须

*   使用`RoboClawUtil.findDeviceFile`执行 USB 设备身份验证

*   根据第 [7](07.html) 章，启用资源试运行和 diozero 关闭安全网

*   根据章节 [7](07.html) ，注册`RoboClaw`实例进行关机，启用 Java 关机安全网

*   使用`setEncoderM1`设置编码器 M1 的值

*   使用`getEncoders`读取两个编码器的值

RoboClaw USB 设备标识来自表 [7-1](07.html#Tab1) ，其中{usbVendorId，usbProductId} = {03eb，2404}。设备地址(或设备实例 ID)来自我在配置 RoboClaw 时使用的值(0x80)。

```java
package org.gaf.roboclaw.test;

import com.diozero.util.Diozero;
import java.io.IOException;
import org.gaf.roboclaw.RoboClaw;
import org.gaf.roboclaw.RoboClawUtil;

public class TestRoboClawCore {

    private final static int ADDRESS = 0x80;

    public static void main(String[] args)
        throws IOException {
        // identity verification
        String clawFile =
                RoboClawUtil.findDeviceFile(
                        "03eb", "2404", ADDRESS);
        if (clawFile == null) {
            throw new IOException(
                     "No matching device!");
        }

        try (RoboClaw claw = new RoboClaw(clawFile,
               ADDRESS)) {

            Diozero.
                registerForShutdown(claw);

            long[] encoders = new long[2];
            boolean ok = claw.setEncoderM1(123456l);
            if (!ok) {
                System.out.println("writeN failed!");
            }

            ok = claw.getEncoders(encoders);
            if (!ok) {
                System.out.println("readN failed");
            } else {
                System.out.println("Encoder M1:" +
                        encoders[0]);
            }
        } finally {
            Diozero.shutdown();
        }
    }
}

Listing 8-10TestRoboClawCore

```

在运行`TestRoboClawCore`之前，您必须按照**用户手册**来:

*   将主电池连接到 RoboClaw。

*   将编码电机连接到 RoboClaw(尽管这可以在以后完成)。

*   使用 Basicmicro *Motion Studio* 应用程序:
    *   更新 RoboClaw 固件(在设备状态屏幕上)。

    *   确保设备运行在*数据包串行模式*(在通用设置屏幕上)。

    *   分配所需的地址(0x 80–0x 87，在通用设置屏幕上)；我用的是 0x80。

*   通过 USB 电缆将您的树莓派连接到 RoboClaw。

Note

在撰写本文时，Motion Studio 只能在 Windows 上运行，这对非 Windows 用户来说是个问题。我用 macOS。幸运的是，我有 Parallels ( [`www.parallels.com`](http://www.parallels.com) )托管 Windows 8.2，所以我能够运行 Motion Studio。您可以为您的工作站创建类似的环境，或者使用廉价的 Windows 机器。

此时，您不需要连接电机，但如果连接了，也不会有任何损害。如第 [5 章](05.html)所述，使用 NetBeans 远程运行`TestRoboClawCore`。您应该会看到类似于清单 [8-11](#PC11) 的结果(您的设备文件可能会有所不同)。核心作品！

```java
/dev/ttyACM1
Encoder M1:123456

Listing 8-11Results of successful execution of TestRoboClawCore

```

现在来点“乐子”在`TestRoboClawCore`中，将`ADDRESS`字段更改为`0x81`。显然，身份验证的第二阶段应该会失败。再次运行`TestRoboClawCore`。您应该看到以下内容:

```java
java.io.IOException: No matching device!

```

如果是这样，那就好！这意味着设备实例 ID 的验证在设备实例 ID 匹配和不匹配时都有效。

### 完成实施

成功是伟大的，但还有更多工作要做。你需要实现中间层方法`Read2`和使用它的接口层方法，加上表 [8-2](#Tab2) 中剩余的使用`write_n`或`read_n`的接口层方法。

首先，我们来分析并实现`Read2`。它与`read_n`相似，既提供从设备读取的数据，也提供指示操作成功或失败的状态。然而，`Read2`返回一个包含数据而不是状态的双字节无符号整数，并在参数中提供状态而不是数据。

看看使用`Read2`的接口级方法，你会发现更多的不一致。有些方法，如期望的方法`ReadMainBatteryVoltage`，返回一个整数并在参数中提供状态，有些返回状态并提供整数或两个字节作为参数。为了满足我的好奇心，我查看了`Roboclaw.cs`,发现它始终返回状态，并使用一个或多个参数提供任何数据。

我非常想引入一致性，但是这也带来了一些问题。Java 不允许除了对象之外的引用。有几种方法可以处理这个问题:

*   使用异常来指示状态并返回值。这可能是太多的 Java 主义，并且为了一致性，会影响已经完成的工作。

*   使用子类来返回状态和值。这引入了一些 Java-ism，但不影响已经完成的工作。

*   使用数组作为参数，即使是不必要的。这引入了一些 Java-ism，但不影响已经完成的工作。

我认为数组是最简单的方法。因此，接口级方法将直接返回状态，并采用参数来返回数据。

为了使`Read2`的 Java 实现与其他中级方法一致，它也应该返回 status。由于`Read2`调用者无论如何都必须考虑“双字节性”,我建议通过参数返回一个字节数组。这产生了一个与清单 [8-12](#PC13) 中所示的`read2`方法的`read_n`(或`readN`)非常相似的设计。

```java
private boolean read2(int commandCode,
    byte[] response) {

    int trys = MAX_RETRIES;

    do { // retry per desired number
        crcClear();
        try {
            device.writeByte((byte) address);
            crcUpdate((byte) address);
            device.writeByte((byte) commandCode);
            crcUpdate((byte) commandCode);

            byte data = device.readByte();
            crcUpdate(data);
            response[0] = data;
            data = device.readByte();
            crcUpdate(data);
            response[1] = data

            // check the CRC
            int crcDevice;
            int dataI;
            dataI = device.read();
            crcDevice = dataI << 8;
            dataI = device.read();
            crcDevice |= dataI;
            return ((crcGet() & 0x0000ffff) ==
                (crcDevice & 0x0000ffff));
        } catch (RuntimeIOException ex) {
            // do nothing but retry
        }
    } while (trys-- != 0);
    return false;
}

Listing 8-12RoboClaw read2

```

表 [8-2](#Tab2) 表明`ReadMainBatteryVoltage`是唯一使用`read2`的方法，所以我们接下来将实现那个接口级方法。清单 [8-13](#PC14) 显示了具有 Java 友好名称`getMainBatteryVoltage`的实现。

```java
public boolean getMainBatteryVoltage(int[] voltage) {
    byte[] response = new byte[2];
    boolean ok = read2(Commands.GETMBATT, response);

    if (ok) {
        int value =
            Byte.toUnsignedInt(response[0]) << 8;
        value |= Byte.toUnsignedInt(response[1]);
        voltage[0] = value;
    }
    return ok;
}

Listing 8-13RoboClaw getMainBatteryVoltage

```

为了测试`read2`和`getMainBatteryVoltage`，将清单 [8-12](#PC13) 和 [8-13](#PC14) 中所示的代码添加到`RoboClaw`中。将清单 [8-14](#PC15) 中的代码添加到`TestRoboClawCore`中；我把它放在 try-with-resources 结束之前。

```java
int[] voltage = new int[1];
ok = claw.getMainBatteryVoltage(voltage);
if (!ok) {
    System.out.println("read2 failed");
} else {
    System.out.println("Main battery voltage: " +
        voltage[0]);
}

Listing 8-14Testing getMainBatteryVoltage and read2

```

当您运行`TestRoboClawCore`时，您应该会看到清单 [8-10](#PC10) 中的结果以及类似如下的内容:

```java
Main battery voltage: 120

```

由于报告的值以十分之一伏特为单位，因此电压为 12.0V，这对于我的 3 芯 LiPo 主电池来说是合理的。您几乎肯定会看到不同的电压值，这取决于电池的额定电压和充电水平。

剩余的接口级命令方法使用已经测试过的`writeN`或`readN`。清单 [8-15](#PC17) 显示了获取电机 1 速度 PID 的`getM1VelocityPID`方法的实现。它必须提供三个浮点值和一个整数。一致性要求为状态返回一个`boolean`，并为四个“感兴趣的”值使用参数。唯一的两个选择是

*   三个`float`数组和一个`int`数组

*   具有三个`float`字段和一个`int`字段的内部类

两个选择都有点不愉快。然而，后者展示了一些新的东西，并且肯定更加 Java 友好，所以我将使用嵌套类。

清单 [8-15](#PC17) 中`getM1VelocityPID`的实现反映了

*   有另外一种相同的方法来获得电机 2 的 PID。

*   该方法不是性能关键的。

因此，我将实现的公共部分放在它自己的方法中。这使得对电机 2 执行相同的命令变得非常容易，也减少了编码和测试。

```java
public boolean getM1VelocityPID(
    VelocityPID velocityPID) {
    return getVelocityPID(Commands.READM1PID,
        velocityPID);
}

private boolean getVelocityPID(int commandCode,
    VelocityPID velocityPID) {

    int[] response = new int[4];
    boolean valid = readN(commandCode, response);
    if (valid) {
        velocityPID.kP =
            ((float) response[0]) / 65536f;
        velocityPID.kI =
            ((float) response[1]) / 65536f;
        velocityPID.kD =
            ((float) response[2]) / 65536f;
        velocityPID.qPPS = response[3];
    }
    return valid;
}

public static class VelocityPID {
    public float kP;
    public float kI;
    public float kD;
    public int qPPS;

    public VelocityPID() {
    }

    public VelocityPID(float kP, float kI,
            float kD, int qPPS) {
        this.kP = kP;
        this.kI = kI;
        this.kD = kD;
        this.qPPS = qPPS;
    }

    @Override
    public String toString() {
        return "Velocity PID kP: " + kP +
        "  kI: " + kI + "  kD: " + kD +
        "  qpps: " + qPPS;
    }
}

Listing 8-15RoboClaw getM1VelocityPID and VelocityPID inner class

```

清单 [8-16](#PC18) 显示了设置电机 1 速度 PID 的`setM1VelocityPID`方法的实现。虽然有可能为三个`float`值和单个`int`值使用单独的参数，但是由于`VelocityPID`类已经存在，`setM1VelocityPID`将会使用它。

与获取 PID 一样，您可以将公共函数分解成不同的方法。同样，这减少了编码和测试。

```java
public boolean setM1VelocityPID(
        VelocityPID velocityPID) {
    return setVelocityPID(Commands.SETM1PID,
            velocityPID);
}

private boolean setVelocityPID(int commandCode,
        VelocityPID velocityPID) {
    byte[] buffer = new byte[18];

    // calculate the integer values for device
    int kPi = (int) (velocityPID.kP * 65536);
    int kIi = (int) (velocityPID.kI * 65536);
    int kDi = (int) (velocityPID.kD * 65536);

    // insert parameters into buffer
    buffer[0] = (byte) address;
    buffer[1] = (byte) commandCode;
    insertIntInBuffer(kDi, buffer, 2);
    insertIntInBuffer(kPi, buffer, 6);
    insertIntInBuffer(kIi, buffer, 10);
    insertIntInBuffer(velocityPID.qPPS, buffer, 14);
    return writeN(buffer);
}

Listing 8-16RoboClaw setM1VelocityPID

```

是时候测试新方法了。将清单 [8-16](#PC18) 中的代码添加到`RoboClaw`中。在 try-with-resources 语句的末尾之前添加清单 [8-17](#PC19) 到`TestRoboClawCore`中的代码。

```java
RoboClaw.VelocityPID m1PID =
    new RoboClaw.VelocityPID();
ok = claw.getM1VelocityPID(m1PID);
if (!ok) {
    System.out.println("readN failed");
} else {
    System.out.println("M1:" + m1PID);
}

m1PID = new RoboClaw.VelocityPID(8, 7, 6, 2000);
ok = claw.setM1VelocityPID(m1PID);
if (!ok) {
    System.out.println("writeN failed");
}

ok = claw.getM1VelocityPID(m1PID);
if (!ok) {
    System.out.println("readN failed");
} else {
    System.out.println("M1:" + m1PID);
}

Listing 8-17More in TestRoboClawCore

```

运行`TestRoboClawCore`，您应该会看到类似清单 [8-18](#PC20) 中的输出。您的 M1 速度 PID 值可能会有所不同。同样，你的电压可能会有所不同。

```java
/dev/ttyACM1
Encoder M1:123456
Main battery voltage:120
M1:Velocity PID kP: 10.167343  kI: 1.7274933  kD: 0.0  qpps: 2250
M1:Velocity PID kP: 8.0  kI: 7.0  kD: 6.0  qpps: 2000

Listing 8-18Output

```

成功运行测试后，将主电池从 RoboClaw 上断开，然后重新连接(我根据**用户手册**通过开关连接了我的电池)。这将恢复原始 PID 值。

现在是一些可怕的工作。我们将执行一个驱动马达的命令！清单 [8-19](#PC21) 展示了`speedAccelDistanceM1M2`的实现。唯一有趣的方面是对一些参数使用了`long`；您可以猜到，这是因为 Java 不支持无符号 32 位整数。

```java
public boolean speedAccelDistanceM1M2(
    long acceleration, int speedM1, long distanceM1,
    int speedM2, long distanceM2, boolean buffer) {
    byte[] buf = new byte[23];

    buf[0] = (byte) address;
    buf[1] = (byte) Commands.MIXEDSPEEDACCELDIST;
    insertIntInBuffer((int) acceleration, buf, 2);
    insertIntInBuffer(speedM1, buf, 6);
    insertIntInBuffer((int) distanceM1, buf, 10);
    insertIntInBuffer(speedM2, buf, 14);
    insertIntInBuffer((int) distanceM2, buf, 18);
    buf[22] = (buffer) ? (byte) 0 : 1;
    return writeN(buf);
}

Listing 8-19RoboClaw speedAccelDistanceM1M2

```

为了简化测试，我将创建一个新的主类`TestClawMotor`，如清单 [8-20](#PC22) 所示。它和`TestRoboClawCore`有一些明显的相似之处，但它只叫`speedAccelDistanceM1M2`。当然，要运行这个测试，您必须将电池连接到 RoboClaw，并将编码电机连接到 RoboClaw。注意，该命令有两次调用。两个命令都被缓冲。第一个命令执行并使 RoboClaw 以 400 编码器每秒 <sup>2</sup> 的速度加速到 400 秒，并运行 2400 个脉冲的总距离。然后执行第二个命令，使机器人以 400 PPS 的速度减速 <sup>2</sup> 达到 0 PPS。

您可能对`sleep`语句感到好奇。`speedAccelDistanceM1M2`方法只是将命令发送给 RoboClaw 并返回；因此，该方法在命令启动的移动完成之前很久就返回。休眠只是在设备关闭之前给缓冲的命令时间来完成。阅读**用户手册**了解更多关于缓冲的细节。

```java
package org.gaf.roboclaw.test;

import com.diozero.util.Diozero;
import java.io.IOException;
import org.gaf.roboclaw.RoboClaw;
import org.gaf.roboclaw.RoboClawUtil;

public class TestClawMotor {

    private final static int ADDRESS = 0x80;

    public static void main(String[] args)
        throws IOException {
        // identity verification
        String clawFile =
                RoboClawUtil.findDeviceFile(
                        "03eb", "2404", ADDRESS);
        if (clawFile == null) {
            throw new IOException(
                    "No matching device!");
        }

        try (RoboClaw claw = new RoboClaw(clawFile,
               ADDRESS)) {

            Diozero.
                registerForShutdown(claw);

            boolean ok =
                    claw.speedAccelDistanceM1M2(
                    400, 400, 2400, 400, 2400,
                    true);
            ok = claw.speedAccelDistanceM1M2(
                    400, 0, 0, 0, 0, true);
            // wait for buffered commands to finish
            Thread.sleep(10000);
        } finally {
            Diozero.shutdown();
        }
    }
}

Listing 8-20TestClawMotor

```

当您运行`TestClawMotor`时，您应该看到电机加速到额定速度，以额定速度运行，然后减速到零(停止)，所有这些总共需要大约 7 秒的时间。如果没有发生这种情况，您可能有一些接线不正确。

恭喜你！您已经完成了将 C++库移植到 Java 的所有艰苦工作！我没有涵盖表 [8-2](#Tab2) 中的所有命令，但是那些没有实现的命令是那些已经实现的命令的简单变体。完整的实现包含在本书的代码库中。

Caution

不要忘记`RoboClaw.close`正常工作需要`speedM1M2`。

## 摘要

在本章中，您已经学会了如何

*   评估现有设备库以移植到 Java

*   如果你有足够的时间，可以在多个图书馆中选择

*   识别和评估移植问题，在如何移植现有库以及移植多少方面进行权衡

*   解决将 C++库移植到 Java 的血淋淋的细节

*   使用深度优先的开发方法，随着新需求的出现改进设计

*   为复杂的串行设备创建一个全功能的 Java 库

干得好！

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

如果你想了解更多关于自主漫游车的信息，请访问。

  [2](#Fn2_source)

CRC(循环冗余校验)是一种检测传输数据流中错误的简单方法。你不需要理解这些原理，但是你必须在 RoboClaw 的上下文中处理 CRC 计算。

  [3](#Fn3_source)

使用 diozero 远程提供者进行测试，然后切换到所需的提供者进行生产，这可能是一个合理的选择。

 </aside>********