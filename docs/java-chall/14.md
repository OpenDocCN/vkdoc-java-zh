# 十四、O 符号快速入门

在本书中，所谓的 O-notation 是用来对算法的运行时间进行分类的。这允许对算法的复杂性进行更正式的分类。

## 1 使用 O 符号的估计值

要估计和描述算法的复杂性并对它们的运行时行为进行分类，总是进行度量是不切实际的。此外，测量仅反映在硬件(处理器时钟、存储器等)的某些限制下的运行时间行为。).为了能够独立于这些细节并在更抽象的层面上对设计决策的后果进行分类，计算机科学使用了所谓的 *O-notation* ，这表明了算法复杂性的上限。为了做到这一点，人们希望能够回答下面的问题:*当不是处理 1000 个输入值，例如，处理 10000 或 100000 个输入值时，程序如何执行？*要回答这个问题，必须考虑算法的各个步骤并进行分类。目的是形式化复杂性的计算，以估计输入数据数量的变化对程序运行时间的影响。

考虑以下`while`循环作为介绍性示例:

```java
int i = 0;                      // O(1)
while (i < n)                   // O(n)
{
    createPersonInDb(i);        // O(1)
    i++;                        // O(1)
}

```

任何单个指令都被赋予了 *O* (1)的复杂度。由于循环体的 *n* 执行，循环本身被赋予复杂度 *O* ( *n* )。 <sup>[1](#Fn1)</sup> 将这些值加在一起，那么运行程序的成本就是*O*(1)+*O*(*n*)∫(*O*(1)+*O*(1))=*O*(1)+*O*(*n*)∫对于复杂性的估计，常数和因子并不重要。只对 *n* 的最高功率感兴趣。因此，对于程序的图示部分，您得到的复杂度为 *O* ( *n* )。这种简化是允许的，因为对于较大的 *n* 值，因子和较小复杂度等级的影响是不明显的。为了理解以下各节中的注意事项，这个非正式的定义应该足够了。

下面，我想引用罗伯特·塞奇威克的两句话来描述 O-符号，这两句话摘自他的标准著作*算法*[sed 92]:“[...O 符号是指定运行时间上限的有用工具，它独立于输入数据的细节和实现。”它进一步指出,“在帮助分析师根据算法的性能对算法进行分类方面，以及在帮助算法搜索*最佳*算法方面，O 符号被证明是非常有用的。”

### 1.1 复杂性类别

为了能够相互比较不同算法的运行时行为，七个不同的复杂性类别通常就足够了。下表列出了各自的复杂性类别和一些示例:

*   *O* (1):恒定复杂度导致复杂度与输入数据的数量 *n* 无关。这种复杂性通常代表*一条指令*或者由几个计算步骤组成的简单计算。

*   *O* ( *log* ( *n* ):对数复杂度下，输入数据集 *n* 的平方时运行时间翻倍。这种复杂性的一个众所周知的例子是二分搜索法。

*   *O* ( *n* ):在线性复杂度的情况下，运行时间与元素数量 *n* 成正比增长。简单的循环和迭代就是这种情况，比如在数组或列表中进行*搜索。*

*   *O* ( *n* )。 *log* ( *n* ):这种复杂性是线性和对数增长的结合。一些最快的*排序算法*(例如 Mergesort)显示了这种复杂性。

*   *O*(*n*T6】2):当输入数据量翻倍 *n* 时，二次复杂度导致运行时间翻两番。输入数据的十倍增长已经导致运行时间的百倍增长。实际上，这种复杂性是用*两个嵌套的* `for` *或* `while` *循环*发现的。简单的排序算法通常具有这种复杂性。

*   *O* ( *n* <sup>3</sup> ):以立方复杂度来说， *n* 翻倍已经导致运行时间增加八倍。矩阵的简单*乘法就是这种复杂性的一个例子。*

*   *O* (2 <sup>*n*</sup> ):指数复杂度导致在运行时间的平方中 *n* 翻倍。起初，这听起来并不多。但是，如果增加 10 倍，运行时间将增加 200 亿倍！指数复杂性经常出现在*优化问题*中，例如所谓的*旅行推销员问题*，其目标是在访问所有城市的同时找到不同城市之间的最短路径。为了解决运行时间过长的问题，程序使用试探法，这种方法可能找不到最优解，只是一个近似解，但是复杂度低得多，运行时间也短得多。

表 [C-1](#Tab1) 令人印象深刻地显示了对于不同的输入数据组 *n* 所提到的复杂性类别的影响。<sup>2[2](#Fn2)T7】</sup>

表 C-1

不同时间复杂性的影响

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"> <col class="tcol6 align-left"></colgroup> 
| 

*N*

 | 

*O* ( *日志* ( *n* ))

 | 

*O* ( *n*

 | 

*O* ( *n* )。*日志* ( *n* ))

 | 

*O*(*n*T4】2

 | 

*O*(*n*T4】3

 |
| --- | --- | --- | --- | --- | --- |
| Ten | one | Ten | Ten | One hundred | One |
| One hundred | Two | One hundred | Two hundred | Ten | 1.000.000 |
| One | three | One | Three | 1.000.000 | 1.000.000.000 |
| Ten | four | Ten | Forty | 100.000.000 | 1.000.000.000.000 |
| One hundred | five | One hundred | Five hundred | 10.000.000.000 | 1.000.000.000.000.000 |
| 1.000.000 | six | 1.000.000 | 6.000.000 | 1.000.000.000.000 | 1.000.000.000.000.000.000 |

根据显示的值，您可以感受不同复杂性的影响。大约到了 *O* ( *n* )。 *log* ( *n* ))复杂度等级有利。虽然对于许多算法来说是无法实现的，但最佳和理想的是复杂度 *O* (1)和*O*(*log*(*n*))。已经*O*(*n*T20】2)通常不适合较大的输入集，但它可以用于简单的计算和较小的 *n* 值，没有任何问题。

NOTE: INFLUENCE OF INPUT DATA

根据输入数据的不同，某些算法的行为会有所不同。对于快速排序，一般情况下的复杂度为 *n* 。 *log* ( *n* ，但这在极端情况下可以增加到*n*T8】2。由于 O 符号描述了最差情况*，快速排序被赋予了复杂度*O*(*n*<sup>2</sup>)。*

 *### 1.2 复杂性和程序运行时间

对于一组输入值 *n* ，通过特殊的 O 复杂度计算出的数字有时可能令人望而生畏。尽管如此，他们并没有提到实际的执行时间，而只是提到了当输入集增加时它的增长。正如已经基于介绍性示例的那样，O-符号没有声明单个计算步骤的持续时间:增量`i++`和数据库访问`createPersonInDb(i)`都被评定为 *O* (1)，即使数据库访问比关于执行时间的增量贵几个数量级。

对于*普通*指令，无需访问外部系统，如文件系统、网络或数据库(即添加、分配等)。)，在许多情况下， *n* 的影响对于今天具有用户交互的典型商业应用的计算机来说不是决定性的。对于小的 *n* ( < 1000)在复杂度 *O* ( *n* )或*O*(*n*<sup>2</sup>)甚至有时在*O*(*n*<sup>3</sup>)时，对实际运行时间的影响几乎无关紧要——但这并不意味着你不应该使用尽可能优化的算法相反，反之亦然:您也可以从第一个功能正确的实现开始，并将其投入生产。优化版本可能会在稍后推出。

总而言之，我想再次强调，即使是复杂度为 *O* ( *n* <sup>2</sup> )或 *O* ( *n* <sup>3</sup> )的多重嵌套循环，从绝对意义上来说，其执行速度通常也比网络上一些复杂度为 *O* ( *n* )的数据库查询快得多。对于数组中的搜索( *O* ( *n* ))和对基于散列的数据结构的元素的访问( *O* (1))也是如此。对于小的 *n* ，哈希值的计算可能比线性搜索花费更长的时间。然而， *n* 越大，越差的复杂度类对实际运行时间的影响就越大。

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

在下一页，通过展示其他复杂性类别的示例，符号的含义将变得更容易理解。有关更高级的插图，请参见 [`www.linux-related.de/index.html?/coding/o-notation.htm`](http://www.linux-related.de/index.html%253F/coding/o-notation.htm) 。

  [2](#Fn2_source)

时间复杂度 *O* (2 <sup>*n*</sup> )没有显示，因为它的增长太强了，如果不使用 10 的幂，就无法有意义地表达。

 </aside>*