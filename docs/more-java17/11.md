# 十一、进程 API

在本章中，您将学习:

*   什么是进程 API

*   如何与运行 Java 应用程序的当前进程交互

*   如何创建本机进程

*   如何获取有关新进程的信息

*   如何获取当前进程的信息

*   如何获取所有系统进程的信息

*   如何设置创建、查询和管理本机进程的权限

本章中的所有示例程序都是清单 11-1 中声明的`jdojo.process`模块的成员。

```java
// module-info.java
module jdojo.process {
    exports com.jdojo.process;
}

Listing 11-1The Declaration of a jdojo.process Module

```

## 什么是进程 API？

Process API 由允许您在 Java 程序中使用本地进程的类和接口组成。使用 API，您可以

*   从 Java 代码创建新的本地进程。

*   获取本机进程的进程句柄，无论它们是由 Java 代码还是其他方式创建的。

*   销毁正在运行的本机进程。

*   查询进程的活性及其其他属性。

*   获取进程的子进程和父进程的列表。

*   获取本机进程的进程 ID (PID)。

*   获取新创建进程的输入、输出和错误流。

*   等待进程终止。

*   当进程终止时执行任务。

进程 API 很小。它由表 11-1 中列出的类和接口组成。我将在接下来的章节中用例子详细解释这些类和接口。

表 11-1

进程 API 的类和接口

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

类别/接口

 | 

描述

 |
| --- | --- |
| `Runtime` | 它是一个单例类，其唯一的实例代表了 Java 应用程序的运行时环境。 |
| `ProcessBuilder` | `ProcessBuilder`类的一个实例保存了一组进程的属性。调用它的`start()`方法启动一个本地进程，并返回一个代表本地进程的`Process`类的实例。可以多次调用它的`start()`方法；每次，它都使用保存在`ProcessBuilder`实例中的属性启动一个新的进程。 |
| `ProcessBuilder.Redirect` | 它是一个静态嵌套类，表示进程输入的源或进程输出的目的。 |
| `Process` | 它是一个抽象类，其实例表示当前 Java 程序使用`ProcessBuilder`的`start()`方法或`Runtime`的`exec()`方法启动的本地进程。 |
| `ProcessHandle` | 它是一个接口，其实例表示本地进程的句柄，无论这些进程是由当前 Java 程序还是由任何其他方式启动的。您可以使用此句柄控制和查询本机进程的状态。 |
| `ProcessHandle.Info` | `ProcessHandle.Info`接口的一个实例表示一个进程属性的快照。 |

在 Java 中，您可以启动本地进程，并使用它们的输入、输出和错误流。此外，还可以使用未启动的本地进程，并查询进程的详细信息。对于后者，您使用进程 API 内部的一个名为`ProcessHandle`的接口。接口的一个实例标识了一个本地进程；它允许您查询进程状态和管理进程。

比较一下`Process`类和`ProcessHandle`接口。`Process`类的实例表示由当前 Java 程序启动的本地进程，而`ProcessHandle`接口的实例表示由当前 Java 程序或其他方式启动的本地进程。`Process`类包含一个返回`ProcessHandle`的`toHandle()`方法。

`ProcessHandle.Info`接口的一个实例表示一个进程属性的快照。请注意，不同的操作系统实现的进程不同，因此它们的属性也不同。进程的状态可能随时改变，例如，每当进程获得更多的 CPU 时间时，进程使用的 CPU 时间就会增加。为了获得进程的最新信息，您需要在需要的时候使用`ProcessHandle`接口的`info()`方法，这将返回一个`ProcessHandle.Info`接口的新实例。

本章中的所有例子都是在 Ubuntu Linux 上运行的。当您在使用 Windows 或任何其他不同操作系统的计算机上运行这些程序时，您可能会得到不同的输出。

Note

通过调整可执行文件和参数文件路径，CLI 代码片段可以很容易地转换为 Windows 代码片段。

## 了解运行时环境

每个 Java 应用程序都有一个`Runtime`类的实例，它允许您查询当前 Java 应用程序运行的运行时环境并与之交互。`Runtime`类是单例的。您可以使用该类的`getRuntime()`静态方法获得它的唯一实例:

```java
// Get the instance of the Runtime
Runtime runtime = Runtime.getRuntime();

```

使用`Runtime`，可以知道当前 JVM 可以使用的最大内存，JVM 中当前分配的内存，以及 JVM 中的空闲内存。这里有三种方法可以让您以字节为单位查询 JVM 的内存:

*   `long maxMemory()`

*   `long totalMemory()`

*   `long freeMemory()`

JVM 延迟分配内存。`maxMemory()`方法返回 JVM 可以分配的最大内存量。如果没有最大内存限制，该方法返回`Long.MAX_VALUE`。

`totalMemory()`方法返回 JVM 当前分配的最大内存。当 JVM 需要更多内存时，它会分配更多内存，而`totalMemory()`方法将返回当前分配的内存。JVM 可以分配最大内存，最大为由`maxMemory()`方法返回的内存量。

`freeMemory()`方法从 JVM 当前分配的内存中返回未使用的内存。你如何知道 JVM 使用的内存？下面的公式将给出 JVM 在特定时间点使用的内存:

```java
Used Memory = Total Memory Free Memory

```

使用`availableProcessors()`方法获得 JVM 的可用处理器数量。

使用`version()`方法获得一个代表 Java 运行时环境版本的`Runtime.Version`。关于 JDK/JRE 版本化方案的更多细节，请参考`Runtime.Version`类的 Javadoc。清单 11-2 向您展示了`Runtime`类在查询 Java 运行时环境中的一些应用。您可能会得到不同的输出。

```java
// QueryingRuntime.java
package com.jdojo.process;
public class QueryingRuntime {
    public static void main(String[] args) {
        // Get the Runtime instance
        Runtime rt = Runtime.getRuntime();
        // Get the JVM memory
        long maxMemory = rt.maxMemory();
        long totalMemory = rt.totalMemory();
        long freeMemory = rt.freeMemory();
        long usedMemory = totalMemory freeMemory;
        System.out.format(
            "Max memory = %d, Total memory = %d,"
            + "Free memory = %d, Used memory = %d.%n",
            maxMemory, totalMemory, freeMemory,
            usedMemory);
        // Print the number of processors available to
        // the JVM
        int processors = rt.availableProcessors();
        System.out.format("Number of processors = %d%n",
            processors);
        // Print the version of the Java runtime
        Runtime.Version version = rt.version();
        System.out.format("Version = %s%n",
            version);
    }
}

Max memory = 3126853632,
    Total memory = 201326592,
    Free memory = 198351728,
    Used memory = 2974864.
Number of processors = 8
Version = 17+01-123

Listing 11-2Querying the Java Runtime Environment

```

您可以使用`Runtime`类的`gc()`方法调用垃圾收集。`System.gc()`静态方法是`Runtime.getRuntime().gc()`的方便方法。

Note

方法`gc()`只是提示操作系统在下一个方便的时间段开始垃圾收集。如果`gc()`被调用，你不能依赖垃圾收集来立即开始。

您可以使用`Runtime`类的`exit(int status)`方法终止 JVM。`System.exit()`静态方法是`Runtime.getRuntime().exit()`的一个方便方法。按照惯例，`status`的非零值表示 JVM 的异常终止。您可以使用`Runtime`类的`halt()`方法强制终止 JVM。

您可以使用`Runtime`类的`addShutdownHook(Thread hook)`和`removeShutdownHook(Thread hook)`方法添加和移除 JVM 的关闭挂钩。关闭挂钩是一个线程，它被初始化，但没有启动。当线程终止时，JVM 启动注册为关闭挂钩的线程。

使用它的一个`exec()`重载方法来启动一个本地进程。您应该使用`ProcessBuilder`类来启动一个本地进程。`Runtime`类的`exec()`方法在内部使用了`ProcessBuilder`类。

## 当前进程

`ProcessHandle`接口的`current()`静态方法返回当前进程的句柄。请注意，此方法返回的当前进程始终是执行代码的 Java 进程:

```java
// Get the handle of the current process
ProcessHandle current = ProcessHandle.current();

```

一旦获得了当前进程的句柄，就可以使用`ProcessHandle`接口的方法来获得关于该进程的细节。请参考下一节中关于如何获取当前进程信息的示例。

Note

您不能终止当前进程。试图使用`ProcessHandle`接口的`destroy()`或`destroyForcibly()`方法终止当前进程会导致`IllegalStateException`。

## 查询进程状态

您可以使用`ProcessHandle`接口中的方法来查询进程的状态。表 11-2 列出了该接口的常用方法，并做了简要说明。请注意，这些方法中有许多会返回快照时为真的进程状态的快照。因为进程是异步创建、运行和销毁的，所以当您以后使用它的属性时，不能保证进程仍然处于相同的状态。

表 11-2

ProcessHandle 接口中的方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

方法

 | 

描述

 |
| --- | --- |
| `static Stream<ProcessHandle> allProcesses()` | 返回操作系统中对当前进程可见的所有进程的快照。 |
| `Stream<ProcessHandle> children()` | 返回进程的当前直接子进程的快照。使用`descendants()`方法获得所有级别的子进程列表，例如，子进程、孙进程、曾孙进程等。 |
| `static ProcessHandle current()` | 为当前进程返回一个`ProcessHandle`，当前进程是执行这个方法调用的 Java 进程。 |
| `Stream<ProcessHandle> descendants()` | 返回进程后代的快照。将其与`children()`方法进行比较，后者只返回进程的直接后代。 |
| `boolean destroy()` | 请求终止该进程。如果成功请求终止进程，则返回`true`，否则返回`false`。能否终止一个进程取决于操作系统的访问控制。 |
| `boolean destroyForcibly()` | 请求强制终止进程。如果成功请求终止进程，则返回`true`，否则返回`false`。终止一个进程会立即强制终止该进程，而正常终止则允许进程干净地关闭。能否终止一个进程取决于操作系统的访问控制。 |
| `ProcessHandle.Info info()` | 返回进程信息的快照。 |
| `boolean isAlive()` | 如果此`ProcessHandle`所代表的进程尚未终止，则返回`true`，否则返回`false`。请注意，在您成功请求终止进程后的一段时间内，该方法可能会返回`true`，因为进程将被异步终止。 |
| `static Optional<ProcessHandle> of(long pid)` | 为现有的本地进程返回一个`Optional<ProcessHandle>`。如果具有指定的`pid`的进程不存在，则返回空的`Optional`。 |
| `CompletableFuture <ProcessHandle> onExit()` | 返回一个`CompletableFuture <ProcessHandle>`来终止进程。您可以使用返回的对象添加一个任务，该任务将在进程终止时执行。在当前进程上调用这个方法会抛出一个`IllegalStateException`。 |
| `Optional<ProcessHandle> parent()` | 为父进程返回一个`Optional<ProcessHandle>`。 |
| `long pid()` | 返回由操作系统分配的进程的本机进程 ID (PID)。注意，如果进程终止，PID 可以被操作系统重用，因此具有相同 PID 的两个进程句柄可能不代表相同的进程。 |
| `boolean supportsNormalTermination()` | 如果`destroy()`的执行正常终止进程，则返回`true`。 |

表 11-3 列出了`ProcessHandle.Info`嵌套接口的方法和描述。此接口的实例包含有关进程的快照信息。你可以使用`ProcessHandle`接口的`info()`方法或者`Process`类获得一个`ProcessHandle.Info`。接口中的所有方法都返回一个`Optional`。

表 11-3

方法。信息界面

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

方法

 | 

描述

 |
| --- | --- |
| `Optional<String[]> arguments()` | 返回进程的参数。该进程可能会在启动后更改传递给它的原始参数。在这种情况下，此方法返回更改的参数。 |
| `Optional<String> command()` | 返回进程的可执行路径名。 |
| `Optional<String> commandLine()` | 这是一种将进程的命令和参数结合起来的便捷方法。如果两个方法都返回非空选项，它通过组合从`command()`和`arguments()`方法返回的值来返回进程的命令行。 |
| `Optional<Instant> startInstant()` | 返回进程的开始时间。如果操作系统没有返回开始时间，它返回一个空的`Optional`。 |
| `Optional<Duration> totalCpuDuration()` | 返回进程使用的总 CPU 时间。请注意，一个进程可能会运行很长时间，并且可能会占用很少的 CPU 时间。 |
| `Optional<String> user()` | 返回进程的用户。 |

是时候看看`ProcessHandle`和`ProcessHandle.Info`接口的作用了。清单 11-3 包含一个名为`CurrentProcessInfo`的类的代码。它的`printInfo()`方法以一个`ProcessHandle`作为参数，并打印进程的细节。我们还在其他例子中使用这种方法来打印进程的细节。`main()`方法获取运行该进程的当前进程的句柄，该进程是一个 Java 进程，并打印其详细信息。您可能会得到不同的输出。当程序在 Linux 上运行时，会生成输出。

```java
// CurrentProcessInfo.java
package com.jdojo.process;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Arrays;
public class CurrentProcessInfo {
    public static void main(String[] args) {
        // Get the handle of the current process
        ProcessHandle current = ProcessHandle.current();
        // Print the process details
        printInfo(current);
    } 

    public static void printInfo(ProcessHandle handle) {
        // Get the process ID
        long pid = handle.pid();
        // Is the process still running
        boolean isAlive = handle.isAlive();
        // Get other process info
        ProcessHandle.Info info = handle.info();
        String command = info.command().orElse("");
        String[] args = info.arguments()
                            .orElse(new String[]{});
        String commandLine = info.commandLine()
            .orElse("");
        ZonedDateTime startTime = info.startInstant()
            .orElse(Instant.now())
            .atZone(ZoneId.systemDefault());
        Duration duration = info.totalCpuDuration()
            .orElse(Duration.ZERO);
        String owner = info.user().orElse("Unknown");
        long childrenCount = handle.children().count();
        // Print the process details
        System.out.printf("PID: %d%n", pid);
        System.out.printf("IsAlive: %b%n", isAlive);
        System.out.printf("Command: %s%n", command);
        System.out.printf("Arguments: %s%n",
            Arrays.toString(args));
        System.out.printf("CommandLine: %s%n",
            commandLine);
        System.out.printf("Start Time: %s%n", startTime);
        System.out.printf("CPU Time: %s%n", duration);
        System.out.printf("Owner: %s%n", owner);
        System.out.printf("Children Count: %d%n",
            childrenCount);
    }
}

PID: 4143
IsAlive: true
Command: /opt/jdk17/bin/java
Arguments: [-Dfile.encoding=UTF-8,
    -classpath,
    [<path-to-project>]/bin,
    -XX:+ShowCodeDetailsInExceptionMessages,
    com.jdojo.process.CurrentProcessInfo]
CommandLine: /opt/openjdk-16.36/bin/java
    -Dfile.encoding=UTF-8
    -classpath [<path-to-project>]/bin
    -XX:+ShowCodeDetailsInExceptionMessages
    com.jdojo.process.CurrentProcessInfo
Start Time: 2021-07-16T14:50:18.870+02:00
    [Europe/Berlin]
CPU Time: PT0.06S
Owner: peter
Children Count: 0

Listing 11-3A CurrentProcessInfo Class That Prints the Details of the Current Process

```

## 比较进程

比较两个进程的相等性或有序性是很棘手的。您不能依赖 PID 来实现进程的平等。进程终止后，操作系统重用 PID。您可以检查进程的开始时间以及 PIDs 如果相同，则两个进程可能相同。`ProcessHandle`接口的默认实现的`equals()`方法检查两个进程的以下三条信息是否相等:

*   两个进程的`ProcessHandle`接口的实现类必须相同。

*   进程必须有相同的 PID。

*   进程必须同时启动。

Note

在`ProcessHandle`接口中使用`compareTo()`方法的默认实现对于排序不是很有用。它比较了两个进程的 PID。

## 创建进程

您需要使用`ProcessBuilder`类的一个实例来启动一个新的本地进程。一个`ProcessBuilder`管理本地进程属性的集合。一旦为进程设置了所有属性，就可以调用它的`start()`方法来启动一个新的本地进程。存储在`ProcessBuilder`中的属性将用于启动新进程。您可以多次调用`start()`方法，使用存储在`ProcessBuilder`中的属性启动新的进程。`start()`方法返回代表新的本地进程的`Process`类的实例。您可以使用以下构造函数之一来创建`ProcessBuilder`类的实例:

*   `ProcessBuilder(String... command)`

*   `ProcessBuilder(List<String> command)`

构造函数允许您指定操作系统程序和参数。假设您想在 Linux 上从`/opt/jdk17/bin`内部运行`java`程序，如下所示:

```java
/opt/jdk17/bin/java --version

```

您将创建一个`ProcessBuilder`来表示这个命令，如下所示:

```java
ProcessBuilder pb = new ProcessBuilder(
    "/opt/jdk17/bin/java", "--version");

```

使用`ProcessBuilder`类的方法，您可以管理进程的以下属性:

*   一个命令

*   一个环境

*   工作目录

*   标准输入/输出(`stdin`、`stdout`和`stderr`)

*   标准错误流的重定向属性

命令只是代表外部程序及其参数的字符串列表。可以在`ProcessBuilder`类的构造函数中设置命令。以下方法允许您检索命令字符串并设置更多命令字符串:

*   `List<String> command()`

*   `ProcessBuilder command(String... command)`

不带任何参数的`command()`方法返回已经在`ProcessBuilder`中设置的命令字符串。带有 varargs 参数的`command()`方法允许您添加更多的命令字符串。下面的代码片段创建了一个`ProcessBuilder`来在 Linux 上启动 JVM。它使用`command()`方法来设置命令属性:

```java
ProcessBuilder pb = new ProcessBuilder()
    .command("/opt/jdk17/bin/java",
        "--module-path",
        "myModulePath",
        "--module",
        "myModule/className");

```

环境是依赖于系统的键值对的列表。它被初始化为从静态方法`System.getEnv()`返回的`Map<String,String>`的副本。您需要使用`ProcessBuilder`类的`environment()`方法来获取`Map<String,String>`并将键值对添加到映射中。下面的代码片段向您展示了如何为`ProcessBuilder`设置环境属性:

```java
ProcessBuilder pb = new ProcessBuilder("mycommand");
Map<String,String> env = pb.environment();
env.put("arg1", "value1");
env.put("arg2", "value2");

```

默认情况下，新进程的工作目录是当前 Java 进程的工作目录，通常是由系统属性`user.dir`命名的目录。`ProcessBuilder`类中的以下方法允许您获取和设置工作目录:

*   `File directory()`

*   `ProcessBuilder directory(File directory)`

下面的代码片段向您展示了如何在 Linux 上将工作目录设置为`/home/USER/mydir`:

```java
ProcessBuilder pb = new ProcessBuilder("myCommand")
    .directory(new File("/home/USER/mydir"));

```

由`ProcessBuilder`的`start()`方法创建的新进程被创建为当前进程的子进程，当前进程是运行代码的 Java 进程。换句话说，当前的 Java 进程是新创建的进程的父进程。新进程不拥有标准 I/O ( `stdin`、`stdout`和`stderr`)的终端或控制台。默认情况下，新进程的 I/O 通过管道连接到父进程。您可以选择通过调用一个`ProcessBuilder`的`inheritIO()`方法将新进程的标准 I/O 设置为与其父进程相同。在`ProcessBuilder`类中有几个`redirectXxx()`方法可以为新进程定制标准的 I/O，例如，将标准的错误流设置到一个文件中，这样所有的错误都会被记录到一个文件中。

一旦您配置了进程的所有属性，您就可以调用`start()`来启动进程:

```java
// Start a new process
Process newProcess = pb.start();

```

您可以多次调用`ProcessBuilder`类的`start()`方法来启动多个具有先前存储在其中的相同属性的进程。这有一个性能优势，您可以创建一个`ProcessBuilder`实例，并重用它来多次启动相同的进程。

您可以使用`Process`类的`toHandle()`方法获得进程的进程句柄:

```java
// Get the process handle
ProcessHandle handle = newProcess.toHandle();

```

您可以使用进程句柄来销毁进程，等待进程完成，或者查询进程的状态和属性，如其子进程、子进程、父进程、使用的 CPU 时间等。您获得的关于进程的信息以及您对进程的控制取决于操作系统的访问控制。

很难拿出例子来创建可以在所有操作系统上运行的进程。如果您可以运行本书中的其他示例，这意味着您的机器上安装了 JDK17。您可以使用机器上的`java`程序来启动示例中的其他进程。您可以使用当前进程的 command 属性，即当前运行的`java`程序，来获取 Java 程序在您的机器上的路径，因此这些示例将在所有平台上工作。

让我们看几个使用 Java 程序创建本地进程的例子。您可以分别使用`–version`和`-version`选项将 Java 产品版本信息打印到标准输出和标准错误中，如下所示:

```java
/opt/jdk17/bin/java --version
openjdk 17 2021-05-16
OpenJDK Runtime Environment (build 17+1-123)
OpenJDK 64-Bit Server VM (build 17+1-123, mixed mode, sharing)

/opt/jdk17/bin/java -version
openjdk 17 2021-05-16
OpenJDK Runtime Environment (build 17+1-123)
OpenJDK 64-Bit Server VM (build 17+1-123, mixed mode, sharing)

```

在前面的输出中，您看不到输出在哪里打印的任何区别。两个输出都打印到同一个控制台，因为默认情况下，标准输出和标准错误都映射到控制台。但是，当您尝试在程序中捕获这两个命令的输出时，您会看到不同之处。

清单 11-4 显示了一个运行`java –version`命令将 Java 产品信息打印到标准输出的程序。

```java
// PipedIO.java
package com.jdojo.process;
import java.io.IOException;
public class PipedIO {
    public static void main(String[] args) {
        // Get the path of the java program that started
        // this program
        String javaPath = ProcessHandle.current()
            .info()
            .command().orElse(null);
        if(javaPath == null) {
            System.out.println(
                "Could not get the java command's path.");
            return;
        }
        // Configure the ProcessBuilder
        ProcessBuilder pb =
            new ProcessBuilder(javaPath,  "--version");
        try {
            // Start a new java process
            Process p = pb.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    } 

}

Listing 11-4Capturing the Output of a Native Process

```

当你运行程序`ProcessIO`类时，它不打印任何东西。产出去了哪里？程序创建了一个新进程，该进程的标准输出通过管道连接到父进程。如果您想要访问输出，您需要从适当的管道读取。当新进程的标准 I/O 通过管道传输到父进程时，您可以使用`Process`的以下方法来获取新进程的 I/O 流:

*   `OutputStream getOutputStream()`

*   `InputStream getInputStream()`

*   `InputStream getErrorStream()`

从`getOutputStream()`方法返回的`OutputStream`被连接到新进程的标准输入流。写入此输出流将通过管道传输到新进程的标准输入。

从`getInputStream()`返回的`InputStream`连接到新进程的标准输出。如果您想要捕获新进程的标准输出，您需要从这个输入流中读取。

从`getErrorStream()`返回的`InputStream`连接到新进程的标准误差。如果您想要捕获新进程的标准错误，您需要从这个输入流中读取。有时，您希望将输出合并到标准输出，并将标准错误合并到一个目的地。它给出了输出和错误的准确顺序，以便于解决问题。您可以调用`ProcessBuilder`的`redirectErrorStream(true)`方法，将写入标准错误的数据发送到标准输出。我很快会展示这类例子。

Note

您可以选择将新进程的标准 I/O 重定向到其他目的地，比如文件，在这种情况下，`getOutputStream()`、`getInputStream()`和`getErrorStream()`方法返回`null`。

清单 11-5 中的程序修复了在`PipedIO`类中得不到任何输出的问题。它读取并打印写入管道中标准输出流的数据。

```java
// CapturePipedIO.java
package com.jdojo.process;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class CapturePipedIO {
    public static void main(String[] args) {
        // Get the path of the java program that started
        // this program
        String javaPath = ProcessHandle.current()
                .info()
                .command().orElse(null);
        if (javaPath == null) {
            System.out.println(
                "Could not get the java command's path.");
            return;
        }
        // Configure the ProcessBuilder
        ProcessBuilder pb =
            new ProcessBuilder(javaPath, "--version");
        try {
            // Start a new java process
            Process p = pb.start();
            // Read and print the standard output stream
            // of the process
            try (BufferedReader input =
                    new BufferedReader(
                        new InputStreamReader(
                            p.getInputStream()))) {
                String line;
                while ((line = input.readLine()) != null) {
                    System.out.println(line);
                }
            } 

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

openjdk 17 2021-05-16
OpenJDK Runtime Environment (build 17+1-123)
OpenJDK 64-Bit Server VM (build 17+1-123, mixed mode, sharing)

Listing 11-5Capturing the Output of a Native Process

```

如果运行带有`-version`选项的`java`命令，输出将被写入标准错误。如果您将清单 11-5 中的选项从`–version`更改为`-version`，您将不会再次获得任何输出，因为输出将通过管道传输到标准错误流。有两种方法可以解决这个问题:

*   在程序中，从`Process`的`getErrorStream()`方法返回的`InputStream`读取，而不是从`getInputStream()`方法返回的`InputStream`读取。

*   将错误流重定向到标准输出流，并继续从标准输出中读取。

以下代码片段使用`java -version`命令创建了一个`ProcessBuilder`，并在标准输出中重定向了错误流:

```java
// Configure the ProcessBuilder
ProcessBuilder pb =
    new ProcessBuilder(javaPath, "-version")
    .redirectErrorStream(true);

```

如果您将创建清单 11-5 中的`ProcessBuilder`的语句改为这个语句，您的程序将运行良好。

新进程也可以继承父进程的标准 I/O。如果要将新进程的所有 I/O 目的地设置为与当前进程相同，请使用`ProcessBuilder`的`inheritIO()`方法，如下所示:

```java
// Configure the ProcessBuilder inheriting parent's I/O
ProcessBuilder pb =
    new ProcessBuilder(javaPath,  "--version")
    .inheritIO();

```

如果您更改清单 11-4 中的代码以匹配前面的代码片段，您将看到输出。

`ProcessBuilder.Redirect`嵌套类表示由`ProcessBuilder`创建的新进程的输入源和输出目的地。该类定义了以下三个`ProcessBuilder` `.Redirect`类型的常量:

*   `ProcessBuilder.Redirect DISCARD`:丢弃新进程的输出

*   `ProcessBuilder.Redirect.INHERIT`:表示新进程的输入源或输出目的地将与当前进程相同

*   `ProcessBuilder.Redirect.PIPE`:表示新进程将通过管道连接到当前进程，这是默认设置

您还可以使用`Process.Redirect`类的以下方法将新进程的输入和输出重定向到一个文件:

*   `ProcessBuilder.Redirect appendTo(File file)`

*   `ProcessBuilder.Redirect from(File file)`

*   `ProcessBuilder.Redirect to(File file)`

在前面的代码片段中，您看到了如何使用`ProcessBuilder`类的`inheritIO()`方法让新进程拥有与当前进程相同的标准 I/O。您可以按如下方式重写代码:

```java
// Configure the ProcessBuilder inheriting parent's I/O
ProcessBuilder pb =
    new ProcessBuilder(javaPath, "--version")
        .redirectInput(ProcessBuilder.Redirect.INHERIT)
        .redirectOutput(ProcessBuilder.Redirect.INHERIT)
        .redirectError(ProcessBuilder.Redirect.INHERIT);

```

下面的代码片段将新进程的标准输出重定向到当前目录中名为`java_product_details.txt`的文件:

```java
// Configure the ProcessBuilder
    ProcessBuilder pb =
        new ProcessBuilder(javaPath, "--version")
        .redirectOutput(
            ProcessBuilder.Redirect.to(
                new File("java_product_details.txt")));

```

让我们看一个复杂的例子，它将探索关于新的本地进程的更多信息。清单 11-6 包含一个名为`Job`的类的代码。它的`main()`方法需要两个参数:睡眠间隔和以秒为单位的睡眠持续时间。如果没有通过，该方法将使用 5 秒和 60 秒作为默认值。在第一部分，该方法尝试提取第一个和第二个参数(如果指定)。在第二部分中，它使用 ProcessHandle.current()方法获取执行该方法的当前进程的进程句柄。它读取当前进程的 PID，并打印一条包括 PID、睡眠间隔和睡眠持续时间的消息。最后，它开始一个 for 循环，并在睡眠间隔内保持睡眠，直到达到睡眠持续时间。在循环的每次迭代中，它都会打印一条消息。

```java
// Job.java
package com.jdojo.process;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
/**
 * An instance of this class is used as a job that sleeps
 * at a regular interval up to a maximum duration. The
 * sleep interval in seconds can be specified as the first
 * argument and the sleep duration as the second argument
 * while running this class. The default sleep interval
 * and sleep duration are 5 seconds and 60 seconds,
 * respectively. If these values are less than zero, zero
 * is used instead.
 */
public class Job {
    // The job sleep interval
    public static final long DEFAULT_SLEEP_INTERVAL = 5;
    // The job sleep duration
    public static final long DEFAULT_SLEEP_DURATION = 60;
    public static void main(String[] args) {
        long sleepInterval = DEFAULT_SLEEP_INTERVAL;
        long sleepDuration = DEFAULT_SLEEP_DURATION;
        // Get the passed in sleep interval
        if (args.length >= 1) {
            sleepInterval = parseArg(args[0],
                DEFAULT_SLEEP_INTERVAL);
            if (sleepInterval < 0) {
                sleepInterval = 0;
            }
        }
        // Get the passed in the sleep duration
        if (args.length >= 2) {
            sleepDuration = parseArg(args[1],
                DEFAULT_SLEEP_DURATION);
            if (sleepDuration < 0) {
                sleepDuration = 0;
            }
        }
        long pid = ProcessHandle.current().pid();
        System.out.printf(
            "Job (pid=%d) info: Sleep Interval"
            + "=%d seconds, Sleep Duration=%d "
            + "seconds.%n",
            pid, sleepInterval, sleepDuration);
        for (long sleptFor = 0; sleptFor < sleepDuration;
                sleptFor += sleepInterval) {
            try { 

                System.out.printf(
                    "Job (pid=%d) is going to"
                    + " sleep for %d seconds.%n",
                    pid, sleepInterval);
                // Sleep for the sleep interval
                TimeUnit.SECONDS.sleep(sleepInterval);
            } catch (InterruptedException ex) {
                System.out.printf("Job (pid=%d) was "
                        + "interrupted.%n", pid);
            }
        }
    }
    /**
     * Starts a new JVM to run the Job class.
     *
     * @param sleepInterval The sleep interval when the
     *   Job class is run. It is passed to the JVM as the
     *   first argument.
     * @param sleepDuration The sleep duration for the
     *    Job class. It is passed to the JVM as the
     *    second argument.
     * @return The new process reference of the newly
     * launched JVM or null if the JVM
     * cannot be launched.
     */
    public static Process startProcess(long sleepInterval,
            long sleepDuration) {
        // Store the command to launch a new JVM in a
        // List<String>
        List<String> cmd = new ArrayList<>();
        // Add command components in order
        addJvmPath(cmd);
        addModulePath(cmd);
        addClassPath(cmd);
        addMainClass(cmd);
        // Add arguments to run the class
        cmd.add(String.valueOf(sleepInterval));
        cmd.add(String.valueOf(sleepDuration));
        // Build the process attributes
        ProcessBuilder pb = new ProcessBuilder()
                .command(cmd)
                .inheritIO();
        String commandLine = pb.command()
                .stream() 

                .collect(Collectors.joining(" "));
        System.out.println(
            "Command used:\n" + commandLine);
        // Start the process
        Process p = null;
        try {
            p = pb.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return p;
    }
    /**
     * Used to parse the arguments passed to the JVM,
     * which in turn is passed to the main() method.
     *
     * @param valueStr The string value of the argument
     * @param defaultValue The default value of the
     *   argument if the valueStr is not an integer.
     * @return valueStr as a long or the defaultValue if
     * valueStr is not an integer.
     */
    private static long parseArg(String valueStr,
            long defaultValue) {
        long value = defaultValue;
        if (valueStr != null) {
            try {
                value = Long.parseLong(valueStr);
            } catch (NumberFormatException e) {
                // no action needed
            }
        }
        return value;
    }
    /**
     * Adds the JVM path to the command list. It first
     * attempts to use the command attribute of the
     * current process; failing that it relies on the
     * java.home system property.
     *
     * @param cmd The command list
     */ 

    private static void addJvmPath(List<String> cmd) {
        // First try getting the command to run the
        // current JVM
        String jvmPath = ProcessHandle.current()
            .info()
            .command().orElse("");
        if (jvmPath.length() > 0) {
            cmd.add(jvmPath);
        } else {
            // Try composing the JVM path using the
            // java.home system property
            final String FILE_SEPARATOR =
                System.getProperty("file.separator");
            jvmPath = System.getProperty("java.home")
                    + FILE_SEPARATOR + "bin"
                    + FILE_SEPARATOR + "java";
            cmd.add(jvmPath);
        }
    }
    /**
     * Adds a module path to the command list.
     *
     * @param cmd The command list
     */
    private static void addModulePath(List<String> cmd) {
        String modulePath
            = System.getProperty("jdk.module.path");
        if (modulePath != null
                && modulePath.trim().length() > 0) {
            cmd.add("--module-path");
            cmd.add(modulePath);
        }
    } 

    /**
     * Adds class path to the command list.
     *
     * @param cmd The command list
     */
    private static void addClassPath(List<String> cmd) {
        String classPath =
            System.getProperty("java.class.path");
        if (classPath != null
                && classPath.trim().length() > 0) {
            cmd.add("--class-path");
            cmd.add(classPath);
        }
    }
    /**
     * Adds a main class to the command list. Adds
     * module/className or just className depending on
     * whether the Job class was loaded in a named
     * module or unnamed module
     *
     * @param cmd The command list
     */
    private static void addMainClass(List<String> cmd) {
        Class<Job> cls = Job.class;
        String className = cls.getName();
        Module module = cls.getModule();
        if (module.isNamed()) {
            String moduleName = module.getName();
            cmd.add("--module");
            cmd.add(moduleName + "/" + className);
        } else {
            cmd.add(className);
        }
    }
}

Listing 11-6The Declaration of a Class Named Job

```

`Job`类包含一个启动新进程的`startProcess(long sleepInterval, long sleepDuration)`方法。它启动一个以`Job`类为主类的 JVM。它将休眠间隔和持续时间作为参数传递给 JVM。该方法试图构建一个命令来从`JDK_HOME\bin`目录启动`java`命令。如果`Job`类被加载到一个命名的模块中，它将构建一个类似这样的命令:

```java
JDK_HOME/bin/java --module-path <module-path> \
--module jdojo.process/com.jdojo.process.Job \
<sleepInterval> <sleepDuration>

```

如果`Job`类被加载到一个未命名的模块中，它会尝试构建一个如下所示的命令:

```java
JDK_HOME/bin/java \
-class-path <class-path> \
com.jdojo.process.Job \
<sleepInterval> <sleepDuration>

```

`startProcess()`方法打印用于启动进程的命令，尝试启动进程，并返回进程引用。

`addJvmPath()`方法将 JVM 路径添加到命令列表中。它试图获取当前 JVM 进程的命令，以用作新进程的 JVM 路径。如果它不可用，它会尝试从`java.home`系统属性构建它。

`Job`类包含几个实用方法，用于组成命令的一部分，并解析传递给`main()`方法的参数。有关描述，请参考他们的 Javadoc。

如果您想要启动一个应该运行 15 秒并每 5 秒唤醒一次的新进程，您可以使用`Job`类的`startProcess()`方法来实现:

```java
// Start a process that runs for 15 seconds
Process p = Job.startProcess(5, 15);

```

您可以使用您在清单 11-3 中创建的`CurrentProcessInfo`类的`printInfo()`方法打印进程细节:

```java
// Get the handle of the current process
ProcessHandle handle = p.toHandle();
// Print the process details
CurrentProcessInfo.printInfo(handle);

```

当进程终止时，您可以使用`ProcessHandle`的`onExit()`方法的返回值来运行任务:

```java
CompletableFuture<ProcessHandle> future = handle.onExit();
// Print a message when process terminates
future.thenAccept((ProcessHandle ph) -> {
    System.out.printf(
        "Job (pid=%d) terminated.%n", ph.pid());
});

```

您可以等待新进程终止，如下所示:

```java
// Wait for the process to terminate
future.get();

```

在这个例子中，`future.get()`将返回进程的`ProcessHandle`。我没有使用返回值，因为我已经在`handle`变量中有了它。

清单 11-7 包含了一个`StartProcessTest`类的代码，展示了如何使用`Job`类创建一个新的进程。在它的`main()`方法中，它创建一个新进程，打印进程细节，向进程添加一个关闭任务，等待进程终止，然后再次打印进程细节。请注意，该进程运行了 15 秒，但它只使用了 0.359375 秒的 CPU 时间，因为该进程的主线程大部分时间都在休眠。您可能会得到不同的输出。当程序在 Linux 上运行时，会生成输出。

```java
// StartProcessTest.java
package com.jdojo.process;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
public class StartProcessTest {
    public static void main(String[] args) {
        // Start a process that runs for 15 seconds
        Process p = Job.startProcess(5, 15);
        if (p == null) {
            System.out.println(
                "Could not create a new process.");
            return;
        }
        // Get the handle of the current process
        ProcessHandle handle = p.toHandle();
        // Print the process details
        CurrentProcessInfo.printInfo(handle);
        CompletableFuture<ProcessHandle> future =
            handle.onExit();
        // Print a message when process terminates
        future.thenAccept((ProcessHandle ph) -> {
            System.out.printf(
                "Job (pid=%d) terminated.%n",
                ph.pid());
        });
        try {
            // Wait for the process to complete
            future.get();
        } catch (InterruptedException
                | ExecutionException e) {
            e.printStackTrace();
        } 

        // Print process details again
        CurrentProcessInfo.printInfo(handle);
    }
}

Command used:
/opt/jdk17/bin/java
  --class-path /[<path-to-project>]/bin
  com.jdojo.process.Job 5 15
PID: 8701
IsAlive: true
Command: /opt/jdk17/bin/java
Arguments: [
  --class-path,
  /[<path-to-project>]/bin,
  com.jdojo.process.Job,
  5, 15 ]
CommandLine: /opt/jdk17/bin/java
  --class-path /[<path-to-project>]/bin
  com.jdojo.process.Job
  5 15
Start Time: 2021-07-16T18:11:42.510+02:00
  [Europe/Berlin]
CPU Time: PT0.01S
Owner: peter
Children Count: 0
Job (pid=8701) info:
  Sleep Interval=5 seconds, Sleep Duration=15 seconds.
Job (pid=8701) is going to sleep for 5 seconds.
Job (pid=8701) is going to sleep for 5 seconds.
Job (pid=8701) is going to sleep for 5 seconds.
Job (pid=8701) terminated.
PID: 8701
IsAlive: false
Command:
Arguments: []
CommandLine:
Start Time: 2021-07-16T18:11:58.489975569+02:00
  [Europe/Berlin]
CPU Time: PT0S
Owner: Unknown
Children Count: 0

Listing 11-7A StartProcessTest Class That Creates New Processes

```

## 获取进程句柄

有几种方法可以获得本机进程的句柄。对于由 Java 代码创建的进程，您可以使用`Process`类的`toHandle()`方法获得一个`ProcessHandle`。本机进程也可以从 JVM 外部创建。`ProcessHandle`接口包含以下方法来获取本地进程的句柄:

*   `static Optional<ProcessHandle> of(long pid)`

*   `static ProcessHandle current()`

*   `Optional<ProcessHandle> parent()`

*   `Stream<ProcessHandle> children()`

*   `Stream<ProcessHandle> descendants()`

*   `static Stream<ProcessHandle> allProcesses()`

`of()`静态方法为指定的`pid`返回一个`Optional<ProcessHandle>`。如果这个`pid`没有进程，则返回一个空的`Optional`。要使用这种方法，您需要知道进程的 PID:

```java
// Get the process handle of the process with the pid
// of 1234
Optional<ProcessHandle> handle = ProcessHandle.of(1234L);

```

`current()`静态方法返回当前进程的句柄，它总是执行代码的 Java 进程。你已经在清单 11-3 中看到了这样的例子。

`parent()`方法返回父进程的句柄。如果该进程没有父进程或者无法检索父进程，它将返回一个空的`Optional`。

`children()`方法返回该进程所有直接子进程的快照。不能保证此方法返回的进程仍处于活动状态。请注意，不活跃的进程没有子进程。

`descendants()`方法返回该进程所有直接或间接子进程的快照。

`allProcesses()`方法返回该进程可见的所有进程的快照。不能保证流在处理时包含操作系统中的所有进程。在拍摄快照后，可能已经终止或创建了进程。下面的代码片段打印了按 PID 排序的所有进程的 PID:

```java
System.out.printf("All processes PIDs:%n");
ProcessHandle.allProcesses()
    .map(ph -> ph.pid())
    .sorted()
    .forEach(System.out::println);

```

您可以为所有正在运行的进程计算不同类型的统计数据。您还可以在 Java 中创建一个任务管理器，它显示一个 UI，该 UI 显示所有正在运行的进程及其属性。清单 11-8 展示了如何获得运行时间最长的进程的详细信息以及使用 CPU 时间最多的进程。我比较了进程的开始时间以获得运行时间最长的进程，并比较了总的 CPU 持续时间以获得使用 CPU 时间最多的进程。您可能会得到不同的输出。当我在 Linux 上运行这个程序时，我得到了这个输出。

```java
// ProcessStats.java
package com.jdojo.process;
import java.time.Duration;
import java.time.Instant;
public class ProcessStats {
    public static void main(String[] args) {
        System.out.printf("Longest CPU User Process:%n");
        ProcessHandle.allProcesses()
                .max(ProcessStats::compareCpuTime)
                .ifPresent(CurrentProcessInfo::printInfo);
        System.out.printf("%nLongest Running Process:%n");
        ProcessHandle.allProcesses()
                .max(ProcessStats::compareStartTime)
                .ifPresent(CurrentProcessInfo::printInfo);
    } 

    public static int compareCpuTime(ProcessHandle ph1,
            ProcessHandle ph2) {
        return ph1.info()
                .totalCpuDuration()
                .orElse(Duration.ZERO)
                .compareTo(ph2.info()
                        .totalCpuDuration()
                        .orElse(Duration.ZERO));
    }
    public static int
    compareStartTime(ProcessHandle ph1,
            ProcessHandle ph2) {
        return ph1.info()
                .startInstant()
                .orElse(Instant.now())
                .compareTo(ph2.info()
                        .startInstant()
                        .orElse(Instant.now()));
    }
}

Longest CPU User Process:
PID: 2323
IsAlive: true
Command: /usr/lib/tracker/tracker-miner-fs
Arguments: []
CommandLine: /usr/lib/tracker/tracker-miner-fs
Start Time: 2021-07-16T13:43:03.590+02:00[Europe/Berlin]
CPU Time: PT14M35.72S
Owner: peter
Children Count: 0

Longest Running Process:
PID: 9019
IsAlive: true

Command: /opt/openjdk-16.36/bin/java
Arguments: [
  -Dfile.encoding=UTF-8,
  -classpath,
  [...],
  -XX:+ShowCodeDetailsInExceptionMessages,
  com.jdojo.process.ProcessStats]
CommandLine: /opt/jdk17/bin/java
  -Dfile.encoding=UTF-8
  -classpath [...]
  -XX:+ShowCodeDetailsInExceptionMessages
  com.jdojo.process.ProcessStats
Start Time: 2021-07-16T19:02:01.020+02:00[Europe/Berlin]
CPU Time: PT0.3S
Owner: peter
Children Count: 0

Listing 11-8Computing Process Statistics

```

## 终止进程

您可以使用`ProcessHandle`接口的`destroy()`或`destroyForcibly()`方法和`Process`类来终止一个进程。如果终止进程的请求成功，两个方法都返回`true`，否则返回`false`。`destroy()`方法请求正常终止，而`destroyForcibly()`方法请求强制终止。在发出终止进程的请求后，`isAlive()`方法可能会返回`true`一小段时间。

Note

您不能终止当前进程。在当前进程上调用`destroy()`或`destroyForcibly()`方法会抛出一个`IllegalStateException`。操作系统访问控制可以防止进程被终止。

进程的正常终止让进程干净地终止。进程的强制终止会立即终止该进程。进程是否正常终止取决于实现。你可以使用`ProcessHandle`接口的`supportsNormalTermination()`方法和`Process`类来检查一个进程是否支持正常终止。如果进程支持正常终止，该方法返回`true`，否则返回`false`。

调用这些方法之一来终止已经终止的进程不会导致任何操作。当进程终止时，`Process`类的`onExit()`返回的`CompletableFuture<Process>`和`ProcessHandle`接口的`onExit()`返回的`CompletableFuture<ProcessHandle>`为`completed`。

## 管理进程权限

当您运行前几节中的示例时，我假设没有安装 Java 安全管理器。如果安装了安全管理器，则需要授予适当的权限来启动、管理和查询本机进程:

*   如果您正在创建一个新的进程，您需要拥有`FilePermission(cmd,"execute")`权限，其中`cmd`是将创建该进程的命令的绝对路径。如果`cmd`不是绝对路径，你需要有`FilePermission("<<ALL FILES>>","execute")`权限。

*   要查询本地进程的状态并使用`ProcessHandle`接口中的方法销毁进程，应用程序需要拥有`RuntimePermission("manageProcess")`权限。

清单 11-9 包含一个获取进程计数并创建一个新进程的程序。它在没有安全管理器和有安全管理器的情况下重复这两个任务。

```java
// ManageProcessPermission.java
package com.jdojo.process;
import java.util.concurrent.ExecutionException;
public class ManageProcessPermission {
    public static void main(String[] args) {
        // Get the process count
        long count = ProcessHandle.allProcesses().count();
        System.out.printf("Process Count: %d%n", count);
        // Start a new process
        Process p = Job.startProcess(1, 3);
        try {
            p.toHandle().onExit().get();
        } catch (InterruptedException
                | ExecutionException e) {
            System.out.println(e.getMessage());
        }
        // Install a security manager
        SecurityManager sm = System.getSecurityManager();
        if (sm == null) {
            System.setSecurityManager(
                new SecurityManager());
            System.out.println(
                "A security manager is installed.");
        }
        // Get the process count
        try {
            count = ProcessHandle.allProcesses().count();
            System.out.printf("Process Count: %d%n",
                count);
        } catch (RuntimeException e) {
            System.out.println(
                "Could not get a process count: " +
                e.getMessage());
        }
        // Start a new process
        try {
            p = Job.startProcess(1, 3);
            p.toHandle().onExit().get();
        } catch (InterruptedException
                | ExecutionException
                | RuntimeException e) {
            System.out.println(
                "Could not start a new process: " +
                e.getMessage());
        }
    }
}

Listing 11-9Managing Processes with a Security Manager

```

假设您没有更改任何 Java 策略文件，尝试使用以下命令运行`ManageProcessPermission`类:

```java
/opt/jdk17/bin/java \
-Dfile.encoding=UTF-8 \
-classpath /[<path-to-project>]/bin \
-XX:+ShowCodeDetailsInExceptionMessages \
com.jdojo.process.ManageProcessPermission

Process Count: 332
Command used:
/opt/jd17/bin/java
  --class-path [...] com.jdojo.process.Job 1 3
Job (pid=3858) info: Sleep Interval=1 seconds,
  Sleep Duration=3 seconds.
Job (pid=3858) is going to sleep for 1 seconds.
Job (pid=3858) is going to sleep for 1 seconds.
Job (pid=3858) is going to sleep for 1 seconds.
A security manager is installed.
Could not get a process count: access denied
    ("java.lang.RuntimePermission" "manageProcess")
Could not start a new process: access denied
    ("java.lang.RuntimePermission" "manageProcess")

```

您可能会得到不同的输出。输出表明您能够在安装安全管理器之前获得进程计数并创建一个新进程。安装安全管理器后，Java 运行时在请求进程计数和创建新进程时抛出异常。要解决该问题，您需要授予以下权限:

*   `"manageProcess" RuntimePermission`，它将允许应用程序查询本机进程并创建一个新进程

*   Java 命令路径上的`"execute" FilePermission`,它将允许启动 JVM

*   `"jdk.module.path"`上的`"read" PropertyPermission`和`"java.class.path"`系统属性，因此`Job`类可以在构建启动 JVM 的命令行时读取这些属性

清单 11-10 包含一个将这四种权限授予所有代码的脚本。您需要将这个脚本添加到您机器上的`JDK_HOME/conf/security/java.policy`文件中。Java launcher 的路径是`/opt/jdk17/bin/java`，在 Linux 上只有在`/opt/jdk17`目录下安装了 JDK17 才有效。对于所有其他平台和 JDK 安装，修改该路径以指向您机器上正确的 Java 启动器。

```java
grant {
    permission java.lang.RuntimePermission
        "manageProcess";
    permission java.io.FilePermission
        "/opt/jdk17/bin/java", "execute";
    permission java.util.PropertyPermission
        "jdk.module.path", "read";
    permission java.util.PropertyPermission
        "java.class.path", "read";
};

Listing 11-10Addendum to the JDK_HOME/conf/security/java.policy File

```

如果使用相同的命令再次运行`ManageProcessPermission`类，应该会得到类似如下的输出:

```java
/opt/jdk17/bin/java \
  -Dfile.encoding=UTF-8 \
  -classpath /[<path-to-project>]/bin \
  -XX:+ShowCodeDetailsInExceptionMessages \
  com.jdojo.process.ManageProcessPermission

Process Count: 330
Command used:
/opt/jdk17/bin/java
  --class-path [...]
  com.jdojo.process.Job 1 3
Job (pid=6093) info: Sleep Interval=1 seconds,
  Sleep Duration=3 seconds.
Job (pid=6093) is going to sleep for 1 seconds.
Job (pid=6093) is going to sleep for 1 seconds.
Job (pid=6093) is going to sleep for 1 seconds.

A security manager is installed.

Process Count: 330
Command used:
/opt/jdk17/bin/java
  --class-path [...]
  com.jdojo.process.Job 1 3
Job (pid=6114) info: Sleep Interval=1 seconds,
  Sleep Duration=3 seconds.
Job (pid=6114) is going to sleep for 1 seconds.
Job (pid=6114) is going to sleep for 1 seconds.
Job (pid=6114) is going to sleep for 1 seconds.

```

## 摘要

进程 API 由与本地进程一起工作的类和接口组成。Java SE 从 1.0 版本开始就通过`Runtime`和`Process`类提供了进程 API。它允许您创建新的本机进程，管理它们的 I/O 流，并销毁它们。Java SE 的更高版本改进了 API，增加了一个名为`ProcessHandle`的接口来表示进程句柄。您可以使用进程句柄来查询和管理本机进程。

以下类和接口组成了进程 API: `Runtime`、`ProcessBuilder`、`ProcessBuilder.Redirect`、`Process`、`ProcessHandle`和`ProcessHandle.Info`。

`Runtime`类的`exec()`方法用于启动一个本地进程。在启动一个进程时，`ProcessBuilder`类的`start()`方法比`Runtime`类的`exec()`方法更可取。`ProcessBuilder.Redirect`类的一个实例代表一个进程的输入源或一个进程的输出目的地。

默认情况下，新进程的标准 I/O 通过管道连接到当前进程。您需要读写与管道相关的流，以访问新进程的标准 I/O。您可以选择将新进程的标准 I/O 设置为与当前进程相同，或者将 I/O 重定向到其他源/目标，如文件。

`Process`类的一个实例代表一个由 Java 程序创建的本地进程。

`ProcessHandle`接口的一个实例代表一个由 Java 程序或其他方式创建的进程；它是在 Java 9 中添加的，提供了几种查询和管理进程的方法。`ProcessHandle.Info`接口的一个实例代表一个进程的快照信息；它可以通过使用`Process`类的`info()`方法或`ProcessHandle`接口获得。如果你有一个`Process`实例，使用它的`toHandle()`方法得到一个`ProcessHandle`。

`ProcessHandle`接口的`onExit()`方法返回一个`CompletableFuture<ProcessHandle>`来终止进程。您可以使用返回的对象添加一个任务，该任务将在进程终止时执行。请注意，您不能在当前进程中使用此方法。

如果安装了安全管理器，应用程序需要有一个`"manageProcess" RuntimePermission`来查询和管理本地进程，并在从 Java 代码启动的进程的命令文件上有一个`"execute" FilePermission`。

## 练习

**练习** 1

什么是进程 API？

**练习** 2

`Runtime`类的实例代表什么？

**运动** 3

如何获得`Runtime`类的实例？

**演习** 4

如何使用`ProcessBuilder`类？这个类的什么方法被用来启动一个新的本地进程？

**锻炼** 5

`Process`类的实例代表什么？

**锻炼** 6

`ProcessHandle`接口的实例代表什么？你如何从一个`Process`那里获得一个`ProcessHandle`？

**锻炼** 7

如何获得代表正在运行的 Java 程序的当前进程的句柄？

**运动** 8

`ProcessHandle.Info`接口的实例代表什么？

**演习** 9

由`ProcessBuilder`类的`start()`方法创建的新进程的默认标准 I/O 是什么？

**运动** 10

可以使用 Process API 终止当前的 Java 程序吗？