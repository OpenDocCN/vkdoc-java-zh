# 10.用 Java 编写脚本

在本章中，您将学习:

*   什么是 Java 脚本

*   如何从 Java 执行脚本以及如何向脚本传递参数

*   如何在执行脚本时使用`ScriptContext`

*   如何在脚本中使用 Java 编程语言

*   如何实现脚本引擎

除非另有说明，本章中的所有示例程序都是清单 [10-1](#PC1) 中声明的`jdojo.script`模块的成员。

```
// module-info.java
module jdojo.script {
    requires java.scripting;
    requires jdk.unsupported;
    // <- needed for GraalVM JavaScript
    exports com.jdojo.script;
}

Listing 10-1The Declaration of a jdojo.script Module

```

JDK 的脚本支持在`java.scripting`模块中。使用 Java 脚本 API 的模块需要像`jdojo.script`模块一样读取`java.scripting`模块。

## Java 中的脚本是什么？

有人认为 Java 虚拟机(JVM)可以执行只用 Java 编程语言编写的程序，这是不正确的。JVM 执行语言无关的字节码。如果程序可以被编译成 Java 字节码，它可以执行用任何编程语言编写的程序。

*脚本语言*是一种编程语言，它提供了编写*脚本*的能力，这些脚本由一个叫做*脚本引擎*(或解释器)的运行时环境评估(或解释)。脚本是使用脚本语言的语法编写的字符序列，用作由解释器执行的程序的源。解释器解析脚本；产生中间代码，它是程序的内部表示；并执行中间代码。解释器将脚本中使用的变量存储在名为*符号表*的数据结构中。

通常，与编译编程语言不同，脚本语言中的源代码(称为脚本)不是编译的，而是在运行时解释的。然而，用一些脚本语言编写的脚本可以被编译成 Java 字节码，由 JVM 运行。

Java 已经包含了对 Java 平台的脚本支持，允许 Java 应用程序执行用 JavaScript、Groovy、Jython、JRuby 等脚本语言编写的脚本。支持双向通信。它还允许脚本访问由宿主应用程序创建的 Java 对象。Java 运行时和脚本语言运行时可以相互通信并使用彼此的功能。

Java 对脚本语言的支持来自 Java 脚本 API。Java 脚本 API 中的所有类和接口都在`javax.script`包中，这个包在`java.scripting`模块中。

在 Java 应用程序中使用脚本语言有几个好处:

*   大多数脚本语言都是动态类型的，这使得编写程序更加简单。

*   它们为开发和测试小型应用程序提供了一种更快捷的方式。

*   最终用户可以进行定制。

*   脚本语言可以提供 Java 中没有的特定领域的特性。

脚本语言也有一些缺点。例如，动态类型有利于编写更简单的代码；然而，当一个类型被错误地解释时，它就变成了一个缺点，你必须花很多时间去调试它。

Java 中的脚本支持让您可以利用两个世界的优势:它允许您使用 Java 编程语言来开发应用程序的静态类型、可伸缩和高性能部分，并使用适合特定领域需求的脚本语言来开发其他部分。

我在本章中经常使用术语*脚本引擎*。一个*脚本引擎*是一个执行用脚本语言编写的程序的软件组件。通常，但不一定，脚本引擎是脚本语言的解释器的实现。Java 已经实现了几种脚本语言的解释器。它们公开了编程接口，因此 Java 程序可以与它们进行交互。

JDK 曾经和一个叫做 Nashorn JavaScript 的脚本引擎捆绑在一起。不过在甲骨文的 JDK15 中已经去掉了 Nashorn，虽然在 OpenJDK 16 中你还能找到它。我们在这一章中不谈论纳松。

Java 可以执行任何为脚本引擎提供实现的脚本语言的脚本。比如 Java 可以执行用 GraalVM JavaScript、Groovy、Jython、JRuby 等编写的脚本。本章中的例子使用 Groovy 语言。

Note

作为 Nashorn JavaScript 引擎的替代品，您可以考虑使用 GraalVM 提供的 JavaScript 脚本引擎。不幸的是，这个不能很好地与 OpenJDK 17 配合使用。

## 在 Maven 中安装脚本引擎

如果您使用 Maven 作为构建工具，安装脚本引擎是很容易的。您所需要做的就是在您的`pom.xml`中添加一个非标准的存储库和某些依赖项:

```
<project xmlns:="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation=
      "http://maven.apache.org/POM/4.0.0
       https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>your.project.group.id</groupId>
  <artifactId>your.project.artifact.id</artifactId>
  <version>your.project.version</version>

<dependencies>
  <dependency>
    <groupId>org.codehaus.groovy</groupId>
    <artifactId>groovy-jsr223</artifactId>
    <version>3.0.8</version>
  </dependency>

  <!-- Other script engines:-->
  <dependency>
    <groupId>org.scijava</groupId>
    <artifactId>scripting-jython</artifactId>
    <version>1.0.0</version>
  </dependency>
  <dependency>
    <groupId>org.scijava</groupId>
    <artifactId>scripting-jruby</artifactId>
    <version>0.3.1</version>
  </dependency>
  <dependency>
    <groupId>org.graalvm.js</groupId>
    <artifactId>js-scriptengine</artifactId>
    <version>21.1.0</version>
  </dependency>
  <dependency>

    <!-- needed for GraalVM.js -->
    <groupId>org.graalvm.truffle</groupId>
    <artifactId>truffle-api</artifactId>
    <version>21.1.0</version>
  </dependency>
  ...
</dependencies>

<repositories>
  <repository>
    <id>Maven Repo</id>
    <url>
https://repo1.maven.org/maven2/
    </url>
  </repository>
  <repository>
    <id>Maven Repo 2</id>
    <url>
http://maven.imagej.net/content/repositories/releases/
    </url>
  </repository>
</repositories>

...
</project>

```

当然，您可以注释掉或删除不需要的脚本引擎。

## 执行您的第一个脚本

在本节中，您将使用 Groovy 在标准输出中打印一条消息。使用任何其他脚本语言都可以使用相同的步骤来打印消息，只有一点不同:您需要使用特定于脚本语言的代码来打印消息。要用 Java 运行脚本，您需要执行以下三个步骤:

*   创建脚本引擎管理器。

*   从脚本引擎管理器获取脚本引擎的实例。

*   调用脚本引擎的`eval()`方法执行脚本。

脚本引擎管理器是`ScriptEngineManager`类的一个实例:

```
// Create an script engine manager
ScriptEngineManager manager = new ScriptEngineManager();

```

接口的一个实例代表了 Java 程序中的一个脚本引擎。`ScriptEngineManager`的`getEngineByName(String engineShortName)`方法返回一个脚本引擎的实例。要获得 Groovy 引擎的实例，使用`Groovy`作为引擎的简称，如下所示:

```
// Get the reference of the Groovy engine
ScriptEngine engine =
    manager.getEngineByName("Groovy");

```

Note

脚本引擎的简称区分大小写。有时，一个脚本引擎有多个简称。groovy 引擎有以下简称:Groovy，Groovy。您可以使用这些引擎的简称中的任何一个，通过使用`ScriptEngineManager`类的`getEngineByName()`方法来获得它的实例。请注意可能与其他脚本引擎的名称冲突。

在 Groovy 中，`println()`函数在标准输出中打印一条消息。Groovy 中的字符串是用单引号或双引号括起来的字符序列。下面的代码片段将一个 Groovy 脚本存储在一个 Java `String`对象中，该对象将`Hello Scripting!`打印到标准输出:

```
// Store a Groovy script in a String
String script = "println('Hello Scripting!')";

```

如果您想在 Groovy 中使用双引号将字符串括起来，该语句将如下所示:

```
// Store a Groovy script in a String
String script = "println(\"Hello Scripting!\")";

```

或者

```
// Store a Groovy script in a String
String script = """println("Hello Scripting!")""";

```

要执行脚本，需要将脚本传递给脚本引擎的`eval()`方法。脚本引擎在运行脚本时可能会抛出一个`ScriptException`。因此，当您调用`ScriptEngine`的`eval()`方法时，您需要处理这个异常。以下代码片段执行存储在`script`变量中的脚本:

```
try {
    engine.eval(script);
} catch (ScriptException e) {
    e.printStackTrace();
}

```

清单 [10-2](#PC9) 包含程序在标准输出上打印信息的完整代码。

```
// HelloScripting.java
package com.jdojo.script;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class HelloScripting {
    public static void main(String[] args) {
        // Create a script engine manager
        ScriptEngineManager manager =
            new ScriptEngineManager();
        // Obtain a Groovy script engine from the manager
        ScriptEngine engine =
            manager.getEngineByName("Groovy");
        // Store the Groovy script in a String
        String script = """
            println('Hello Scripting!')
        """;
        try {
            // Execute the script
            engine.eval(script);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }
}

Hello Scripting!

Listing 10-2Printing a Message on the Standard Output Using Groovy

```

## 使用其他脚本语言

在 Java 程序中使用除 Groovy 之外的脚本语言非常简单。在使用脚本引擎之前，您只需要执行一项任务:在应用程序模块路径中包含特定脚本引擎的 JAR 文件。脚本引擎的实现者提供这些 JAR 文件。

Java 的服务提供者机制将列出其模块化 JAR 或 JAR 文件已经包含在应用程序的模块路径中的所有脚本引擎。接口的一个实例用于创建和描述一个脚本引擎。脚本引擎的提供者为`ScriptEngineFactory`接口提供了一个实现。`ScriptEngineManager`的`getEngineFactories()`方法返回所有可用脚本引擎工厂的`List<ScriptEngineFactory>`。`ScriptEngineFactory`的`getScriptEngine()`方法返回`ScriptEngine`的一个实例。工厂的其他几个方法返回关于引擎的元数据。

清单 [10-3](#PC10) 展示了如何打印所有可用脚本引擎的细节。输出显示 Groovy 的脚本引擎是可用的。它之所以可用，是因为我已经向 Maven 项目添加了`org.codehaus.groovy:groovy-jsr223:3.0.8`工件，这导致在我的机器上包含了模块路径所需的所有 jar。当您在模块路径中包含了一个脚本引擎，并且想知道脚本引擎的简称时，这个程序会很有帮助。运行该程序时，您可能会得到不同的输出。

```
// ListingAllEngines.java
package com.jdojo.script;
import java.util.List;
import javax.script.ScriptEngineFactory;
import javax.script.ScriptEngineManager;
public class ListingAllEngines {
    public static void main(String[] args) {
        ScriptEngineManager manager =
            new ScriptEngineManager();
        // Get the list of all available engines
        List<ScriptEngineFactory> list =
            manager.getEngineFactories();
        // Print the details of each engine
        for (ScriptEngineFactory f : list) {
            System.out.println("Engine Name:" +
                f.getEngineName());
            System.out.println("Engine Version:" +
                f.getEngineVersion());
            System.out.println("Language Name:" +
                f.getLanguageName());
            System.out.println("Language Version:" +
                f.getLanguageVersion());
            System.out.println("Engine Short Names:" +
                f.getNames());
            System.out.println("Mime Types:" +
                f.getMimeTypes());
            System.out.println(
                "----------------------------");
        }
    }
}

ScriptEngineFactory Info
Script Engine: Groovy Scripting Engine (2.0)
Engine Alias: groovy
Engine Alias: Groovy
Language: Groovy (3.0.8)

Listing 10-3Listing All Available Script Engines

```

清单 [10-4](#PC11) 展示了如何使用 JavaScript、Groovy、Jython 和 JRuby 在标准输出中打印消息。如果脚本引擎不可用，程序会打印一条消息说明这一点。您可能会得到不同的输出。

```
// HelloEngines.java
package com.jdojo.script;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class HelloEngines {
    public static void main(String[] args) {
        // Get the script engine manager
        ScriptEngineManager manager =
            new ScriptEngineManager();
        // Try executing scripts in JavaScript, Groovy,
        // Jython, and JRuby
        execute(manager, "JavaScript",
            "print('Hello JavaScript')");
        execute(manager, "Groovy",
            "println('Hello Groovy')");
        execute(manager, "jython",
            "print 'Hello Jython'");
        execute(manager, "jruby",
            "puts('Hello JRuby')");
    }
    public static void
    execute(ScriptEngineManager manager, String engineName,
            String script) {
        // Try getting the engine
        ScriptEngine engine =
            manager.getEngineByName(engineName);
        if (engine == null) {
            System.out.println(engineName +
                " is not available.");
            return;
        }
        // If we get here, it means we have the engine
        // installed. So, run the script
        try {
            engine.eval(script);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }
}

JavaScript is not available.
Hello Groovy
jython is not available.
jruby is not available.

Listing 10-4Printing

a Message on the Standard Output Using Different Scripting Languages

```

## 探索 javax.script 包

Java 中的 Java 脚本 API 由少量的类和接口组成。它们在`java.scripting`模块的`javax.script`包中。本节包含对这个包中的类和接口的简要描述。我将在后续章节中讨论它们的用法。

### ScriptEngine 和 ScriptEngineFactory 接口

`ScriptEngine`接口是 Java 脚本 API 中的主要接口，它的实例促进了以特定脚本语言编写的脚本的执行。

`ScriptEngine`接口的实现者也提供了`ScriptEngineFactory`接口的实现。一辆`ScriptEngineFactory`执行两项任务:

*   它创建脚本引擎的实例。

*   它提供关于脚本引擎的信息，如引擎名称、版本、语言等。

### AbstractScriptEngine 类

`AbstractScriptEngine`是一个抽象类。它为`ScriptEngine`接口提供了部分实现。除非实现脚本引擎，否则不能直接使用该类。

### ScriptEngineManager 类

`ScriptEngineManager`类为脚本引擎提供了发现和实例化机制。它还维护一个键-值对的映射，作为存储状态的`Bindings`接口的一个实例，由它创建的所有脚本引擎共享。

### 可编译接口和 CompiledScript 类

可选地，可以通过脚本引擎来实现`Compilable`接口，该脚本引擎允许编译脚本以便重复执行，而无需重新编译。

`CompiledScript`类被声明为抽象的。它是由脚本引擎的提供者扩展的。它以编译形式存储脚本，无需重新编译即可重复执行。请注意，使用`ScriptEngine`重复执行脚本会导致脚本每次都要重新编译，从而降低性能。支持脚本编译不需要脚本引擎。如果支持脚本编译，它必须实现`Compilable`接口。

### 可调用的接口

可选地，`Invocable`接口可以由脚本引擎实现，该脚本引擎可以允许调用先前已经编译过的脚本中的过程、函数和方法。

### 绑定接口和简单绑定类

实现`Bindings`接口的类的一个实例是一个键-值对的映射，有一个限制，即一个键必须是非 null、非空的`String`。它扩展了`java.util.Map`接口。`SimpleBindings`类是`Bindings`接口的一个实现。

### ScriptContext 接口和 SimpleScriptContext 类

接口的一个实例充当 Java 主机应用程序和脚本引擎之间的桥梁。它用于将 Java 主机应用程序的执行上下文传递给脚本引擎。脚本引擎可以在执行脚本时使用上下文信息。脚本引擎可以将其状态存储在实现`ScriptContext`接口的类的实例中，Java 主机应用程序可以访问该接口。

`SimpleScriptContext`类是`ScriptContext`接口的一个实现。

### ScriptException 类

`ScriptException`类是一个异常类。如果在脚本的执行、编译或调用过程中出现错误，脚本引擎会抛出一个`ScriptException`。该类包含三个有用的方法，分别叫做`getLineNumber()`、`getColumnNumber()`和`getFileName()`。这些方法报告发生错误的脚本的行号、列号和文件名。`ScriptException`类覆盖了`Throwable`类的`getMessage()`方法，并在它返回的消息中包含行号、列号和文件名。

### 发现和实例化脚本引擎

您可以使用`ScriptEngineFactory`或`ScriptEngineManager`创建脚本引擎。谁真正负责创建一个脚本引擎:`ScriptEngineFactory`、`ScriptEngineManager`，或者两者都有？简单的回答是，`ScriptEngineFactory`总是负责创建脚本引擎的实例。下一个问题是“a `ScriptEngineManager`的作用是什么？”

A `ScriptEngineManager`使用服务提供者机制来定位所有可用的脚本引擎工厂。服务提供者机制已经在本书的第 7 章中讨论过了。

一个`ScriptEngineManager`定位并实例化所有可用的`ScriptEngineFactory`类。您可以使用`ScriptEngineManager`类的`getEngineFactories()`方法获得所有工厂类的实例列表。当您调用管理器的一个方法来获得一个基于某个标准的脚本引擎时，例如通过名称获得引擎的`getEngineByName(String shortName)`方法，管理器搜索该标准的所有工厂并返回匹配的脚本引擎引用。如果没有工厂能够提供匹配的引擎，经理返回`null`。请参考清单 [10-3](#PC10) 了解更多关于列出所有可用工厂和描述它们可以创建的脚本引擎的详细信息。

现在你知道了`ScriptEngineManager`并不创建脚本引擎的实例。相反，它查询所有可用的工厂，并将工厂创建的脚本引擎的引用传递回调用者。

为了使讨论完整，让我们添加一个创建脚本引擎的方法。您可以通过三种方式创建脚本引擎的实例:

*   直接实例化脚本引擎类。

*   直接实例化脚本引擎工厂类，调用其`getScriptEngine()`方法。

*   使用`ScriptEngineManager`类的`getEngineByXxx()`方法之一。

建议使用`ScriptEngineManager`类来获取脚本引擎的实例。这个方法允许由同一个管理器创建的所有引擎共享一个状态，这个状态是作为`Bindings`接口的一个实例存储的一组键-值对。`ScriptEngineManager`实例存储这个状态。使用此方法还会使您的代码不知道实际的脚本引擎/工厂实现类。

Note

一个应用程序中可能有多个`ScriptEngineManager`类的实例。在这种情况下，每个`ScriptEngineManager`实例维护一个它创建的所有引擎共有的状态。也就是说，如果两个引擎是由`ScriptEngineManager`类的两个不同实例获得的，那么这些引擎将不会共享由它们的管理器维护的一个公共状态，除非您以编程方式实现这一点。

## 执行脚本

一个`ScriptEngine`可以执行一个`String`和一个`Reader`中的脚本。使用`Reader`，您可以执行存储在网络或文件中的脚本。`ScriptEngine`的`eval()`方法的以下版本之一用于执行脚本:

*   `Object eval(String script)`

*   `Object eval(Reader reader)`

*   `Object eval(String script, Bindings bindings)`

*   `Object eval(Reader reader, Bindings bindings)`

*   `Object eval(String script, ScriptContext context)`

*   `Object eval(Reader reader, ScriptContext context)`

`eval()`方法的第一个参数是脚本的源。第二个参数允许您将信息从宿主应用程序传递到脚本引擎，这些信息可以在脚本执行期间使用。

在清单 [10-2](#PC9) 中，您看到了如何使用第一个版本的`eval()`方法使用`String`来执行脚本。在本节中，您将把您的脚本存储在一个文件中，并使用一个`Reader`对象作为脚本的源，它将使用第二个版本的`eval()`方法。下一节将讨论`eval()`方法的其他四个版本。通常，脚本文件会被赋予一个`.js`扩展名。

清单 [10-5](#PC12) 显示了名为`helloscript.groovy`的文件的内容。它在 Groovy 中只包含一个在标准输出中打印消息的语句。

```
// Print a message
println('Hello from Groovy!')

Listing 10-5The Contents of the helloscript.groovy File

```

清单 [10-6](#PC13) 有执行保存在`helloscript.groovy`文件中脚本的 Java 程序，该文件应该保存在当前目录下的`scripts`子目录中。如果没有找到脚本文件，程序会在需要的地方打印出`helloscript.js`文件的完整路径。如果您在执行脚本文件时遇到问题，请尝试在`main()`方法中使用绝对路径，例如 Windows 上的`C:\scripts\helloscript.js`，假设`helloscript.js`文件保存在`C:\scripts`目录中。本章示例中使用的所有脚本都在源代码中的`Java9APIsAndModules\scripts`目录下提供。

```
// ReaderAsSource.java
package com.jdojo.script;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class ReaderAsSource {
    public static void main(String[] args) {
        // Construct the script file path
        String scriptFileName =
            "scripts/helloscript.groovy";
        Path scriptPath = Paths.get(scriptFileName);
        // Make sure the script file exists. If not,
        // print the full path of the script file and
        // terminate the program.
        if (!Files.exists(scriptPath)) {
            System.out.println(
                scriptPath.toAbsolutePath() +
                " does not exist.");
            return;
        }
        // Get the Groovy script engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        try {
            // Get a Reader for the script file
            Reader scriptReader = Files.newBufferedReader(
                scriptPath);
            // Execute the script in the file
            engine.eval(scriptReader);
        } catch (IOException | ScriptException e) {
            e.printStackTrace();
        }
    }
}

Hello from Groovy!

Listing 10-6Executing a Script Stored in a File

```

在实际应用程序中，您应该将所有脚本存储在允许修改脚本而无需修改和重新编译 Java 代码的文件中。在本章的大部分例子中，你不会遵循这个规则；您将把您的脚本存储在`String`对象中，以保持代码简短。

## 传递参数

Java 脚本 API 允许您将参数从主机环境(Java 应用程序)传递到脚本引擎，反之亦然。在本节中，您将看到宿主应用程序和脚本引擎之间的参数传递机制的技术细节。

### 从 Java 代码向脚本传递参数

Java 程序可以向脚本传递参数。Java 程序也可以在脚本执行后访问脚本中声明的全局变量。让我们讨论一个简单的例子，Java 程序向脚本传递一个参数。考虑清单 [10-7](#PC14) 中向脚本传递参数的程序。

```
// PassingParam.java
package com.jdojo.script;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class PassingParam {
    public static void main(String[] args) {
        // Get the Groovy engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        // Store the script in a String. Here, msg is a
        // variable that we have not declared in the script
        String script = "println(msg)";
        try {
            // Store a parameter named msg in the engine
            engine.put("msg",
                "Hello from the Java program");
            // Execute the script
            engine.eval(script);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }
}

Hello from the Java program

Listing 10-7Passing Parameters from a Java Program to Scripts

```

程序在`String`中存储一个脚本，如下所示:

```
// Store the script in a String
String script = "println(msg)";

```

在语句中，脚本引擎将执行的脚本是

```
println(msg)

```

注意`msg`是在`println()`函数调用中使用的变量。脚本没有声明`msg`变量，也没有给它赋值。如果您试图在不告诉引擎什么是`msg`变量的情况下执行这个脚本，引擎将抛出一个异常，声明它不理解名为`msg`的变量的含义。这就是将参数从 Java 程序传递到脚本引擎的概念发挥作用的地方。

可以通过几种方式将参数传递给脚本引擎。最简单的方法是使用脚本引擎的`put(String paramName, Object paramValue)`方法，它接受两个参数:

*   第一个参数是参数的名称，它需要与脚本中变量的名称相匹配。

*   第二个参数是参数的值。

在您的例子中，您希望将一个名为`msg`的参数传递给脚本引擎，它的值是一个`String`。调用`put()`的方法是

```
// Store the value of the msg parameter in the engine
engine.put("msg", "Hello from Java program");

```

注意，在调用`eval()`方法之前，必须先调用引擎的`put()`方法。在您的例子中，当引擎试图执行`print(msg)`时，它将使用您传递给引擎的`msg`参数的值。

大多数脚本引擎允许您使用传递给它的参数名作为脚本中的变量名。当您传递名为`msg`的参数值并在清单 [10-7](#PC14) 的脚本中将它用作变量名时，您看到了这种例子。脚本引擎可能要求在脚本中声明变量，例如，PHP 中的变量名必须以前缀`$`开头，JRuby 中的全局变量名必须包含前缀`$`。如果您想将名为`msg`的参数传递给 JRuby 中的脚本，您的代码如下所示:

```
// Get the JRuby script engine
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("jruby");
// Must use the $ prefix in JRuby script
String script = "puts($msg)";
// No $ prefix used in passing the msg parameter to the
// JRuby engine
engine.put("msg", "Hello from Java");
// Execute the script
engine.eval(script);

```

传递给脚本的 Java 对象的属性和方法可以在脚本中访问，就像在 Java 代码中访问一样。不同的脚本语言使用不同的语法来访问脚本中的 Java 对象。例如，您可以在清单 [10-7](#PC14) 所示的示例中使用表达式`msg.toString()`，输出将是相同的。在这种情况下，您正在调用变量`msg`的`toString()`方法。将清单 [10-7](#PC14) 中赋值给`script`变量的语句改为如下，并运行程序，程序将产生相同的输出:

```
String script = "println(msg.toString())";

```

### 从脚本向 Java 代码传递参数

脚本引擎可以使其全局范围内的变量对 Java 代码可用。`ScriptEngine`的`get(String variableName)`方法用于访问 Java 代码中的那些变量。它返回一个 Java `Object`。全局变量的声明依赖于脚本语言。以下代码片段声明了一个全局变量，并在 Groovy 中为其赋值:

```
// Declare a variable named year in Groovy
// Note the missing of the 'def' in front of it. If you
// don't prepend 'def', Groovy puts the variable in a
// script-wide global scope.
year = 1969;

```

清单 [10-8](#PC21) 包含了一个程序，展示了如何从 Java 代码访问 Groovy 中的一个全局变量。

```
// AccessingScriptVariable.java
package com.jdojo.script;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class AccessingScriptVariable {
    public static void main(String[] args) {
        // Get the Groovy engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        // Write a script that declares a global variable
        // named year and assign it a value of 1969.
        String script = "year = 1969";
        try {
            // Execute the script
            engine.eval(script);
            // Get the year global variable from the
            // engine
            Object year = engine.get("year");
            // Print the class name and the value of the
            // variable year
            System.out.println("year's class: "  +
                year.getClass().getName());
            System.out.println("year's value: " +
                year);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }
}

year's class: java.lang.Integer
year's value: 1969

Listing 10-8Accessing Script Global Variables in Java Code

```

程序在脚本中声明了一个全局变量`year`，并给它赋值`1969`，如下所示:

```
String script = "year = 1969";

```

当脚本执行时，引擎将`year`变量添加到它的状态中。在 Java 代码中，引擎的`get()`方法用于检索`year`变量的值，如下所示:

```
Object year = engine.get("year");

```

当脚本中声明了`year`变量时，您没有指定它的数据类型。脚本变量值到适当 Java 对象的转换是自动执行的。在这种情况下，值`1969`被评估为一个`Integer`。

## 高级参数传递技术

为了理解参数传递机制的细节，必须清楚地理解三个术语:绑定、范围和上下文。这些术语起初令人困惑。本节使用以下步骤解释参数传递机制:

*   首先，它定义了这些术语。

*   其次，它定义了这些术语之间的关系。

*   第三，它解释了如何在 Java 代码中使用它们。

### 粘合剂

一个`Bindings`是一组键-值对，其中所有键必须是非空的、非空字符串。在 Java 代码中，`Bindings`是`Bindings`接口的一个实例。`SimpleBindings`类是`Bindings`接口的一个实现。脚本引擎可以提供自己的`Bindings`接口实现。

Note

如果你熟悉`java.util.Map`界面，就很容易理解`Bindings`。`Bindings`接口继承自`Map<String,Object>`接口。因此，`Bindings`只是一个`Map`，它的键必须是非空的非空字符串。

清单 [10-9](#PC24) 展示了如何使用`Bindings`。它创建一个`SimpleBindings`的实例，添加一些键值对，检索键值，删除键值对，等等。`Bindings`接口的`get()`方法返回`null`，如果键不存在或者键存在且其值为`null`。如果你想测试一个键是否存在，你需要调用它的`contains()`方法。

```
// BindingsTest.java
package com.jdojo.script;
import javax.script.Bindings;
import javax.script.SimpleBindings;
public class BindingsTest {
    public static void main(String[] args) {
        // Create a Bindings instance
        Bindings params = new SimpleBindings();
        // Add some key-value pairs
        params.put("msg", "Hello");
        params.put("year", 1969);
        // Get values
        Object msg = params.get("msg");
        Object year = params.get("year");
        System.out.println("msg = " + msg);
        System.out.println("year = " + year);
        // Remove year from Bindings
        params.remove("year");
        year = params.get("year");
        boolean containsYear = params.containsKey("year");
        System.out.println("year = " + year);
        System.out.println("params contains year = " +
            containsYear);
    }
}

msg = Hello
year = 1969
year = null
params contains year = false

Listing 10-9Using Bindings Objects

```

你不能单独使用一个`Bindings`。通常，您会使用它将参数从 Java 代码传递到脚本引擎。`ScriptEngine`接口包含一个返回`Bindings`接口实例的`createBindings()`方法。这个方法给脚本引擎一个机会来返回一个`Bindings`接口的特殊实现的实例。您可以使用如下所示的方法:

```
// Get the Groovy engine
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName(
    "Groovy");
// Do not instantiate SimpleBindings class directly.
// Use the createBindings() method of the engine to create
// a Bindings.
Bindings params = engine.createBindings();
// Work with params as usual

```

### 范围

让我们转到下一个术语，即范围。范围用于绑定。绑定的范围决定了它的键值对的可见性。在多个作用域中可以有多个绑定。但是，一个绑定只能出现在一个范围内。如何指定绑定的范围？我很快会谈到这一点。

使用`Bindings`的作用域可以让您按照层次顺序为脚本引擎定义参数变量。如果在引擎状态下搜索变量名，首先搜索优先级较高的`Bindings`，然后是优先级较低的`Bindings`。返回找到的第一个变量的值。Java 脚本 API 定义了两个范围。它们在`ScriptContext`接口中被定义为两个`int`常量。他们是

*   `ScriptContext.ENGINE_SCOPE`

*   `ScriptContext.GLOBAL_SCOPE`

引擎范围的优先级高于全局范围。如果向两个`Bindings`添加具有相同键的两个键-值对，一个在引擎范围内，一个在全局范围内，那么每当需要解析与键同名的变量时，都会使用引擎范围内的键-值对。

理解作用域对于一个`Bindings`的作用是如此重要，以至于我通过另一个类比来解释它。考虑一个有两组变量的 Java 类:一组包含类中的所有实例变量，另一组包含方法中的所有局部变量。这两组变量及其值是两个`Bindings`。这些`Bindings`中的变量类型定义了作用域。为了便于讨论，我定义了两个范围:实例范围和本地范围。当执行一个方法时，首先在局部范围`Bindings`中查找变量名，因为局部变量优先于实例变量。如果在本地作用域`Bindings`中没有找到变量名，就在实例作用域`Bindings`中查找。当一个脚本被执行时，`Bindings`和它们的作用域扮演着相似的角色。

### 定义脚本上下文

脚本引擎在上下文中执行脚本。您可以将上下文视为脚本执行的环境。Java 宿主应用程序为脚本引擎提供了两样东西:脚本和脚本需要执行的上下文。接口的一个实例代表一个脚本的上下文。`SimpleScriptContext`类是`ScriptContext`接口的一个实现。脚本上下文由四部分组成:

*   一组`Bindings`，其中每个`Bindings`与一个不同的作用域相关联

*   脚本引擎用来读取输入的`Reader`

*   脚本引擎用来写输出的一个`Writer`

*   脚本引擎用来写入错误输出的错误`Writer`

上下文中的一组`Bindings`用于向脚本传递参数。上下文中的读取器和写入器分别控制脚本的输入源和输出目的地。例如，通过将文件编写器设置为编写器，可以将脚本的所有输出发送到文件。

每个脚本引擎都维护一个默认的脚本上下文，用于执行脚本。到目前为止，您已经在没有提供脚本上下文的情况下执行了几个脚本。在这些情况下，脚本引擎使用它们的默认脚本上下文来执行脚本。在这一节中，我将介绍如何单独使用`ScriptContext`。在下一节中，我将介绍在脚本执行期间如何将一个`ScriptContext`传递给一个`ScriptEngine`。

您可以使用`SimpleScriptContext`类创建一个`ScriptContext`接口的实例:

```
// Create a script context
ScriptContext ctx = new SimpleScriptContext();

```

一个`SimpleScriptContext`类的实例维护两个`Bindings`实例:一个用于引擎范围，一个用于全局范围。当您创建`SimpleScriptContext`的实例时，就会创建引擎范围内的`Bindings`。要使用全局范围`Bindings`，您需要创建一个`Bindings`接口的实例。

默认情况下，`SimpleScriptContext`类将上下文的输入读取器、输出写入器和错误写入器分别初始化为标准输入`System.in`、标准输出`System.out`和标准错误输出`System.err`。您可以使用`ScriptContext`接口的`getReader()`、`getWriter()`和`getErrorWriter()`方法分别从`ScriptContext`中获取阅读器、编写器和错误编写器的引用。还提供了 Setter 方法来设置读取器和编写器。下面的代码片段显示了如何获取阅读器和编写器。它还展示了如何将 writer 设置为`FileWriter`以将脚本输出写入文件:

```
// Get the reader and writers from the script context
Reader inputReader = ctx.getReader();
Writer outputWriter = ctx.getWriter();
Writer errWriter = ctx.getErrorWriter();
// Write all script outputs to an out.txt file
Writer fileWriter = new FileWriter("out.txt");
ctx.setWriter(fileWriter);

```

在创建了`SimpleScriptContext`之后，您可以开始在引擎范围`Bindings`中存储键值对，因为当您创建`SimpleScriptContext`对象时，在引擎范围中创建了一个空的`Bindings`。`setAttribute()`方法用于向`Bindings`添加一个键值对。您必须为`Bindings`提供键名、值和范围。以下代码片段添加了三个键值对:

```
// Add three key-value pairs to the engine scope bindings
ctx.setAttribute("year", 1969, ScriptContext.ENGINE_SCOPE);
ctx.setAttribute("month", 9, ScriptContext.ENGINE_SCOPE);
ctx.setAttribute("day", 19, ScriptContext.ENGINE_SCOPE);

```

如果您想在全局范围内将键值对添加到`Bindings`中，您需要首先创建并设置`Bindings`，如下所示:

```
// Add a global scope Bindings to the context
Bindings globalBindings = new SimpleBindings();
ctx.setBindings(globalBindings,
    ScriptContext.GLOBAL_SCOPE);

```

现在，您可以使用`setAttribute()`方法在全局范围内向`Bindings`添加键值对，如下所示:

```
// Add two key-value pairs to the global scope bindings
ctx.setAttribute("year", 1982,
    ScriptContext.GLOBAL_SCOPE);
ctx.setAttribute("name", "Boni",
    ScriptContext.GLOBAL_SCOPE);

```

此时，您可以可视化`ScriptContext`实例的状态，如图 [10-1](#Fig1) 所示。

![../images/323070_3_En_10_Chapter/323070_3_En_10_Fig1_HTML.jpg](../images/323070_3_En_10_Chapter/323070_3_En_10_Fig1_HTML.jpg)

图 10-1

SimpleScriptContext 类实例的图示视图

您可以在`ScriptContext`上执行多项操作。您可以使用`setAttribute(String name, Object value, int scope)`方法为已存储的密钥设置不同的值。对于指定的键和范围，可以使用`removeAttribute(String name, int scope)`方法移除键-值对。您可以使用`getAttribute(String name, int scope)`方法获得指定范围内的键值。

使用`ScriptContext`可以做的最有趣的事情是检索一个键值，而不用使用它的`getAttribute(String name)`方法指定它的作用域。一个`ScriptContext`首先在引擎范围`Bindings`中搜索关键字。如果在引擎范围内没有找到，则在全局范围内搜索`Bindings`。如果在这些范围中找到该键，则返回首先找到该键的范围中的相应值。如果两个范围都不包含该键，则返回`null`。

在您的示例中，您已经在引擎范围和全局范围中存储了名为`year`的键。当首先搜索引擎范围时，下面的代码片段从引擎范围返回关键字`year`的`1969`。`getAttribute()`方法的返回类型是`Object`:

```
// Get the value of the key year without specifying the
// scope. It returns 1969 from the Bindings in the engine
// scope.
int yearValue = (Integer) ctx.getAttribute("year");

```

您只在全局范围内存储了名为`name`的键。如果尝试检索其值，将首先搜索引擎范围，这不会返回匹配项。随后，搜索全局范围，并返回值`"Boni"`,如下所示:

```
// Get the value of the key named name without specifying
// the scope.
// It returns "Boni" from the Bindings in the global scope.
String nameValue = (String) ctx.getAttribute("name");

```

您还可以检索特定范围内的键值。以下代码片段从引擎范围和全局范围中检索关键字"`year`"的值:

```
// Assigns 1969 to engineScopeYear and 1982 to
// globalScopeYear
int engineScopeYear = (Integer) ctx.getAttribute(
    "year", ScriptContext.ENGINE_SCOPE);
int globalScopeYear = (Integer) ctx.getAttribute(
    "year", ScriptContext.GLOBAL_SCOPE);

```

Note

Java 脚本 API 只定义了两个作用域:引擎和全局。`ScriptContext`接口的子接口可以定义额外的作用域。`ScriptContext`接口的`getScopes()`方法返回一个支持范围的列表作为`List<Integer>`。请注意，作用域表示为整数。在`ScriptContext`界面中的两个常量`ENGINE_SCOPE`和`GLOBAL_SCOPE`分别被赋值为 100 和 200。当在出现在多个范围中的多个`Bindings`中搜索一个键时，首先搜索具有较小整数值的范围。因为引擎范围的值 100 小于全局范围的值 200，所以当您不指定范围时，首先在引擎范围中搜索一个键。

清单 [10-10](#PC34) 展示了如何使用实现`ScriptContext`接口的类的实例。请注意，您不能在应用程序中单独使用`ScriptContext`。它由脚本引擎在脚本执行期间使用。最常见的是，你通过一个`ScriptEngine`和一个`ScriptEngineManager`间接地操纵一个`ScriptContext`，这将在下一节详细讨论。

```
// ScriptContextTest.java
package com.jdojo.script;
import java.util.List;
import javax.script.Bindings;
import javax.script.ScriptContext;
import javax.script.SimpleBindings;
import javax.script.SimpleScriptContext;
import static javax.script.ScriptContext.ENGINE_SCOPE;
import static javax.script.ScriptContext.GLOBAL_SCOPE;
public class ScriptContextTest {
    public static void main(String[] args) {
        // Create a script context
        ScriptContext ctx = new SimpleScriptContext();
        // Get the list of scopes supported by the script
        // context
        List<Integer> scopes = ctx.getScopes();
        System.out.println("Supported Scopes: " + scopes);
        // Add three key-value pairs to the engine scope
        // bindings
        ctx.setAttribute("year", 1969, ENGINE_SCOPE);
        ctx.setAttribute("month", 9, ENGINE_SCOPE);
        ctx.setAttribute("day", 19, ENGINE_SCOPE);
        // Add a global scope Bindings to the context
        Bindings globalBindings = new SimpleBindings();
        ctx.setBindings(globalBindings, GLOBAL_SCOPE);
        // Add two key-value pairs to the global scope
        // bindings
        ctx.setAttribute("year", 1982, GLOBAL_SCOPE);
        ctx.setAttribute("name", "Boni", GLOBAL_SCOPE);
        // Get the value of year without specifying the
        // scope
        int yearValue =
            (Integer) ctx.getAttribute("year");
        System.out.println("yearValue = " + yearValue);
        // Get the value of name
        String nameValue =
            (String) ctx.getAttribute("name");
        System.out.println("nameValue = " + nameValue);
        // Get the value of year from engine  and global
        // scopes
        int engineScopeYear = (Integer) ctx.
            getAttribute("year", ENGINE_SCOPE);
        int globalScopeYear = (Integer) ctx.
            getAttribute("year", GLOBAL_SCOPE);
        System.out.println("engineScopeYear = " +
            engineScopeYear);
        System.out.println("globalScopeYear = " +
            globalScopeYear);
    }
}

Supported Scopes: [100, 200]
yearValue = 1969
nameValue = Boni
engineScopeYear = 1969
globalScopeYear = 1982

Listing 10-10Using an Instance of the ScriptContext Interface

```

### 把它们放在一起

在这一节中，我将向您展示`Bindings`的实例及其作用域、`ScriptContext`、`ScriptEngine`、`ScriptEngineManager`和宿主应用程序是如何协同工作的。重点是如何使用一个`ScriptEngine`和一个`ScriptEngineManager`在不同的范围内操作存储在`Bindings`中的键值对。

一个`ScriptEngineManager`在一个`Bindings`中维护一组键值对。它允许您使用以下方法处理这些键值对:

*   `void put(String key, Object value)`

*   `Object get(String key)`

*   `void setBindings(Bindings bindings)`

*   `Bindings getBindings()`

`put()`方法向`Bindings`添加一个键值对。`get()`方法返回指定键的值；如果没有找到密钥，它返回`null`。使用`setBindings()`方法可以替换发动机管理器的`Bindings`。`getBindings()`方法返回`ScriptEngineManager`的`Bindings`的引用。

默认情况下，每个`ScriptEngine`都有一个被称为默认上下文的`ScriptContext`。回想一下，除了读者和作者，一个`ScriptContext`有两个`Bindings`:一个在引擎范围内，一个在全局范围内。当一个`ScriptEngine`被创建时，它的引擎作用域`Bindings`为空，它的全局作用域`Bindings`引用创建它的`ScriptEngineManager`的`Bindings`。

默认情况下，由`ScriptEngineManager`创建的`ScriptEngine`的所有实例共享`ScriptEngineManager`的`Bindings`。在同一个 Java 应用程序中可能有多个`ScriptEngineManager`实例。在这种情况下，由同一个`ScriptEngineManager`创建的`ScriptEngine`的所有实例共享`ScriptEngineManager`的`Bindings`作为它们默认上下文的全局作用域`Bindings`。

下面的代码片段创建了一个`ScriptEngineManager`，用于创建`ScriptEngine`的三个实例:

```
// Create a ScriptEngineManager
ScriptEngineManager manager = new ScriptEngineManager();
// Create three ScriptEngines using the same
// ScriptEngineManager
ScriptEngine engine1 = manager.getEngineByName(
    "Groovy");
ScriptEngine engine2 = manager.getEngineByName(
    "Groovy");
ScriptEngine engine3 = manager.getEngineByName(
    "Groovy");

```

现在，让我们给`ScriptEngineManager`的`Bindings`添加三个键值对，给每个`ScriptEngine`的引擎范围`Bindings`添加两个键值对:

```
// Add three key-value pairs to the Bindings
// of the manager
manager.put("K1", "V1");
manager.put("K2", "V2");
manager.put("K3", "V3");
// Add two key-value pairs to each engine
engine1.put("KE11", "VE11");
engine1.put("KE12", "VE12");
engine2.put("KE21", "VE21");
engine2.put("KE22", "VE22");
engine3.put("KE31", "VE31");
engine3.put("KE32", "VE32");

```

图 [10-2](#Fig2) 显示了前一段代码执行后`ScriptEngineManager`和三个`ScriptEngine`的状态。从图中可以明显看出，所有`ScriptEngine`的默认上下文共享`ScriptEngineManager`的`Bindings`作为它们的全局作用域`Bindings`。

![../images/323070_3_En_10_Chapter/323070_3_En_10_Fig2_HTML.jpg](../images/323070_3_En_10_Chapter/323070_3_En_10_Fig2_HTML.jpg)

图 10-2

由 ScriptEngineManager 创建的三个 ScriptEngines 的图示视图

`ScriptEngineManager`中的`Bindings`可以通过以下方式修改:

*   通过使用`ScriptEngineManager`的`put()`方法

*   通过使用`ScriptEngineManager`的`getBindings()`方法获取`Bindings`的引用，然后在`Bindings`上使用`put()`和`remove()`方法

*   通过使用`getBindings()`方法在`ScriptEngine`的默认上下文的全局范围内获取`Bindings`的引用，然后在`Bindings`上使用`put()`和`remove()`方法

当一个`ScriptEngineManager`中的`Bindings`被修改时，由这个`ScriptEngineManager`创建的所有`ScriptEngine`的默认上下文中的全局作用域`Bindings`被修改，因为它们共享同一个`Bindings`。

每个`ScriptEngine`的默认上下文分别维护一个引擎范围`Bindings`。要将一个键-值对添加到一个`ScriptEngine`的引擎作用域`Bindings`，使用它的`put()`方法，如下所示:

```
ScriptEngine engine1 = null; // get an engine
// Add an "engineName" key with its value as "Engine-1"
// to the engine scope Bindings of the default context
// of engine1
engine1.put("engineName", "Engine-1");

```

`ScriptEngine`的`get(String key)`方法从其引擎作用域`Bindings`返回指定的`key`的值。下面的语句返回`"Engine-1"`，它是`engineName`键的值:

```
String eName = (String) engine1.get("engineName");

```

在默认的`ScriptEngine`上下文中，获得全局作用域`Bindings`的键值对需要两个步骤。首先，您需要使用它的`getBindings()`方法获取全局作用域`Bindings`的引用，如下所示:

```
Bindings e1Global =
    engine1.getBindings(ScriptContext.GLOBAL_SCOPE);

```

现在，您可以使用`e1Global`引用来修改引擎的全局范围`Bindings`。下面的语句向`e1Global Bindings`添加了一个键值对:

```
e1Global.put("id", 89999);

```

因为所有的`ScriptEngine`共享一个`ScriptEngine`的全局作用域`Bindings`，这段代码将把键`id`及其值添加到所有`ScriptEngine`的默认上下文的全局作用域`Bindings`中，这些默认上下文是由创建`engine1`的同一`ScriptEngineManager`创建的。不建议使用之前的代码修改`ScriptEngineManager`中的`Bindings`。您应该改为使用`ScriptEngineManager`引用来修改`Bindings`，这使得代码的读者可以更清楚地理解逻辑。

清单 [10-11](#PC41) 展示了本节讨论的概念。

```
ScriptEngineManager
// GlobalBindings.java
package com.jdojo.script;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class GlobalBindings {
    public static void main(String[] args) {
        ScriptEngineManager manager =
            new ScriptEngineManager();
        // Add two numbers to the Bindings of the
        // manager - shared by all its engines
        manager.put("n1", 100);
        manager.put("n2", 200);
        // Create two JavaScript engines and add the name
        // of the engine in the engine scope of the default
        // context of the engines
        ScriptEngine engine1 = manager.getEngineByName(
            "Groovy");
        engine1.put("engineName", "Engine-1");
        ScriptEngine engine2 = manager.getEngineByName(
            "Groovy");
        engine2.put("engineName", "Engine-2");
        // Execute a script that adds two numbers and
        // prints the result
        String script = """
            def sum = n1 + n2
            println(engineName + ' - Sum = ' + sum)
        """;
        try {
            // Execute the script in two engines
            engine1.eval(script);
            engine2.eval(script);
            // Now add a different value for n2 for each
            // engine 

            engine1.put("n2", 1000);
            engine2.put("n2", 2000);
            // Execute the script in two engines again
            engine1.eval(script);
            engine2.eval(script);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }
}

Engine-1 - Sum = 300
Engine-2 - Sum = 300
Engine-1 - Sum = 1100
Engine-2 - Sum = 2100

Listing 10-11Using Global and Engine Scope Bindings of Engines Created by the Same

```

A `ScriptEngineManager`向它的`Bindings`添加两个键-值对，键为`n1`和`n2`。创造了两个`ScriptEngine`;他们在引擎范围`Bindings`中添加了一个名为`engineName`的键。当脚本被执行时，脚本中的`engineName`变量的值从`ScriptEngine`的引擎范围中被使用。脚本中变量`n1`和`n2`的值是从`ScriptEngine`的全局作用域`Bindings`中获取的。在第一次执行该脚本后，每个`ScriptEngine`向它们的引擎范围`Bindings`添加一个名为`n2`的键，该键具有不同的值。当您第二次执行脚本时，变量`n1`的值从引擎的全局作用域`Bindings`中检索，而变量`n2`的值从引擎作用域`Bindings`中检索，如输出所示。

由一个`ScriptEngineManager`创建的所有`ScriptEngines`共享的全局范围`Bindings`的故事还没有结束。这是最复杂、最令人困惑的事情！现在重点将放在使用`ScriptEngineManager`类的`setBindings()`方法和`ScriptEngine`接口的效果上。考虑以下代码片段:

```
// Create a ScriptEngineManager and two ScriptEngines
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine1 = manager.getEngineByName(
    "Groovy");
ScriptEngine engine2 = manager.getEngineByName(
    "Groovy");
// Add two key-value pairs to the manager
manager.put("n1", 100);
manager.put("n2", 200);

```

图 [10-3](#Fig3) 显示了该脚本执行后引擎管理器及其引擎的状态。此时，`ScriptEngineManager`中只存储了一个`Bindings`，两个`ScriptEngine`正在将其作为自己的全局作用域`Bindings`进行引用。

![../images/323070_3_En_10_Chapter/323070_3_En_10_Fig3_HTML.jpg](../images/323070_3_En_10_Chapter/323070_3_En_10_Fig3_HTML.jpg)

图 10-3

ScriptEngineManager 和两个 ScriptEngines 的初始状态

让我们创建一个新的`Bindings`，并使用`setBindings()`方法将其设置为`ScriptEngineManager`的`Bindings`，如下所示:

```
// Create a Bindings, add two key-value pairs to it, and
// set it as the new Bindings for the manager
Bindings newGlobal = new SimpleBindings();
newGlobal.put("n3", 300);
newGlobal.put("n4", 400);
manager.setBindings(newGlobal);

```

图 [10-4](#Fig4) 显示了前一段代码执行后`ScriptEngineManager`和两个`ScriptEngine`的状态。请注意，`ScriptEngineManager`有了新的`Bindings`，而两个`ScriptEngine`仍然将旧的`Bindings`称为它们的全球范围`Bindings`。

![../images/323070_3_En_10_Chapter/323070_3_En_10_Fig4_HTML.jpg](../images/323070_3_En_10_Chapter/323070_3_En_10_Fig4_HTML.jpg)

图 10-4

设置新绑定后 ScriptEngineManager 和两个 ScriptEngines 的状态

此时，对`ScriptEngineManager`的`Bindings`所做的任何更改都不会反映在两个`ScriptEngine`的全局作用域`Bindings`中

您仍然可以对两个`ScriptEngine`共享的`Bindings`进行更改，两个`ScriptEngine`都将看到其中一个所做的更改。

让我们创建一个新的`ScriptEngine`，如图所示:

```
// Create a new ScriptEngine
ScriptEngine engine3 = manager.getEngineByName(
    "Groovy");

```

回想一下，`ScriptEngine`在创建时获得了全局作用域`Bindings`,`Bindings`与`ScriptEngineManager`的`Bindings`相同。前一条语句执行后，`ScriptEngineManager`和三个`ScriptEngine`的状态如图 [10-5](#Fig5) 所示。

![../images/323070_3_En_10_Chapter/323070_3_En_10_Fig5_HTML.jpg](../images/323070_3_En_10_Chapter/323070_3_En_10_Fig5_HTML.jpg)

图 10-5

创建第三个 ScriptEngine 后 ScriptEngineManager 和三个 script engine 的状态

这里是对所谓的`ScriptEngine` s 的全局范围的“全球性”的另一种扭曲。这一次，您将使用一个`ScriptEngine`的`setBindings()`方法来设置它的全局范围`Bindings`:

```
// Set a new Bindings for the global scope of engine1
Bindings newGlobalEngine1 = new SimpleBindings();
newGlobalEngine1.put("n5", 500);
newGlobalEngine1.put("n6", 600);
engine1.setBindings(newGlobalEngine1,
    ScriptContext.GLOBAL_SCOPE);

```

图 [10-6](#Fig6) 显示了前一段代码执行后`ScriptEngineManager`和三个脚本引擎的状态。

![../images/323070_3_En_10_Chapter/323070_3_En_10_Fig6_HTML.jpg](../images/323070_3_En_10_Chapter/323070_3_En_10_Fig6_HTML.jpg)

图 10-6

设置新的全局范围绑定后 ScriptEngineManager 和三个 ScriptEngines 的状态

Note

默认情况下，a `ScriptEngineManager`创建的所有`ScriptEngine`共享其`Bindings`作为它们的全局作用域`Bindings`。如果你使用一个`ScriptEngine`的`setBindings()`方法来设置它的全局作用域`Bindings`，或者如果你使用一个`ScriptEngineManager`的`setBindings()`方法来设置它的`Bindings`，你就打破了“全局”链，如本节所讨论的。为了保持“全局”链的完整性，您应该总是使用`ScriptEngineManager`的`put()`方法将键值对添加到它的`Bindings`中。要从由`ScriptEngineManager`创建的所有`ScriptEngine`的全局范围中删除一个键值对，您需要使用`ScriptEngineManager`的`getBindings()`方法获取`Bindings`的引用，并在`Bindings`上使用`remove()`方法。

## 使用自定义脚本上下文

在上一节中，您看到每个`ScriptEngine`都有一个默认的脚本上下文。`ScriptEngine`的`get()`、`put()`、`getBindings()`和`setBindings()`方法在默认`ScriptContext`下运行。当`ScriptEngine`的`eval()`方法没有指定`ScriptContext`时，使用引擎的默认上下文。`ScriptEngine`的`eval()`方法的以下两个版本使用其默认上下文来执行脚本:

*   `Object eval(String script)`

*   `Object eval(Reader reader)`

您可以将一个`Bindings`传递给下面两个版本的`eval()`方法:

*   `Object eval(String script, Bindings bindings)`

*   `Object eval(Reader reader, Bindings bindings)`

这些版本的`eval()`方法不使用默认的`ScriptEngine`上下文。他们使用一个新的`ScriptContext`，其引擎范围`Bindings`是传递给这些方法的那个，全局范围`Bindings`与引擎的默认上下文相同。注意，`eval()`方法的这两个版本保持了`ScriptEngine`的默认上下文不变。

您可以将一个`ScriptContext`传递给下面两个版本的`eval()`方法:

*   `Object eval(String script, ScriptContext context)`

*   `Object eval(Reader reader, ScriptContext context)`

这些版本的`eval()`方法使用指定的上下文来执行脚本。它们保持`ScriptEngine`的默认上下文不变。

三组`eval()`方法允许您使用不同的隔离级别执行脚本:

*   第一组让所有脚本共享默认上下文。

*   第二组让脚本使用不同的引擎作用域`Bindings`并共享全局作用域`Bindings`。

*   第三组让脚本在隔离的`ScriptContext`中执行。

清单 [10-12](#PC46) 展示了如何使用不同版本的`eval()`方法在不同的隔离级别执行脚本。

```
// CustomContext.java
package com.jdojo.script;
import javax.script.Bindings;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javax.script.SimpleScriptContext;
import static javax.script.SimpleScriptContext.
    ENGINE_SCOPE;
import static javax.script.SimpleScriptContext.
    GLOBAL_SCOPE;
public class CustomContext {
    public static void
    main(String[] args) throws ScriptException {
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        // Add n1 to Bindings of the manager, which will
        // be shared by all engines as their global scope
        // Bindings
        manager.put("n1", 100);
        // Prepare the script
        String script = """
            def sum = n1 + n2
            println(msg + ' n1=' + n1 + ', n2=' + n2 +
                    ', sum=' + sum)
        """;
        // Add n2 to the engine scope of the default
        // context of the engine
        engine.put("n2", 200);
        engine.put("msg", "Using the default context:");
        engine.eval(script);
        // Use a Bindings to execute the script
        Bindings bindings = engine.createBindings();
        bindings.put("n2", 300);
        bindings.put("msg", "Using a Bindings:");
        engine.eval(script, bindings);
        // Use a ScriptContext to execute the script
        ScriptContext ctx = new SimpleScriptContext();
        Bindings ctxGlobalBindings =
            engine.createBindings();
        ctx.setBindings(ctxGlobalBindings, GLOBAL_SCOPE);
        ctx.setAttribute("n1", 400, GLOBAL_SCOPE);
        ctx.setAttribute("n2", 500, ENGINE_SCOPE);
        ctx.setAttribute("msg", "Using a ScriptContext:",
            ENGINE_SCOPE); 

        engine.eval(script, ctx);
        // Execute the script again using the default
        // context to prove that the default context is
        // unaffected.
        engine.eval(script);
    }
}

Using the default context: n1=100, n2=200, sum=300
Using a Bindings: n1=100, n2=300, sum=400
Using a ScriptContext: n1=400, n2=500, sum=900
Using the default context: n1=100, n2=200, sum=300

Listing 10-12Using Different Isolation Levels for Executing Scripts

```

该程序使用三个变量，称为`msg`、`n1`和`n2`。它显示存储在`msg`变量中的值。将`n1`和`n2`的值相加，并显示总和。该脚本打印出在计算总和时使用了什么值的`n1`和`n2`。`n1`的值存储在由所有`ScriptEngine`的默认上下文共享的`ScriptEngineManager`的`Bindings`中。`n2`的值存储在默认上下文和自定义上下文的引擎范围中。该脚本使用引擎的默认上下文执行两次，一次在开始，一次在结束，以证明在`eval()`方法中使用自定义`Bindings`或`ScriptContext`不会影响`ScriptEngine`的默认上下文中的`Bindings`。该程序在其`main()`方法中声明了一个`throws`子句，以使代码更短。

## eval()方法的返回值

`ScriptEngine`的`eval()`方法返回一个`Object`，这是脚本中的最后一个值。如果脚本中没有最后一个值，它将返回`null`。依赖脚本中的最后一个值容易出错，同时也令人困惑。下面的代码片段展示了一些为 Groovy 使用`eval()`方法返回值的例子。代码中的注释表示从`eval()`方法返回的值:

```
Object result = null;
// Assigns 3 to result
result = engine.eval("1 + 2");
// Assigns 7 to result
result = engine.eval("1 + 2; 3 + 4");
// Assigns 6 to result
result = engine.eval("""1 + 2; 3 + 4;
    def v = 5; v = 6""");
// Assigns 5 to result
result = engine.eval("""1 + 2; 3 + 4;
    def v = 5""");
// Assigns null to result
result = engine.eval("println(1 + 2)");

```

最好不要依赖于`eval()`方法的返回值。您应该将一个 Java 对象作为参数传递给脚本，并让脚本将脚本的返回值存储在该对象中。在执行了`eval()`方法之后，您可以查询这个 Java 对象的返回值。

清单 [10-13](#PC48) 包含包装整数的`Result`类的代码。您将向脚本传递一个`Result`类的对象，脚本将在其中存储返回值。脚本完成后，您可以在 Java 代码中读取存储在`Result`对象中的整数值。需要将`Result`声明为公共的，这样脚本引擎就可以访问它。

```
// Result.java
package com.jdojo.script;
public class Result {
    public int val = -1;
}

Listing 10-13A Result Class That Wraps an Integer

```

清单 [10-14](#PC49) 中的程序展示了如何将一个`Result`对象传递给一个用值填充`Result`对象的脚本。该程序在`main()`方法的声明中包含一个`throws`子句，以保持代码简短。

```
// ResultBearingScript.java
package com.jdojo.script;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class ResultBearingScript {
    public static void
    main(String[] args) throws ScriptException {
        // Get the Groovy engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        // Pass a Result object to the script. The script
        // will store the result of the script in the
        // result object
        Result result = new Result();
        engine.put("result", result);
        // Store the script in a String
        String script = "3 + 4; result.val = 101";
        // Execute the script, which uses the passed in
        // Result object to return a value
        engine.eval(script);
        // Use the result object to get the returned value
        // from the script
        int returnedValue = result.val; // -> 101
        System.out.println("Returned value is " +
            returnedValue);
    }
}

Returned value is 101

Listing 10-14Collecting the Return Value of a Script in a Result Object

```

## 引擎范围绑定的保留键

通常，引擎范围`Bindings`中的一个键代表一个脚本变量。有些键是保留的，它们有特殊的含义。它们的值可以通过引擎的实现传递给引擎。一个实现可以定义附加的保留密钥。

表 [10-1](#Tab1) 包含所有保留密钥的列表。这些键在`ScriptEngine`接口中也被声明为常量。脚本引擎的实现不需要在引擎范围绑定中将所有这些键传递给引擎。作为开发人员，您不应该使用这些键将参数从 Java 应用程序传递到脚本引擎。

表 10-1

引擎范围绑定的保留键

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

钥匙

 | 

ScriptEngine 接口中的常数

 | 

键值的含义

 |
| --- | --- | --- |
| `"javax.script.argv"` | `ScriptEngine.ARGV` | 用来传递一个数组`Object`来传递一组位置参数。 |
| `"javax.script.engine"` | `ScriptEngine.ENGINE` | 脚本引擎的名称。 |
| `"javax.script.engine_version"` | `ScriptEngine.ENGINE_VERSION` | 脚本引擎的版本。 |
| `"javax.script.filename"` | `ScriptEngine.FILENAME` | 用于传递作为脚本源的文件或资源的名称。 |
| `"javax.script.language"` | `ScriptEngine.LANGUAGE` | 脚本引擎支持的语言的名称。 |
| `"javax.script.language_version"` | `ScriptEngine.LANGUAGE_VERSION` | 引擎支持的脚本语言版本。 |
| `"javax.script.name"` | `ScriptEngine.NAME` | 脚本语言的简称。 |

## 更改默认脚本上下文

您可以分别使用`getContext()`和`setContext()`方法来获取和设置`ScriptEngine`的默认上下文，如下所示:

```
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName(
    "Groovy");
// Get the default context of the ScriptEngine
ScriptContext defaultCtx = engine.getContext();
// Work with defaultCtx here
// Create a new context
ScriptContext ctx = new SimpleScriptContext();
// Configure ctx here
// Set ctx as the new default context for the engine
engine.setContext(ctx);

```

注意，为一个`ScriptEngine`设置一个新的默认上下文不会使用`ScriptEngineManager`的`Bindings`作为它的全局作用域`Bindings`。如果您希望新的默认上下文使用`ScriptEngineManager`的`Bindings`，您需要显式设置它，如下所示:

```
// Create a new context
ScriptContext ctx = new SimpleScriptContext();
// Set the global scope Bindings for ctx the same as the
// Bindings for the manager
ctx.setBindings(manager.getBindings(),
    ScriptContext.GLOBAL_SCOPE);
// Set ctx as the new default context for the engine
engine.setContext(ctx);

```

## 将脚本输出发送到文件

您可以自定义脚本执行的输入源、输出目标和错误输出目标。您需要为用于执行脚本的`ScriptContext`设置适当的读取器和写入器。下面的代码片段将把脚本输出写到当前目录中名为`output.txt`的文件中:

```
// Create a FileWriter
FileWriter writer = new FileWriter("output.txt");
// Get the default context of the engine
ScriptContext defaultCtx = engine.getContext();
// Set the output writer for the default context of the
// engine
defaultCtx.setWriter(writer);

```

该代码为`ScriptEngine`的默认上下文设置了一个自定义输出编写器，在使用默认上下文的脚本执行过程中将会用到这个编写器。如果您想使用定制的输出编写器来执行特定的脚本，您需要使用一个定制的`ScriptContext`并设置它的编写器。

Note

为`ScriptContext`设置自定义输出编写器不会影响 Java 应用程序标准输出的目的地。要重定向 Java 应用程序的标准输出，您需要使用`System.setOut()`方法。

清单 [10-15](#PC53) 向您展示了如何将脚本执行的输出写到名为`output.txt`的文件中。该程序在标准输出中打印输出文件的完整路径。运行该程序时，您可能会得到不同的输出。您需要在文本编辑器中打开输出文件来查看脚本的输出。

```
// CustomScriptOutput.java
package com.jdojo.script;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class CustomScriptOutput {
    public static void main(String[] args) {
        // Get the Groovy engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        // Print the absolute path of the output file
        File outputFile = new File("output.txt");
        System.out.println(
            "Script output will be written to "
            + outputFile.getAbsolutePath());
        try (FileWriter writer =
                new FileWriter(outputFile)) {
            // Set a custom output writer for the engine
            ScriptContext defaultCtx =
                engine.getContext();
            defaultCtx.setWriter(writer);
            // Execute a script
            String script =
                "println('Hello custom output writer')";
            engine.eval(script);
        } catch (IOException | ScriptException e) {
            e.printStackTrace();
        }
    }
}

Listing 10-15Writing the Output of Scripts to a File

```

脚本输出将被写入当前工作目录中的文件`output.txt`。

## 在脚本中调用过程

脚本语言可以允许创建过程、函数和方法。Java 脚本 API 允许您从 Java 应用程序中调用这样的过程、函数和方法。在本节中，我使用术语“过程”来表示过程、函数和方法。当讨论的上下文需要时，我使用特定的术语。

并非所有脚本引擎都需要支持过程调用。Groovy 引擎支持过程调用。如果有脚本引擎支持，那么脚本引擎类的实现必须实现`Invocable`接口。在调用过程之前，检查脚本引擎是否实现了`Invocable`接口是开发人员的责任。调用过程包括四个步骤:

*   检查脚本引擎是否支持过程调用。

*   将发动机参考转换为`Invocable`类型。

*   评估包含该过程源代码的脚本。

*   使用`Invocable`接口的`invokeFunction()`方法调用过程和函数。使用`invokeMethod()`方法来调用在脚本语言中创建的对象的方法。

以下代码片段检查脚本引擎实现类是否实现了`Invocable`接口:

```
// Get the Groovy engine
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName(
    "Groovy");
// Make sure the script engine implements the Invocable
// interface
if (engine instanceof Invocable) {
    System.out.println(
        "Invoking procedures is supported.");
} else {
    System.out.println(
        "Invoking procedures is not supported.");
}

```

第二步是将引擎引用转换为`Invocable`接口类型:

```
Invocable inv = (Invocable) engine;

```

第三步是评估脚本，因此脚本引擎编译并存储过程的编译形式，供以后调用。以下代码片段执行此步骤:

```
// Declare a function named add that adds two numbers
String script = "def add(n1, n2) { n1 + n2 }";
// Evaluate the function. Call to eval() does not invoke
// the function. It just compiles it.
engine.eval(script);

```

最后一步是调用过程或函数:

```
// Invoke the add function with 30 and 40 as the function's
// arguments. It is as if you called add(30, 40) in the
// script.
Object result = inv.invokeFunction("add", 30, 40);

```

`invokeFunction()`的第一个参数是过程或函数的名称。第二个参数是 varargs，用于指定过程或函数的参数。`invokeFunction()`方法返回过程或函数返回的值。

清单 10-16 显示了如何调用一个函数。它调用用 Groovy 编写的函数。

```
// InvokeFunction.java
package com.jdojo.script;
import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class InvokeFunction {
    public static void main(String[] args) {
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        // Make sure the script engine implements the
        // Invocable interface
        if (!(engine instanceof Invocable)) {
            System.out.println(
                "Invoking procedures is not supported.");
            return;
        }
        // Cast the engine reference to the Invocable type
        Invocable inv = (Invocable) engine;
        try {
            String script =
              "def add(n1, n2) { n1 + n2 }";
            // Evaluate the script first
            engine.eval(script);
            // Invoke the add function twice
            Object result1 = inv.invokeFunction(
                "add", 30, 40);
            System.out.println("Result1 = " + result1);
            Object result2 = inv.invokeFunction(
                "add", 10, 20);
            System.out.println("Result2 = " + result2);
        } catch (ScriptException |
                NoSuchMethodException e) {
            e.printStackTrace();
        }
    }
}

Result1 = 70
Result2 = 30

Listing 10-16Invoking a Function Written in Groovy

```

面向对象或基于对象的脚本语言可以让您定义对象及其方法。您可以使用`Invocable`接口的`invokeMethod()`方法调用这些对象的方法，声明如下:

```
Object invokeMethod(Object objectRef, String name,
    Object... args)

```

第一个参数是对象的引用，第二个参数是要在对象上调用的方法的名称，第三个参数是 varargs 参数，用于将参数传递给被调用的方法。

清单 [10-17](#PC60) 展示了在 Groovy 中创建的对象上的方法调用。注意，该对象是在 Groovy 脚本中创建的。要从 Java 调用对象的方法，需要通过脚本引擎获取对象的引用。该程序评估使用 add()方法创建对象的脚本，并将其引用存储在名为 calculator 的变量中。engine.get("calculator ")方法返回 calculator 对象对 Java 代码的引用。

```
// InvokeMethod.java
package com.jdojo.script;
import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class InvokeMethod {
    public static void main(String[] args) {
        // Get the Groovy engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        // Make sure the script engine implements the
        // Invocable interface
        if (!(engine instanceof Invocable)) {
            System.out.println(
                "Invoking methods is not supported.");
            return;
        }
        // Cast the engine reference to the Invocable type
        Invocable inv = (Invocable) engine;
        try {
            // Declare a global object with an add() method
            String script = """
                  class Calculator {
                  def add(int n1, int n2){n1 + n2}
                 }
                calculator = new Calculator()
                """;
            // Evaluate the script first
            engine.eval(script);
            // Get the calculator object reference created
            // in the script
            Object calculator = engine.get("calculator");
            // Invoke the add() method on the calculator
            // object
            Object result = inv.invokeMethod(calculator,
                "add", 30, 40);
            System.out.println("Result = " + result);
        } catch (ScriptException |
                NoSuchMethodException e) {
            e.printStackTrace();
        }
    }
}

Result = 70

Listing 10-17Invoking a Method on an Object Created in Groovy JavaScript

```

Note

使用 Invocable 接口重复执行过程、函数和方法。脚本的评估包含过程、函数和方法，将中间代码存储在引擎中，从而在重复执行时提高性能。

## 在脚本中实现 Java 接口

Java 脚本 API 允许您用脚本语言实现 Java 接口。Java 接口的方法可以使用顶层过程或对象的实例方法在脚本中实现。用脚本语言实现 Java 接口的优点是，您可以用 Java 代码使用接口的实例，就好像接口是用 Java 实现的一样。您可以将接口的实例作为参数传递给 Java 方法。`Invocable`接口的`getInterface()`方法用于获取在脚本中实现的 Java 接口的实例。该方法有两个版本:

*   `<T> T getInterface(Class<T> cls)`

*   `<T> T getInterface(Object obj, Class<T> cls)`

第一个版本用于获取 Java 接口的实例，该接口的方法在脚本中作为顶级过程实现。接口类型作为参数传递给该方法。假设你有一个`Calculator`接口，如清单 [10-18](#PC61) 所示，它有两个方法叫做`add()`和`subtract()`。

```
// Calculator.java
package com.jdojo.script;
public interface Calculator {
    int add (int n1, int n2);
    int subtract (int n1, int n2);
}

Listing 10-18A Calculator Interface

```

考虑以下两个用 Groovy 编写的顶级函数:

```
def add(n1, n2) {
    n1 + n2
}
def subtract(n1, n2) {
    n1 -n2
}

```

这两个函数为`Calculator`接口的两个方法提供了实现。在 Groovy 脚本引擎编译了这些函数之后，您可以获得一个`Calculator`接口的实例，如下所示:

```
// Cast the engine reference to the Invocable type
Invocable inv = (Invocable) engine;
// Get the reference of the Calculator interface
Calculator calc = inv.getInterface(Calculator.class);
if (calc == null) {
    System.err.println(
        "Calculator interface implementation not found.");
} else {
    // Use calc to call add() and subtract() methods
}

```

您可以添加两个数字，如下所示:

```
int sum = calc.add(15, 10);

```

清单 [10-19](#PC65) 展示了如何使用 Groovy 中的顶级过程实现 Java 接口。请查阅脚本语言的文档，了解它是如何支持这一功能的。

```
// UsingInterfaces.java
package com.jdojo.script;
import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class UsingInterfaces {
    public static void main(String[] args) {
        // Get the Groovy engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        // Make sure the script engine implements
        // Invocable interface
        if (!(engine instanceof Invocable)) {
            System.out.println(
                """Interface implementation in script
                   is not supported.""");
            return;
        }
        // Cast the engine reference to the Invocable
        // type
        Invocable inv = (Invocable) engine;
        // Create the script for add() and subtract()
        // functions
        String script = """
            def add(n1, n2) { n1 + n2 }
            def subtract(n1, n2) { n1 - n2 }
        """;
        try { 

            // Compile the script that will be stored in
            // the engine
            engine.eval(script);
            // Get the interface implementation
            Calculator calc = inv.getInterface(
                Calculator.class);
            if (calc == null) {
                System.err.println(
                    """Calculator interface implementation
                       not found.""");
                return;
            }
            int result1 = calc.add(15, 10);
            System.out.println(
                "add(15, 10) = " + result1);
            int result2 = calc.subtract(15, 10);
            System.out.println(
                "subtract(15, 10) = " + result2);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }
}

add(15, 10) = 25
subtract(15, 10) = 5 

Listing 10-19Implementing a Java Interface Using Top-Level Functions in a Script

```

第二个版本的`getInterface()`方法用于获得一个 Java 接口的实例，该接口的方法被实现为一个对象的实例方法。它的第一个参数是用脚本语言创建的对象的引用。对象的实例方法实现作为第二个参数传入的接口类型。Groovy 中的以下代码创建了一个对象，该对象的实例方法实现了`Calculator`接口:

```
    class GCalculator {
      def add(int n1, int n2){n1 + n2}
      def subtract(int n1, int n2){n1 + n2}
    }
    calculator = new GCalculator()

```

当脚本对象的实例方法实现 Java 接口的方法时，您需要执行一个额外的步骤。在获取接口的实例之前，需要获取脚本对象的引用，如下所示:

```
// Get the reference of the global script object calc
Object calc = engine.get("calculator");
// Get the implementation of the Calculator interface
Calculator calculator =
    inv.getInterface(calc, Calculator.class);

```

清单 [10-20](#PC68) 展示了如何使用 Groovy 将 Java 接口的方法实现为对象的实例方法。

```
// ScriptObjectImplInterface.java
package com.jdojo.script;
import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class ScriptObjectImplInterface {
    public static void main(String[] args) {
        // Get the Groovy engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        // Make sure the engine implements the Invocable
        // interface 

        if (!(engine instanceof Invocable)) {
            System.out.println(
                """Interface implementation in script is
                not supported.""");
            return;
        }
        // Cast the engine reference to the Invocable type
        Invocable inv = (Invocable) engine;
        String script = """
          class GCalculator {
            def add(int n1, int n2){n1 + n2}
            def subtract(int n1, int n2){n1 + n2}
          }
          calculator = new GCalculator()
        """;
        try {
            // Compile and store the script in the engine
            engine.eval(script);
            // Get the reference of the global script
            // object calc
            Object calc = engine.get("calculator");
            // Get the implementation of the Calculator
            // interface
            Calculator calculator =
                inv.getInterface(calc, Calculator.class);
            if (calculator == null) {
                System.err.println(
                    """Calculator interface implementation
                    not found.""");
                return;
            }
            int result1 = calculator.add(15, 10);
            System.out.println(
                "add(15, 10) = " + result1);
            int result2 = calculator.subtract(15, 10);
            System.out.println(
                "subtract(15, 10) = " + result2);
        } catch (ScriptException e) {
            e.printStackTrace();
        } 

    }
}

add(15, 10) = 25
subtract(15, 10) = 5

Listing 10-20Implementing Methods of a Java Interface As Instance Methods of an Object in a Script

```

## 使用编译的脚本

脚本引擎可以允许编译脚本并重复执行它。执行编译后的脚本可以提高应用程序的性能。脚本引擎可以以 Java 类、Java 类文件的形式或特定于语言的形式编译和存储脚本。

并非所有脚本引擎都需要支持脚本编译。支持脚本编译的脚本引擎必须实现`Compilable`接口。Groovy 引擎支持脚本编译。以下代码片段检查脚本引擎是否实现了`Compilable`接口:

```
// Get the script engine reference
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName(
    "YOUR_ENGINE_NAME");
if (engine instanceof Compilable) {
    System.out.println(
        "Script compilation is supported.");
} else {
    System.out.println(
        "Script compilation is not supported.");
}

```

一旦您知道脚本引擎实现了`Compilable`接口，您就可以将其引用转换为`Compilable`类型

```
// Cast the engine reference to the Compilable type
Compilable comp = (Compilable) engine;

```

`Compilable`接口包含两个方法:

*   `CompiledScript compile(String script) throws ScriptException`

*   `CompiledScript compile(Reader script) throws ScriptException`

该方法的两个版本仅在脚本源的类型上有所不同。第一个版本接受脚本作为`String`，第二个版本接受脚本作为`Reader`。

`compile()`方法返回一个`CompiledScript`类的对象。`CompiledScript`是一个抽象类。脚本引擎的提供者提供了这个类的具体实现。一个`CompiledScript`与创建它的`ScriptEngine`相关联。`CompiledScript`类的`getEngine()`方法返回与其关联的`ScriptEngine`的引用。

要执行编译后的脚本，您需要调用`CompiledScript`类的以下`eval()`方法之一:

*   `Object eval() throws ScriptException`

*   `Object eval(Bindings bindings) throws ScriptException`

*   `Object eval(ScriptContext context) throws ScriptException`

没有任何参数的`eval()`方法使用脚本引擎的默认脚本上下文来执行编译后的脚本。当你向另外两个版本传递一个`Bindings`或一个`ScriptContext`时，它们的工作方式与`ScriptEngine`接口的`eval()`方法相同。

清单 [10-21](#PC71) 展示了如何编译并执行一个脚本。它使用不同的参数将相同的编译脚本执行两次。

```
// CompilableTest .java
package com.jdojo.script;
import javax.script.Bindings;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class CompilableTest {
    public static void main(String[] args) {
        // Get the Groovy engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "Groovy");
        if (!(engine instanceof Compilable)) {
            System.out.println(
                "Script compilation not supported.");
            return;
        }
        // Cast the engine reference to the Compilable
        // type
        Compilable comp = (Compilable) engine;
        try {
            // Compile a script
            String script = "println(n1 + n2)";
            CompiledScript cScript = comp.compile(script);
            // Store n1 and n2 script variables in a
            // Bindings
            Bindings scriptParams =
                engine.createBindings();
            scriptParams.put("n1", 2);
            scriptParams.put("n2", 3);
            cScript.eval(scriptParams);
            // Execute the script again with different
            // values for n1 and n2
            scriptParams.put("n1", 9);
            scriptParams.put("n2", 7);
            cScript.eval(scriptParams);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }
}
5
16

Listing 10-21Using Compiled Scripts

```

## 在脚本语言中使用 Java

脚本语言允许在脚本中使用 Java 类库。每种脚本语言都有自己的使用 Java 类的语法。讨论所有脚本语言的语法是不可能的，也超出了本书的范围。在这一节中，我将讨论在 Groovy 中使用一些 Java 结构的语法。关于 Groovy 的完整报道，请参考网站 [`www.groovy-lang.org/`](http://www.groovy-lang.org/) 。

### 声明变量

在脚本语言中声明变量并不一定与 Java 相关。通常，脚本语言允许您在不声明变量的情况下给变量赋值。然后在运行时基于变量存储的值的类型来确定变量的类型。

在 Groovy 中，关键字`def`用于声明一个变量。如果您决定在变量声明中省略关键字`def`,那么该变量在整个脚本中都是可访问的，尽管不是在您在脚本中声明的类中，并且在脚本被处理后，可以从 Java 中访问该值。以下代码片段声明了两个变量，并为它们赋值:

```
// Declare a variable named msg using the def keyword
def msg = "Hello";

// Declare a variable named greeting without using the
// keyword def. We can later use
//     Object greeting = engine.get("greeting");
// in Java to get the value.
greeting = "Hello";

```

### 导入 Java 类

Groovy 位于 JVM 之上，所以您可以像导入 Java 类文件一样，将 Java 类从标准库中导入到 Groovy 脚本中。这同样适用于项目中包含的库提供的类以及项目中定义的类:

```
// A class from the standard library
import java.text.SimpleDateFormat

// A class defined elsewhere in the project
import java17.script.SomeJavaClass

// Some library class. Must be inside the classpath.
import com.foo.superlib.Foo

def obj = new SomeJavaClass(8)
def sdf = new SimpleDateFormat("yyyy-MM-dd")
def foo = new Foo()
...

```

其他脚本语言定义或者不定义它们自己导入 Java 类的方式。有关详细信息，请参考他们的文档。

## 实现脚本引擎

实现一个成熟的脚本引擎不是一件简单的任务，它超出了本书的范围。本节旨在为您提供实现脚本引擎所需的设置的简要但完整的概述。在本节中，您将实现一个简单的脚本引擎，称为`JKScript`引擎。它将使用以下规则计算算术表达式:

*   它将计算由两个操作数和一个运算符组成的算术表达式。

*   表达式可能有两个数字文字、两个变量，或者一个数字文字和一个变量作为操作数。数字文字必须是十进制格式。不支持十六进制、八进制和二进制数字文本。

*   表达式中的算术运算仅限于加、减、乘和除。

*   它会将`+`、`-`、`*`和`/`识别为算术运算符。

*   引擎将返回一个`Double`对象作为表达式的结果。

*   可以使用引擎的全局范围或引擎范围绑定将表达式中的操作数传递给引擎。

*   它应该允许从一个`String`对象和一个`java.io.Reader`对象执行脚本。然而，一个`Reader`应该只有一个表达式作为其内容。

*   它不会实现`Invocable`和`Compilable`接口。

使用这些规则，脚本引擎的一些有效表达式如下:

*   `10 + 90`

*   `10.7 + 89.0`

*   `+10 + +90`

*   `num1 + num2`

*   `num1 * num2`

*   `78.0 / 7.5`

脚本 API 使用服务提供者机制来发现脚本引擎。服务类型是`javax.script.ScriptEngineFactory`接口。您的脚本引擎必须为此服务类型提供实现。你将把你的脚本引擎打包在一个名为`jdojo.jkscript`的独立模块中，如清单 [10-22](#PC74) 中所声明的。

```
// module-info.java
module jdojo.jkscript {
    requires java.scripting;
    provides javax.script.ScriptEngineFactory
        with com.jdojo.jkscript.JKScriptEngineFactory;
}

Listing 10-22The Declaration of a jdojo.jkscript Module

```

该模块读取`java.scripting`模块，因为它需要使用该模块中的类型。该模块提供了`javax.script.ScriptEngineFactory`服务接口的实现，它是`com.jdojo.jkscript.JKScriptEngineFactory`类。您不需要导出您的模块的任何包，因为没有其他模块应该直接从该模块访问任何类型。

作为`JKScript`脚本引擎实现的一部分，你将开发表 [10-2](#Tab2) 中列出的三个类。在随后的部分中，您将开发这些类。

表 10-2

要为 jscript 脚本引擎开发的类

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

班级

 | 

描述

 |
| --- | --- |
| `Expression` | `Expression`类是脚本引擎的核心。它执行解析和评估算术表达式的工作。它在`JKScriptEngine`类的`eval()`方法中使用。 |
| `JKScriptEngine` | 接口的一个实现。它扩展了实现`ScriptEngine`接口的`AbstractScriptEngine`类。`AbstractScriptEngine`类为`ScriptEngine`接口的`eval()`方法的几个版本提供了标准实现。您需要实现下面两个版本的`eval()`方法:`Object eval(String, ScriptContext)`和`Object eval(Reader, ScriptContext)` |
| `JKScriptEngineFactory` | 接口的一个实现。这是`javax.script.ScriptEngineFactory`服务接口的服务提供者。 |

### 表达式类

`Expression`类包含解析和评估算术表达式的主要逻辑。清单 [10-23](#PC75) 包含了`Expression`类的完整代码。

```
// Expression.java
package com.jdojo.jkscript;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.script.ScriptContext;
public class Expression {
    private String exp;
    private ScriptContext context;
    private String op1;
    private char op1Sign = '+';
    private String op2;
    private char op2Sign = '+';
    private char operation;
    private boolean parsed;
    public Expression(String exp, ScriptContext context) {
        if (exp == null || exp.trim().equals("")) {
            throw new IllegalArgumentException(
                this.getErrorString());
        }
        this.exp = exp.trim();
        if (context == null) {
            throw new IllegalArgumentException(
                "ScriptContext cannot be null.");
        }
        this.context = context;
    }
    public String getExpression() {
        return exp;
    }
    public ScriptContext getScriptContext() {
        return context;
    }
    public Double eval() {
        // Parse the expression
        if (!parsed) {
            this.parse();
            this.parsed = true;
        }
        // Extract the values for the operand
        double op1Value = getOperandValue(op1Sign, op1);
        double op2Value = getOperandValue(op2Sign, op2);
        // Evaluate the expression
        Double result = null;
        switch (operation) {
            case '+':
                result = op1Value + op2Value;
                break;
            case '-':
                result = op1Value - op2Value;
                break;
            case '*':
                result = op1Value * op2Value;
                break;
            case '/':
                result = op1Value / op2Value;
                break;
            default:
                throw new RuntimeException(
                    "Invalid operation:" + operation);
        }
        return result;
    }
    private double
    getOperandValue(char sign, String operand) {
        // Check if operand is a double
        double value;
        try {
            value = Double.parseDouble(operand);
            return sign == '-' ? -value : value;
        } catch (NumberFormatException e) {
            // Ignore it. Operand is not in a format that
            // can be converted to a double value.
        }
        // Check if operand is a bind variable
        Object bindValue = context.getAttribute(operand);
        if (bindValue == null) {
            throw new RuntimeException(operand +
                " is not found in the script context.");
        }
        if (bindValue instanceof Number) {
            value = ((Number) bindValue).doubleValue();
            return sign == '-' ? -value : value;
        } else {
            throw new RuntimeException(operand +
                " must be bound to a number.");
        }
    }
    public void parse() {
        // Supported expressions are of the form v1 op v2,
        // where v1 and v2 are variable names or numbers,
        // and op could be +, -, *, or /
        // Prepare the pattern for the expected expression
        String operandSignPattern = "([+-]?)";
        String operandPattern = "([\\p{Alnum}\\p{Sc}_.]+)";
        String whileSpacePattern = "([\\s]*)";
        String operationPattern = "([+*/-])";
        String pattern = "^" + operandSignPattern
                + operandPattern
                + whileSpacePattern + operationPattern
                + whileSpacePattern
                + operandSignPattern + operandPattern
                + "$";
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(exp);
        if (!m.matches()) {
            // The expression is not in the expected format
            throw new IllegalArgumentException(
                this.getErrorString());
        }
        // Get operand-1
        String temp = m.group(1);
        if (temp != null && !temp.equals("")) {
            this.op1Sign = temp.charAt(0);
        }
        this.op1 = m.group(2);
        // Get operation
        temp = m.group(4);
        if (temp != null && !temp.equals("")) {
            this.operation = temp.charAt(0);
        }
        // Get operand-2
        temp = m.group(6);
        if (temp != null && !temp.equals("")) {
            this.op2Sign = temp.charAt(0);
        }
        this.op2 = m.group(7);
    }
    private String getErrorString() {
        return "Invalid expression[" + exp + "]"
                + "\nSupported expression syntax is: "
                + "op1 operation op2"
                + "\n where op1 and op2 can be a number "
                + " or a bind variable"
                + " , and operation can be"
                + " +, -, *, and /.";
    }
    @Override
    public String toString() {
        return "Expression: " + this.exp + ", op1 Sign = "
                + op1Sign + ", op1 = " + op1
                + ", op2 Sign = " + op2Sign
                + ", op2 = " + op2
                + ", operation = " + operation;
    }
}

Listing 10-23The Expression Class That Parses and Evaluates an Arithmetic Expression

```

`Expression`类被设计用来解析和评估以下形式的算术表达式

```
op1 operation op2

```

这里，`op1`和`op2`是两个操作数，可以是十进制格式的数字或变量，`operation`可以是`+`、`-`、`*`或`/`。

建议使用的`Expression`类是

```
Expression exp = new Expression(expression, scriptContext);
Double value = exp.eval();

```

让我们详细讨论一下`Expression`类的重要组件。实例变量`exp`和`context`分别是表达式和对表达式求值的`ScriptContext`。它们被传递给这个类的构造函数。

实例变量`op1`和`op2`分别表示表达式中的第一个和第二个操作数。实例变量`op1Sign`和`op2Sign`分别代表表达式中第一个和第二个操作数的符号，可以是`+`或`-`。当使用`parse()`方法解析表达式时，操作数及其符号被填充。

实例变量`operation`表示要对操作数执行的算术运算(+、-、*或/)。

实例变量`parsed`用于跟踪表达式是否已经被解析。`parse()`方法将其设置为`true`。

构造函数接受一个表达式和一个`ScriptContext`，确保它们不是`null`，并将它们存储在实例变量中。在将表达式存储到实例变量`exp`中之前，它会从表达式中删除开头和结尾的空白。

`parse()`方法将表达式解析成操作数和操作。它使用正则表达式来解析表达式文本。正则表达式要求表达式文本采用以下形式:

*   第一个操作数的可选符号`+`或`-`

*   第一个操作数，可以由字母数字、货币符号、下划线和小数点的组合组成

*   任何数量的空白

*   可能是`+`、`-`、`*`或`/`的操作标志

*   第二个操作数的可选符号`+`或`-`

*   第二个操作数，可以由字母数字、货币符号、下划线和小数点的组合组成

正则表达式`([+-]?)`将匹配操作数的可选符号。正则表达式`([\\pAlnum\\pSc_.]+)`会匹配一个操作数，可能是十进制数，也可能是名字。正则表达式`([\\s]*)`将匹配任意数量的空格。正则表达式`([+*/-])`将匹配一个操作符。所有正则表达式都用括号括起来形成组，这样就可以捕获表达式的匹配部分。

如果一个表达式匹配正则表达式，`parse()`方法将匹配存储到各自的实例变量中。

注意，匹配操作数的正则表达式并不完美。它将允许几种无效的情况，比如一个操作数有多个小数点，等等。然而，对于这个演示目的，它将做。

在表达式被解析后，在表达式求值期间使用`getOperandValue()`方法。如果操作数是一个`double`数，它通过应用操作数的符号返回值。否则，它会在`ScriptContext`中查找操作数的名称。如果在`ScriptContext`中没有找到操作数的名称，它抛出一个`RuntimeException`。如果在`ScriptContext`中找到操作数的名称，它将检查该值是否为数字。如果该值是一个数字，则在将符号应用于该值后返回该值；否则抛出一个`RuntimeException`。

`getOperandValue()`方法不支持十六进制、八进制和二进制格式的操作数。例如，像“0x2A + 0b1011”这样的表达式将不会被视为具有两个带`int`文字的操作数的表达式。读者可以增强这种方法，以支持十六进制、八进制和二进制格式的数字文字。

`eval()`方法计算表达式并返回一个`double`值。首先，如果表达式还没有被解析，它就解析它。注意，多次调用`eval()`只会解析表达式一次。它获取两个操作数的值，执行运算，并返回表达式的值。

### JKScriptEngine 类

清单 [10-24](#PC79) 包含了`JKScript`脚本引擎的实现。它的`eval(String, ScriptContext)`方法包含主要逻辑:

```
Expression exp = new Expression(script, context); Object result = exp.eval();

```

它创建了一个`Expression`类的对象。它调用评估表达式并返回结果的`Expression`对象的`eval()`方法。

`eval(Reader`，`ScriptContext)`方法从`Reader`中读取所有行，将它们连接起来，并将结果`String`传递给`eval(String, ScriptContext)`方法来计算表达式。注意一个`Reader`必须只有一个表达式。一个表达式可以拆分成多行。`Reader`中的空白被忽略。

```
// JKScriptEngine.java
package com.jdojo.jkscript;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import javax.script.AbstractScriptEngine;
import javax.script.Bindings;
import javax.script.ScriptContext;
import javax.script.ScriptEngineFactory;
import javax.script.ScriptException;
import javax.script.SimpleBindings;

public class JKScriptEngine extends AbstractScriptEngine {
    private final ScriptEngineFactory factory;
    public JKScriptEngine(ScriptEngineFactory factory) {
        this.factory = factory;
    }
    @Override
    public Object
    eval(String script, ScriptContext context)
    throws ScriptException {
        try {
            Expression exp =
                new Expression(script, context);
            Object result = exp.eval();
            return result;
        } catch (Exception e) {
            throw new ScriptException(e.getMessage());
        }
    }
    @Override
    public Object
    eval(Reader reader, ScriptContext context)
    throws ScriptException {
        // Read all lines from the Reader
        BufferedReader br = new BufferedReader(reader);
        String script = "";
        try {
            String str;
            while ((str = br.readLine()) != null) {
                script = script + str;
            }
        } catch (IOException e) {
            throw new ScriptException(e);
        }
        // Use the String version of eval()
        return eval(script, context);
    }
    @Override
    public Bindings createBindings() {
        return new SimpleBindings();
    }
    @Override
    Public  ScriptEngineFactory getFactory() {
        return factory;
    }
}

Listing 10-24An Implementation of the JKScript Script Engine

```

### JKScriptEngineFactory 类

清单 [10-25](#PC79) 包含了`JKScript`引擎的`ScriptEngineFactory`接口的实现。它的一些方法返回一个`"Not Implemented"`字符串，因为你不支持这些方法公开的特性。`JKScriptEngineFactory`类中的代码是不言自明的。使用`ScriptEngineManager`可以获得一个`JKScript`引擎的实例，其名称为`jks`、`JKScript`或`jkscript`，如`getNames()`方法中编码的那样。

```
// JKScriptEngineFactory.java
package com.jdojo.jkscript;
import java.util.List;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineFactory;
public class JKScriptEngineFactory
        implements ScriptEngineFactory {
    @Override
    public String getEngineName() {
        return "JKScript Engine";
    }
    @Override
    public String getEngineVersion() {
        return "1.0";
    }
    @Override
    public List<String> getExtensions() {
        return List.of("jks");
    }
    @Override
    public List<String> getMimeTypes() {
        return List.of("text/jkscript");
    }
    @Override
    public List<String> getNames() {
        return List.of("jks", "JKScript", "jkscript");
    }
    @Override
    public String getLanguageName() {
        return "JKScript";
    }
    @Override
    public String getLanguageVersion() {
        return "1.0";
    }
    @Override
    public Object getParameter(String key) {
        switch (key) {
            case ScriptEngine.ENGINE:
                return getEngineName();
            case ScriptEngine.ENGINE_VERSION:
                return getEngineVersion();
            case ScriptEngine.NAME:
                return getEngineName();
            case ScriptEngine.LANGUAGE:
                return getLanguageName();
            case ScriptEngine.LANGUAGE_VERSION:
                return getLanguageVersion();
            case "THREADING":
                return "MULTITHREADED";
            default:
                return null;
        }
    }
    @Override
    public String
    getMethodCallSyntax(String obj, String m, String[] p) {
        return "Not implemented";
    }
    @Override
    public String
    getOutputStatement(String toDisplay) {
        return "Not implemented";
    }
    @Override
    public String
    getProgram(String[] statements) {
        return "Not implemented";
    }
    @Override
    public ScriptEngine
    getScriptEngine() {
        return new JKScriptEngine(this);
    }
}

Listing 10-25A ScriptEngineFactory Implementation for the JKScript Script Engine

```

### 打包 jscript 文件

要让其他人使用您的 JKScript 引擎，您需要做的就是为`jdojo.jkscript`模块提供模块化 JAR。

### 使用 jscript 脚本引擎

是时候测试您的 JKScript 脚本引擎了。第一步也是最重要的一步是将您在上一节中创建的`jdojo.jkscript.jar`包含到应用程序的模块路径中。之后，使用 JKScript 脚本引擎与使用任何其他脚本引擎没有什么不同。

下面的代码片段使用 JKScript 作为其名称来创建 JKScript 脚本引擎的实例。您也可以使用它的其他名称，`jks`和`jkscript`:

```
// Create the JKScript engine
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("JKScript");
if (engine == null) {
    System.out.println(
        "JKScript engine is not available. ");
    System.out.println(
        "Add jkscript.jar to CLASSPATH.");
else {
    // Evaluate your JKScript
}

```

清单 [10-26](#PC82) 包含一个使用 JKScript 脚本引擎评估不同类型表达式的程序。执行存储在`String`对象和文件中的表达式。一些表达式使用数字文字和一些绑定变量，它们的值在引擎范围和引擎的默认`ScriptContext`的全局范围中的绑定中传递。注意，这个程序期望在当前目录中有一个名为`jkscript.txt`的文件，其中包含一个可以被`JKScript`脚本引擎理解的算术表达式。如果脚本文件不存在，程序将在标准输出中打印一条消息，其中包含预期脚本文件的路径。您可能会在最后一行得到不同的输出。

```
// JKScriptTest.java
package com.jdojo.script;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
public class JKScriptTest {
    public static void
    main(String[] args)
    throws FileNotFoundException, IOException {
        // Create JKScript engine
        ScriptEngineManager manager =
            new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(
            "JKScript");
        if (engine == null) {
            System.out.println(
                "JKScript engine is not available. ");
            System.out.println(
                "Add jkscript.jar to CLASSPATH.");
            return;
        }
        // Test scripts as String
        testString(manager, engine);
        // Test scripts as a Reader
        testReader(manager, engine);
    }
    public static void
    testString(ScriptEngineManager manager,
            ScriptEngine engine) {
        try {
            // Use simple expressions with numeric literals
            String script = "12.8 + 15.2";
            Object result = engine.eval(script);
            System.out.println(script + " = " + result);
            script = "-90.0 - -10.5";
            result = engine.eval(script);
            System.out.println(script + " = " + result);
            script = "5 * 12";
            result = engine.eval(script);
            System.out.println(script + " = " + result);
            script = "56.0 / -7.0";
            result = engine.eval(script);
            System.out.println(script + " = " + result);
            // Use global scope bindings variables
            manager.put("num1", 10.0);
            manager.put("num2", 20.0);
            script = "num1 + num2";
            result = engine.eval(script);
            System.out.println(script + " = " + result);
            // Use global and engine scopes bindings.
            // num1 from engine scope and num2 from
            // global scope will be used.
            engine.put("num1", 70.0);
            script = "num1 + num2";
            result = engine.eval(script);
            System.out.println(script + " = " + result);
            // Try mixture of number literal and bindings.
            // num1 from the engine scope bindings will be
            // used
            script = "10 + num1";
            result = engine.eval(script);
            System.out.println(script + " = " + result);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }
    public static void
    testReader(ScriptEngineManager manager,
            ScriptEngine engine) {
        try {
            Path scriptPath = Paths.get("jkscript.txt").
                toAbsolutePath();
            if (!Files.exists(scriptPath)) {
                System.out.println(scriptPath +
                    " script file does not exist.");
                return;
            }
            try (Reader reader = Files.
                    newBufferedReader(scriptPath);) {
                Object result = engine.eval(reader);
                System.out.println("Result of " +
                    scriptPath + " = " + result);
            }
        } catch (ScriptException | IOException e) {
            e.printStackTrace();
        }
    }
}

12.8 + 15.2 = 28.0
-90.0 - -10.5 = -79.5
5 * 12 = 60.0
56.0 / -7.0 = -8.0
num1 + num2 = 30.0
num1 + num2 = 90.0
10 + num1 = 80.0
Result of C:\Java9APIsAndModules\jkscript.txt = 88.0

Listing 10-26Using the JKScript Script Engine

```

## Groovy 中的 JavaFX

我们可以使用脚本来加速 JavaFX 的开发。事实上，混合 Java 代码和脚本有助于分离前端和后端逻辑，并且因为脚本比 Java 代码更简洁，所以可以节省一些开发时间。

清单 [10-27](#PC83) 包含一个简单的 HelloWorld 风格的 JavaFX 应用程序。

```
package com.jdojo.groovyfx;

import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javafx.application.Application;
import javafx.stage.Stage;

public class HelloGroovyFX extends Application {
    private Invocable inv;

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void init() {
        // Create a script engine manager
        ScriptEngineManager manager =
            new ScriptEngineManager();
        // Obtain a Groovy script engine from the manager
        ScriptEngine engine =
            manager.getEngineByName("Groovy");
        // Store the Groovy script in a String
        String script = """
import javafx.scene.Scene
import javafx.scene.control.Button
import javafx.scene.layout.StackPane
import javafx.beans.property.SimpleStringProperty as SP

def go(def primaryStage) {
  primaryStage.setTitle "Hello World!"
  Button btn = new Button()
  btn.text = "Say 'Hello World'"
  btn.onAction = { def event ->
      println("Hello World!")
  }

  StackPane root = new StackPane()
  root.children.add(btn)
  primaryStage.scene = new Scene(root, 300, 250)
  primaryStage.show()
}
            """;
        try {
            // Execute the script
            engine.eval(script);
            inv = (Invocable) engine;
        } catch (ScriptException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void start(Stage primaryStage) {
        try {
            inv.invokeFunction("go", primaryStage);
        } catch (Exception e) {
            e.printStackTrace();
        }
   }
}

Listing 10-27A JavaFX Application Using a Groovy Script

```

为此，您必须添加 JavaFX 库。对于 Maven 项目来说，这很容易。只是补充

```
<dependency>
  <groupId>org.openjfx</groupId>
  <artifactId>javafx-base</artifactId>
  <version>16</version>
</dependency>
<dependency>
  <groupId>org.openjfx</groupId>
  <artifactId>javafx-graphics</artifactId>
  <version>16</version>
</dependency>
<dependency>
  <groupId>org.openjfx</groupId>
  <artifactId>javafx-controls</artifactId>
  <version>16</version>
</dependency>
<dependency>
  <groupId>org.openjfx</groupId>
  <artifactId>javafx-web</artifactId>
  <version>16</version>
</dependency>

```

在您的`pom.xml`文件的`<dependencies>`部分中。

与 Java 相比，Groovy 版本的前端代码要简单一些。在脚本中，您可以使用 Java 类的属性来调用它们的方法。例如，不要用 Java 编写:

```
btn.setText("Say 'Hello World'");

```

你可以用 Groovy 写这个:

```
btn.text = "Say 'Hello World'"

```

此规则的一个例外是

```
primaryStage.setTitle "Hello World!"

```

因为在`Stage`类中，`title`字段的类型不同于`String`。

为按钮添加事件处理程序也更容易。您可以使用 Groovy 闭包作为按钮的事件处理程序。请注意，您也可以使用`onAction`属性来设置事件处理程序，而不是调用`Button`类的`setOnAction()`方法。以下代码片段显示了如何为按钮设置`ActionEvent`处理程序:

```
  btn.onAction = { def event ->
      println("Hello World!")
  }

```

图 [10-7](#Fig7) 显示了正在运行的 JavaFX 应用程序。

![../images/323070_3_En_10_Chapter/323070_3_En_10_Fig7_HTML.png](../images/323070_3_En_10_Chapter/323070_3_En_10_Fig7_HTML.png)

图 10-7

带有 Groovy 脚本的 JavaFX 应用程序

## 摘要

脚本语言是一种编程语言，它使您能够编写由运行时环境评估(或解释)的脚本，运行时环境称为脚本引擎(或解释器)。脚本是使用脚本语言的语法编写的字符序列，用作由解释器执行的程序的源。Java 脚本 API 允许您执行用任何脚本语言编写的脚本，这些脚本可以从 Java 应用程序编译成 Java 字节码。

使用脚本引擎执行脚本，脚本引擎是`ScriptEngine`接口的一个实例。`ScriptEngine`接口的实现者也提供了`ScriptEngineFactory`接口的实现，其工作是创建脚本引擎的实例并提供关于脚本引擎的细节。`ScriptEngineManager`类为脚本引擎提供了发现和实例化机制。一个`ScriptManager`维护一个键值对的映射，作为一个由它创建的所有脚本引擎共享的`Bindings`接口的实例。

您可以执行包含在`String`或`Reader`中的脚本。`ScriptEngine`的`eval()`方法用于执行脚本。您可以使用`ScriptContext`向脚本传递参数。传递的参数可以是脚本引擎的本地参数，脚本执行的本地参数，或者由`ScriptManager`创建的所有脚本引擎的全局参数。使用 Java 脚本 API，您还可以执行用脚本语言编写的过程和函数。如果脚本引擎支持，您还可以预编译脚本，并执行从 Java 重复的脚本以获得更好的性能。

您可以使用 Java 脚本 API 实现您的脚本引擎。您需要为`ScriptEngine`和`ScriptEngineFactory`接口提供实现。你需要以某种方式打包你的脚本引擎代码，这样引擎就可以在运行时被`ScriptManager`发现。

## 练习

**练习** 1

什么是脚本语言？

**练习** 2

哪个 JDK 模块包含脚本 API？

**运动** 3

简述以下类和接口的使用:`ScriptEngineFactory`、`ScriptEngine`、`ScriptEngineManager`、`Compilable`、`Invocable`、`Bindings`、`ScriptContext`、`ScriptException`。

**演习** 4

一个`ScriptEngine`的`eval()`方法有什么用？

**锻炼** 5

编写一个程序，在其中使用`SimpleScriptContext`类创建一个`ScriptContext`接口的实例。在引擎范围和全局范围中存储一些属性，检索相同的属性，并打印它们的值。

**锻炼** 6

如何向全局范围和引擎范围添加属性？

**锻炼** 7

如何将由`ScriptEngine`执行的脚本输出发送到一个文件中？

**运动** 8

编写一段代码来检查`ScriptEngine`是否支持编译脚本。

**演习** 9

使用`java.util.List`接口的`of()`方法创建一个不可修改的两个字符串的列表，并打印列表中的值。使用 Groovy 脚本编写代码。

**运动** 10

如果您想要推出自己的脚本引擎，那么您必须提供其实现的服务接口的名称是什么？