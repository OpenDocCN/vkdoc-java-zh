# 二十六、理解 FXML

在本章中，您将学习:

*   什么是 FXML

*   如何编辑 FXML 文档

*   FXML 文档的结构

*   如何在 FXML 文档中创建对象

*   如何在 FXML 文档中指定资源的位置

*   如何在 FXML 文档中使用资源包

*   如何从一个 FXML 文档引用其他 FXML 文档

*   如何在 FXML 文档中引用常量

*   如何引用其他元素以及如何在 FXML 文档中复制元素

*   如何在 FXML 文档中绑定属性

*   如何使用 FXML 创建自定义控件

本章的例子在`com.jdojo.fxml`包中。为了让它们工作，您必须在`module-info.java`文件中添加相应的一行:

```java
...
opens com.jdojo.fxml to javafx.graphics, javafx.base;
...

```

## 什么是 FXML？

FXML 是一种基于 XML 的语言，旨在为 JavaFX 应用程序构建用户界面。您可以使用 FXML 构建整个场景或场景的一部分。FXML 允许应用程序开发人员将构建 UI 的逻辑与业务逻辑分开。如果应用程序的 UI 部分发生变化，您不需要重新编译 JavaFX 代码。相反，您可以使用文本编辑器更改 FXML 并重新运行应用程序。您仍然使用 JavaFX 通过 Java 语言编写业务逻辑。FXML 文档是 XML 文档。理解本章需要 XML 的基础知识。

JavaFX 场景图是 Java 对象的层次结构。XML 格式非常适合存储表示某种层次结构的信息。所以用 FXML 存储场景图是非常直观的。在 JavaFX 应用程序中使用 FXML 构建场景图是很常见的。然而，FXML 的使用并不仅限于构建场景图。它可以构建 Java 对象的分层对象图。事实上，它只能用来创建一个对象，比如一个`Person`类的对象。

让我们快速预览一下 FXML 文档的样子。首先，创建一个简单的 UI，它由一个带有一个 ?? 的 ?? 和一个 ?? 组成。清单 26-1 包含了构建 UI 的 JavaFX 代码，这是您所熟悉的。清单 26-2 包含了用于构建相同 UI 的 FXML 版本。

```java
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Button?>

<VBox>
        <children>

                <Label text="FXML is cool"/>
                <Button text="Say Hello"/>
        </children>
</VBox>

Listing 26-2A Code Snippet to Build an Object Graph in FXML

```

```java
import javafx.scene.layout.VBox;
import javafx.scene.control.Label;
import javafx.scene.control.Button;

VBox root = new VBox();
root.getChildren().addAll(new Label("FXML is cool"), new Button("Say Hello"));

Listing 26-1A Code Snippet to Build an Object Graph in JavaFX

```

`FXML`中的第一行是 XML 解析器使用的标准 XML 声明。它在 FXML 中是可选的。如果省略，则版本和编码分别假定为 1 和 UTF-8。接下来的三行是导入语句，对应于 Java 代码中的导入语句。代表 UI 的元素，如`VBox`、`Label`和`Button`，与 JavaFX 类同名。`<children>`标签指定了`VBox`的子节点。使用各自元素的`text`属性来指定`Label`和`Button`的文本属性。

## 编辑 FXML 文档

FXML 文档只是一个文本文件。通常，文件名有一个`.fxml`扩展名(例如`hello.fxml`)。例如，您可以使用记事本在 Windows 中创建 FXML 文档。如果您使用过 XML，就会知道在文本编辑器中编辑大型 XML 文档并不容易。胶子公司提供了一个名为*场景构建器*的可视化编辑器，用于编辑 FXML 文档。场景构建器是开源的。可以从 [`https://gluonhq.com/products/scene-builder/`](https://gluonhq.com/products/scene-builder/) 下载其最新版本。Scene Builder 也可以集成到一些 ide 中，因此您可以在 IDE 中使用 Scene Builder 编辑 FXML 文档。本书不讨论场景构建器。

## FXML 基础

本节涵盖了 FXML 的基础知识。您将开发一个简单的 JavaFX 应用程序，它由以下内容组成:

*   答`VBox`

*   答`Label`

*   答`Button`

`VBox`的`spacing`属性被设置为 10px。`Label`和`Button`的`text`属性被设置为“FXML 太酷了！”还有“问好”。当点击`Button`时，`Label`中的文本变为“Hello from FXML！”。图 26-1 显示了应用程序显示的窗口的两个实例。

![img/336502_2_En_26_Fig1_HTML.png](img/336502_2_En_26_Fig1_HTML.png)

图 26-1

窗口的两个实例，其场景图形是使用 FXML 创建的

清单 26-3 中的程序是示例应用程序的 JavaFX 实现。如果你已经完成了书中的这一章，这个程序应该很容易。

```java
// HelloJavaFX.java
package com.jdojo.fxml;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class HelloJavaFX extends Application {
        private final Label msgLbl = new Label("FXML is cool!");

        private final Button sayHelloBtn = new Button("Say Hello");

        public static void main(String[] args) {
                Application.launch(args);
        }

        @Override
        public void start(Stage stage) {
                // Set the preferred width of the label
                msgLbl.setPrefWidth(150);

                // Set the ActionEvent handler for the button
                sayHelloBtn.setOnAction(this::sayHello);

                VBox root = new VBox(10);
                root.getChildren().addAll(msgLbl, sayHelloBtn);
                root.setStyle("""
                         -fx-padding: 10;
                   -fx-border-style: solid inside;
                   -fx-border-width: 2;
                   -fx-border-insets: 5;
                   -fx-border-radius: 5;
                   -fx-border-color: blue;""");
                Scene scene = new Scene(root);
                stage.setScene(scene);
                stage.setTitle("Hello FXML");
                stage.show();
        }

        public void sayHello(ActionEvent e) {
                msgLbl.setText("Hello from FXML!");
        }

}

Listing 26-3The JavaFX Version of the FXML Example Application

```

### 创建 FXML 文件

让我们创建一个 FXML 文件`sayhello.fxml`。将文件存储在`resources/fxml`目录中，其中`resources`目录由`ResourceUtil`类正确寻址。

### 添加 UI 元素

FXML 文档的根元素是对象图中的顶级对象。你的顶层对象是一个`VBox`。因此，FXML 的根元素应该是

```java
<VBox>
</VBox>

```

你怎么知道要在对象图中表示一个`VBox`，你需要在 FXML 中使用一个`<VBox>`标签？这既困难又容易。这很困难，因为没有关于 FXML 标记的文档。这很简单，因为 FXML 有几条规则解释标签名的构成。例如，如果一个标记名是一个类的简单名或完全限定名，该标记将创建该类的一个对象。前面的元素将创建一个`VBox`类的对象。可以使用完全限定的类名重写前面的 FXML:

```java
<javafx.scene.layout.VBox>
</javafx.scene.layout.VBox>

```

在 JavaFX 中，布局窗格有子级。在 FXML 中，布局窗格的子元素是子元素。您可以为`VBox`添加一个`Label`和一个`Button`，如下所示:

```java
<VBox>
        <Label></Label>
        <Button></Button>
</VBox>

```

这为这个示例应用程序定义了对象图的基本结构。它将创建一个带有一个`Label`和一个`Button`的`VBox`。剩下的讨论将集中在添加细节上，例如，为控件添加文本和为`VBox`设置样式。

前面的 FXML 显示了`Label`和`Button`是`VBox`的子元素。从 GUI 的角度来看，确实如此。但是，从技术上来说，它们属于`VBox`对象的`children`属性，而不直接属于`VBox`。为了更专业(也更详细)，您可以重写前面的 FXML，如下所示:

```java
<VBox>
        <children>
                <Label></Label>
                <Button></Button>
        <children>
</VBox>

```

您如何知道可以忽略前面 FXML 中的`<children>`标签，并仍然得到相同的结果？JavaFX 库在`javafx.beans`包中包含一个注释`DefaultProperty`。它可以用来注释类。它包含一个`String`类型的值元素。元素指定类的属性，该属性应被视为 FXML 中的默认属性。如果 FXML 中的子元素不表示其父元素的属性，则它属于父元素的默认属性。`VBox`类继承自`Pane`类，其声明如下:

```java
@DefaultProperty(value="children")
public class Pane extends Region {...}

```

对`Pane`类的注释使`children`属性成为 FXML 中的默认属性。`VBox`从`Pane`类继承了这个注释。这就是前面的 FXML 中可以省略`<children>`标签的原因。如果您在一个类上看到了`DefaultProperty`注释，这意味着您可以省略 FXML 中默认属性的标签。

### 在 FXML 中导入 Java 类型

要在 FXML 中使用 Java 类的简单名称，必须像在 Java 程序中一样导入类。有一个例外。在 Java 程序中，不需要从`java.lang`包中导入类。然而，在 FXML 中，您需要从所有包中导入类，包括`java.lang`包。导入处理指令用于从包中导入一个类或所有类。以下处理指令导入了`VBox`、`Label`和`Button`类:

```java
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Button?>

```

以下导入处理指令从`javafx.scene.control`和`java.lang`包中导入所有类:

```java
<?import javafx.scene.control.*?>
<?import java.lang.*?>

```

FXML 不支持导入静态成员。请注意，import 语句不使用尾随分号。

### 在 FXML 中设置属性

您可以在 FXML 中设置 Java 对象的属性。如果属性声明遵循 JavaBean 约定，则可以在 FXML 中设置对象的属性。设置属性有两种方式:

*   使用 FXML 元素的属性

*   使用属性元素

属性名称或属性元素名称与正在设置的属性的名称相同。下面的 FXML 创建一个`Label`并使用属性设置其`text`属性:

```java
<Label text="FXML is cool!"/>

```

下面的 FXML 使用属性元素实现了同样的目的:

```java
<Label>
        <text>FXML is cool!</text>
</Label>

```

下面的 FXML 创建一个`Rectangle`，并使用属性设置它的`x`、`y`、`width`、`height`和`fill`属性:

```java
<Rectangle x="10" y="10" width="100" height="40" fill="red"/>

```

FXML 将属性值指定为`Strings`。自动应用适当的转换将`String`值转换为所需的类型。在前面的例子中，`fill`属性的值“红色”将被自动转换成一个`Color`对象，`width`属性的值“100”将被转换成一个双精度值，依此类推。

使用属性元素设置对象属性更加灵活。当可以从`String`自动转换类型时，可以使用属性。假设您想将一个`Person`类的对象设置为一个对象的属性。这可以使用属性元素来完成。下面的 FXML 设置了类`MyCls`的对象的`person`属性:

```java
<MyCls>
        <person>
                <Person>
                        <!-- Configure the Person object here -->
                </Person>
        </person>
</MyCls>

```

只读属性是有 getter 但没有 setter 的属性。使用 property 元素可以在 FXML 中设置两种特殊类型的只读属性:

*   只读的`List`属性

*   只读的`Map`属性

使用 property 元素设置只读的`List`属性。property 元素的所有子元素都将被添加到属性 getter 返回的`List`中。下面的 FXML 设置了一个`VBox`的只读`children`属性:

```java
<VBox>
        <children>
                <Label/>
                <Button/>
        <children>
</VBox>

```

您可以使用 property 元素的属性向只读的`Map`属性添加条目。属性的名称和值成为`Map`中的键和值。下面的代码片段声明了一个类`Item`，它有一个只读的`map`属性:

```java
public class Item {
        private Map<String, Integer> map = new HashMap<>();
        public Map getMap() {
                return map;
        }
}

```

下面的 FXML 创建一个`Item`对象，并用两个条目(“n1”，100)和(“n2”，200)设置它的`map`属性。注意属性 n1 和 n2 的名称成为了`Map`中的键:

```java
<Item>
        <map n1="100" n2="200"/>
</Item>

```

Java 对象有一种特殊类型的属性，称为静态属性。静态属性未在对象的类上声明。相反，它是使用另一个类的静态方法设置的。假设您想要为将被放置在`VBox`中的`Button`设置边距。JavaFX 代码如下所示:

```java
Button btn = new Button("OK");
Insets insets = new Insets(20.0);;
VBox.setMargin(btn, insets);
VBox vbox = new VBox(btn);

```

通过为`Button`设置一个`VBox.margin`属性，您可以在 FXML 中实现同样的功能:

```java
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Button?>
<?import javafx.geometry.Insets?>

<VBox>
    <Button text="OK">
        <VBox.margin>
            <Insets top="20.0" right="20.0" bottom="20.0" left="20.0"/>
        </VBox.margin>
    </Button>
</VBox>

```

您不能从`String`创建`Insets`对象，因此，您不能使用属性来设置 margin 属性。您需要使用属性元素来设置它。当您在 FXML 中使用`GridPane`时，您可以设置`rowIndex`和`columnIndex`静态，如下所示:

```java
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.control.Button?>

<GridPane>
        <Button text="OK">
                <GridPane.rowIndex>0</GridPane.rowIndex>
                <GridPane.columnIndex>0</GridPane.columnIndex>
        </Button>
</GridPane>

```

因为`rowIndex`和`columnIndex`属性也可以表示为`Strings`，所以可以使用属性来设置它们:

```java
<GridPane>
        <Button text="OK" GridPane.rowIndex="0" GridPane.columnIndex="0"/>
</GridPane>

```

### 指定 FXML 命名空间

FXML 没有 XML 架构。它使用的名称空间需要使用名称空间前缀“fx”来指定。在大多数情况下，FXML 解析器会计算出标记名，比如作为类的标记名、类的属性等等。fxML 使用特殊的元素和属性名，必须用“FX”名称空间前缀进行限定。以下 fxML 声明了“FX”命名空间前缀:

```java
<VBox xmlns:fx="http://javafx.com/fxml">...</VBox>

```

或者，您可以在命名空间 URI 中追加 FXML 的版本。FXML 解析器将验证它可以解析指定的 XML 代码。在撰写本文时，唯一支持的版本是 1.0:

```java
<VBox xmlns:fx="http://javafx.com/fxml/1.0">...</VBox>

```

FXML 版本可以包括点、下划线和破折号。只比较下划线和破折号第一次出现之前的数字。以下三个声明都将 FXML 版本指定为 1.0:

```java
<VBox xmlns:fx="http://javafx.com/fxml/1">...</VBox>
<VBox xmlns:fx="http://javafx.com/fxml/1.0-ea">...</VBox>
<VBox xmlns:fx="http://javafx.com/fxml/1.0-rc1-2014_03_02">...</VBox>

```

Tip

`<fx:script>`标签就是这种命名空间标签的一个例子。它用于向 FXML 文件添加脚本逻辑。但是，尽量避免。首先，FXML 中的脚本支持似乎不是很稳定。其次，将处理逻辑添加到 FXML 前端定义中被认为不是一种好的编程风格。最好使用控制器，我们简称它。

### 为对象分配标识符

在 FXML 中创建的对象可以在同一文档的其他地方引用。在 JavaFX 代码中获取在 FXML 中创建的 UI 对象的引用是很常见的。您可以通过首先用一个`fx:id`属性标识 FXML 中的对象来实现这一点。属性的值是对象的标识符。如果对象类型有一个`id`属性，该属性的值也将被设置。注意 JavaFX 中的每个`Node`都有一个`id`属性，可以用来在 CSS 中引用它们。以下是为`Label`指定`fx:id`属性的示例:

```java
<Label fx:id="msgLbl" text="FXML is cool!"/>

```

现在，您可以使用`msgLbl`来引用`Label`。属性`fx:id`有几种用法。例如，它用于在加载 FXML 时将 UI 元素的引用注入到 JavaFX 类的实例变量中。我将在单独的部分讨论这一点。

### 添加事件处理程序

可以为 FXML 中的节点设置事件处理程序。设置事件处理程序类似于设置任何其他属性。JavaFX 类定义了`onXxx`属性来为`Xxx`事件设置事件处理程序。例如，`Button`类包含一个`onAction`属性来设置一个`ActionEvent`处理程序。在 FXML 中，可以指定两种类型的事件处理程序:

*   编写事件处理程序脚本

*   控制器事件处理程序

在本书中，我们只讨论控制器事件处理程序，因为通常最好将编程逻辑远离 GUI。我将在“在 FXML 中使用控制器”一节中讨论如何指定控制器事件处理程序。

 *### 正在加载 FXML 文档

FXML 文档定义了 JavaFX 应用程序的视图(GUI)部分。您需要加载 FXML 文档来获得它所代表的对象图。加载 FXML 是由`FXMLLoader`类的一个实例执行的，它在`javafx.fxml`包中。

`FXMLLoader`类提供了几个构造器，允许您指定位置、字符集、资源包和其他用于加载文档的元素。您至少需要指定 FXML 文档的位置，这是一个`URL`。该类包含执行文档实际加载的`load()`方法。以下代码片段从 Windows 中的本地文件系统加载 FXML 文档:

```java
String fxmlDocUrl = "file:///C:/resources/fxml/test.fxml";
URL fxmlUrl = new URL(fxmlDocUrl);
FXMLLoader loader = new FXMLLoader();
loader.setLocation(fxmlUrl);
VBox root = loader.<VBox>load();

```

`load()`方法有一个通用的返回类型。在前面的代码片段中，您已经在对`load()`方法(`loader.<VBox>load()`)的调用中清楚地表达了您的意图，即您期望从 FXML 文档中得到一个`VBox`实例。如果您愿意，可以省略通用参数:

```java
// Will work
VBox root = loader.load();

```

`FXMLLoader`支持使用`InputStream`加载 FXML 文档。下面的代码片段使用一个`InputStream`加载相同的 FXML 文档:

```java
FXMLLoader loader = new FXMLLoader();
String fxmlDocPath = "C:\\resources\\fxml\\test.fxml";
FileInputStream fxmlStream = new FileInputStream(fxmlDocPath);
VBox root = loader.<VBox>load(fxmlStream);

```

在内部，`FXMLLoader`使用流读取文档，这可能会抛出一个`IOException`。所有版本的 l `oad()`方法在`FXMLLoader`类中抛出`IOException`。您在前面的示例代码中省略了异常处理代码。在您的应用程序中，您需要处理异常。

`FXMLLoader`类包含了几个版本的`load()`方法。有些是实例方法，有些是静态方法。如果您想从加载器中检索更多信息，比如控制器引用、资源包、位置、字符集和根对象，您需要创建一个`FXMLLoader`实例并使用 instance `load()`方法。如果你只想加载一个 FXML 文档而不考虑任何其他细节，你需要使用静态的`load()`方法。以下代码片段使用静态`load()`方法加载 FXML 文档:

```java
String fxmlDocUrl = "file:///C:/resources/fxml/test.fxml";
URL fxmlUrl = new URL(fxmlDocUrl);
VBox root = FXMLLoader.<VBox>load(fxmlUrl);

```

加载 FXML 文档后，下一步做什么？至此，FXML 的作用已经结束，您的 JavaFX 代码应该接管了。我将在本文后面讨论加载器。

清单 26-4 中的程序有这个例子的 JavaFX 代码。它加载存储在 *sayHello.fxml* 文件中的 FXML 文档。程序使用`ResourceUtil`实用程序类加载文档。加载器返回一个`VBox`，它被设置为场景的根。除了在`start()`方法的声明中有一处不同之外，代码的其余部分与您一直使用的相同。该方法声明它可能抛出一个`IOException`，这是您必须添加的，因为您已经在方法内部调用了`FXMLLoader`的`load()`方法。运行程序时，显示如图 26-1 所示的窗口。

```java
// SayHelloFXML.java
package com.jdojo.fxml;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import java.io.IOException;
import java.net.URL;
import com.jdojo.util.ResourceUtil;
import javafx.scene.Scene;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class SayHelloFXML extends Application {
        public static void main(String[] args) {
                Application.launch(args);
        }

        @Override
        public void start(Stage stage) throws IOException {
            // Construct a URL for the FXML document
                URL fxmlUrl =
                    ResourceUtil.getResourceURL("fxml/sayhello.fxml");

                // Load the FXML document
                VBox root = FXMLLoader.<VBox>load(fxmlUrl);
                Scene scene = new Scene(root);
                stage.setScene(scene);
                stage.setTitle("Hello FXML");
                stage.show();
        }
}

Listing 26-4Using FXML to Build the GUI

```

如果你点击这个按钮，什么都不会发生。我们将在下一节讨论将 UI 连接到 Java 代码。

### 在 FXML 中使用控制器

控制器只是一个类名，其对象由 FXML 创建，用于初始化 UI 元素。FXML 允许您使用`fx:controller`属性在根元素上指定一个控制器。注意，每个 FXML 文档只允许一个控制器，如果指定了控制器，必须在根元素上指定。

下面的 FXML 为`VBox`元素指定了一个控制器:

```java
<VBox fx:controller="com.jdojo.fxml.SayHelloController"
      xmlns:fx="http://javafx.com/fxml">
</VBox>

```

控制器需要符合一些规则，它可以用于不同的原因:

*   控制器由 FXML 加载器实例化。

*   控制器必须有一个公共的无参数构造器。如果它不存在，FXML 加载器将无法实例化它，这将在加载时引发异常。

*   控制器可以有可访问的方法，这些方法可以被指定为 FXML 中的事件处理程序。关于“可访问”的含义，请参考下面的讨论

*   FXML 加载器将自动寻找控制器的可访问实例变量。如果可访问实例变量的名称与元素的`fx:id`属性匹配，则 FXML 中的对象引用会自动复制到控制器实例变量中。这个特性使得控制器可以引用 FXML 中的 UI 元素。控制器可以在以后使用它们，比如将它们绑定到模型。

*   控制器可以有一个可访问的`initialize()`方法，该方法应该不带参数，返回类型为`void`。FXML 加载器将在 FXML 文档加载完成后调用`initialize()`方法。

清单 26-5 显示了您将在本例中使用的控制器类的代码。

```java
// SayHelloController.java
package com.jdojo.fxml;

import java.net.URL;
import java.util.ResourceBundle;
import javafx.fxml.FXML;
import javafx.scene.control.Label;

public class SayHelloController {
        // The reference of msgLbl will be injected by the FXML loader
        @FXML
        private Label msgLbl;

        // location and resources will be automatically injected by the
           // FXML loader
        @FXML
        private URL location;

        @FXML
        private ResourceBundle resources;

        // Add a public no-args constructor explicitly just to
        // emphasize that it is needed for a controller
        public SayHelloController() {
        }

        @FXML
        private void initialize() {
                System.out.println("Initializing SayHelloController...");
                System.out.println("Location = " + location);
                System.out.println("Resources = " + resources);
        }

        @FXML
        private void sayHello() {
                msgLbl.setText("Hello from FXML!");
        }
}

Listing 26-5A Controller Class

```

控制器类在一些成员上使用了一个`@FXML`注释。`@FXML`注释可以用在字段和方法上。它不能用于类和构造器。通过在成员上使用`@FXML`注释，您声明了 FXML 加载器可以访问成员，即使它是私有的。FXML loader 使用的公共成员不需要用`@FXML`注释。然而，用`@FXML`注释公共成员并不是错误。最好用`@FXML`注释来注释 FXML 加载器使用的所有成员，公共的和私有的。这告诉代码的读者成员是如何被使用的。

下面的 FXML 将控制器类的`sayHello()`方法设置为`Button`的事件处理程序:

```java
<VBox fx:controller="com.jdojo.fxml.SayHelloController"
      xmlns:fx="http://javafx.com/fxml">
        <Button fx:id="sayHelloBtn" text="Say Hello" onAction="#sayHello"/>
...
</VBox>

```

有两个特殊的实例变量可以在控制器中声明，它们由 FXML 加载器自动注入:

*   `@FXML private URL location;`

*   `@FXML private ResourceBundle resources;`

`location`是 FXML 文档的位置。`resources`是 FXML 中使用的`ResourceBundle`的引用，如果有的话。

当事件处理程序属性值以散列符号(#)开始时，它向 FXML loader 表明`sayHello`是控制器中的方法。控制器中的事件处理程序方法应该符合一些规则:

*   该方法可以不带参数，也可以只带一个参数。如果它接受一个参数，参数类型必须是与它应该处理的事件兼容的类型赋值。

*   拥有该方法的两个版本并不是错误:一个不带参数，另一个只有一个参数。在这种情况下，使用带有单个参数的方法。

*   按照惯例，方法返回类型应该是`void`，因为没有返回值的接受者。

*   FXML 加载器必须可以访问该方法:将其公开或者用`@FXML`对其进行注释。

当 FXML 加载器加载完 FXML 文档后，它调用控制器的`initialize()`方法。该方法不应采用任何参数。FXML 加载器应该可以访问它。在控制器中，您使用了`@FXML`注释使 FXML 加载器可以访问它。

`FXMLLoader`类允许您使用`setController()`方法为代码中的根元素设置控制器。使用`getController()`方法从加载器获取控制器的参考。开发人员在获取控制器的引用时会犯一个常见的错误。这个错误是由于`load()`方法的设计方式造成的。`load()`方法有七个重载版本:其中两个是实例方法，五个是静态方法。要使用`getController()`方法，必须创建一个`FXMLLoader`类的对象，并确保使用该类的一个实例方法来加载文档。下面是一个常见错误的例子:

```java
URL fxmlUrl = new URL("file:///C:/resources/fxml/test.fxml");

// Create an FXMLLoader object – a good start
FXMLLoader loader = new FXMLLoader();

// Load the document -- mistake
VBox root = loader.<VBox>load(fxmlUrl);

// loader.getController() will return null
Test controller = loader.getController();
// controller is null here

```

前面的代码创建了一个`FXMLLoader`类的对象。然而，在`loader`变量中调用的`load(URL url)`方法是静态的`load()`方法，而不是实例`load()`方法。因此，`loader`实例从未获得控制器，当您向它请求控制器时，它会返回`null`。为了消除混淆，下面是`load()`方法的实例和静态版本，其中只有前两个版本是实例方法:

*   `<T> T load()`

*   `<T> T load(InputStream inputStream)`

*   `static <T> T load(URL location)`

*   `static <T> T load(URL location, ResourceBundle resources)`

*   `static <T> T load(URL location, ResourceBundle resources, BuilderFactory builderFactory)`

*   `static <T> T load(URL location, ResourceBundle resources, BuilderFactory builderFactory, Callback<Class<?>,Object> controllerFactory)`

*   `static <T> T load(URL location, ResourceBundle resources, BuilderFactory builderFactory, Callback<Class<?>,Object> controllerFactory, Charset charset)`

以下代码片段是使用`load()`方法的正确方式，因此您可以在 JavaFX 代码中获得控制器的引用:

```java
URL fxmlUrl = new URL("file:///C:/resources/fxml/test.fxml");

// Create an FXMLLoader object – a good start
FXMLLoader loader = new FXMLLoader();
loader.setLocation(fxmlUrl);

// Calling the no-args instance load() method - Correct
VBox root = loader.<VBox>load();

// loader.getController() will return the controller
Test controller = loader.getController();

```

现在，您已经有了这个示例应用程序的控制器。让我们修改 FXML 来匹配控制器。清单 26-6 显示了修改后的 FXML。它保存在*资源/fxml* 目录下的 sayhellowithcontroller.fxml 文件中。

```java
<?xml version="1.0" encoding="UTF-8"?>
<?language javascript?>

<?import javafx.scene.Scene?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Button?>

<VBox fx:controller="com.jdojo.fxml.SayHelloController" spacing="10" xmlns:fx="http://javafx.com/fxml">
        <Label fx:id="msgLbl" text="FXML is cool!" prefWidth="150"/>
        <Button fx:id="sayHelloBtn" text="Say Hello" onAction="#sayHello"/>
        <style>
                -fx-padding: 10;
                -fx-border-style: solid inside;
                -fx-border-width: 2;
                -fx-border-insets: 5;
                -fx-border-radius: 5;
                -fx-border-color: blue;
        </style>
</VBox>

Listing 26-6The Contents of the sayhellowithcontroller.fxml File

```

清单 26-7 中的程序是这个例子的 JavaFX 应用程序。代码与清单 26-4 中显示的代码非常相似。主要的区别是使用控制器的 FXML 文档。加载文档时，加载器调用控制器的`initialize()`方法。该方法打印一条消息，包括所使用的资源包引用的位置。当您单击按钮时，控制器的`sayHello()`方法被调用，该方法在`Label`中设置文本。请注意，`Label`引用是由 FXML 加载器自动注入控制器的。

```java
// SayHelloFXMLMain.java
package com.jdojo.fxml;

import java.io.IOException;
import java.net.URL;
import com.jdojo.util.ResourceUtil;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class SayHelloFXMLMain extends Application {
        public static void main(String[] args) {
                Application.launch(args);
        }

        @Override
        public void start(Stage stage) throws IOException {
                // Construct a URL for the FXML document
                     URL fxmlUrl = ResourceUtil.getResourceURL(
                         "fxml/sayhellowithcontroller.fxml");
                VBox root = FXMLLoader.<VBox>load(fxmlUrl);
                Scene scene = new Scene(root);
                stage.setScene(scene);
                stage.setTitle("Hello FXML");
                stage.show();
        }
}

Listing 26-7A JavaFX Application Class Using FXML and a Controller

```

## 在 FXML 中创建对象

使用 FXML 的主要目的是创建一个对象图。所有类的对象不是以相同的方式创建的。例如，一些类提供构造器来创建它们的对象，一些静态的`valueOf()`方法，和一些工厂方法。FXML 应该能够创建所有类的对象，或者至少应该给你一些控制权来决定如何创建这些对象。在下面几节中，我将讨论在 FXML 中创建对象的不同方法。

### 使用无参数构造器

使用无参数构造器在 FXML 中创建对象很容易。如果一个元素名是一个类名，它有一个无参数的构造器，那么这个元素将创建一个该类的对象。下面的元素创建了一个`VBox`对象，因为`VBox`类有一个无参数构造器:

```java
<VBox>
        ...
</VBox>

```

### 使用静态 valueOf()方法

有时候，不可变类提供了一个`valueOf()`方法来构造一个对象。如果`valueOf()`方法被声明为静态的，它可以接受单个`String`参数并返回一个对象。您可以使用`fx:value`属性通过方法创建一个对象。假设你有一个 Xxx 类，它包含一个静态的`valueOf(String s)`方法。以下是 Java 代码:

```java
Xxx x = Xxx.valueOf("a value");

```

在 FXML 中也可以这样做

```java
<Xxx fx:value="a value"/>

```

请注意，您已经声明了`valueOf()`方法应该能够接受一个`String`参数，该参数限定了该类别中的以下两个方法:

*   `public static Xxx valueOf(String arg)`

*   `public static Xxx valueOf(Object arg)`

以下元素创建了值为 100 和“Hello”的`Long`和`String`对象:

```java
<Long fx:value="100"/>
<String fx:value="Hello"/>

```

注意，`String`类包含一个创建空字符串的无参数构造器。如果您需要一个内容为空字符串的`String`对象，您仍然可以使用无参数构造器:

```java
<!-- Will create a String object with "" as the content -->
<String/>

```

当使用前面的元素时，不要忘记导入类`Long`和`String`，因为 FXML 不会自动从`java.lang`包中导入类。

值得注意的是，`fx:value`属性创建的对象类型是从`valueOf()`对象返回的对象类型，而不是元素的类类型。考虑下面这个`Yyy`类的方法声明:

```java
public static Zzz valueOf(String arg);

```

以下元素将创建什么类型的对象？

```java
<Yyy fx:value="hello"/>

```

如果你的答案是`Yyy`，那就错了。一般认为元素名是`Yyy`，所以创建了一个`Yyy`类型的对象。前面的元素与调用`Yyy.valueOf("Hello")`相同，后者返回一个`Zzz`类型的对象。因此，前面的元素创建了一个`Zzz`类型的对象，而不是`Yyy`类型的对象。尽管这种用例是可能的，但这是一种令人困惑的设计类的方式。通常，类`Xxx`中的`valueOf()`方法返回一个`Xxx`类型的对象。

### 使用工厂方法

有时，一个类提供工厂方法来创建它的对象。如果一个类包含一个返回对象的静态无参数方法，那么可以使用带有`fx:factory`属性的方法。下面的元素使用`LocalDate`类的`now()`工厂方法在 FXML 中创建一个`LocalDate`:

```java
<?import java.time.LocalDate?>
<LocalDate fx:factory="now"/>

```

有时，您需要在 FXML 中创建 JavaFX 集合。`FXCollections`类包含几个创建集合的工厂方法。下面的 FXML 片段创建了一个`ObservableList<String>`,将四个水果名称添加到列表中:

```java
<?import java.lang.String?>
<?import javafx.collections.FXCollections?>
<FXCollections fx:factory="observableArrayList">
        <String fx:value="Apple"/>
        <String fx:value="Banana"/>
        <String fx:value="Grape"/>
        <String fx:value="Orange"/>
</FXCollections>

```

清单 26-8 中的 FXML 是使用`fx:factory`属性创建`ObservableList`的一个例子。该列表用于设置一个`ComboBox`的`items`属性。列表中的值“橙色”被设置为默认值。`VBox`将显示一个`Label`和一个`ComboBox`，上面列出了四种水果的名称。

```java
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.ComboBox?>
<?import java.lang.String?>
<?import javafx.collections.FXCollections?>

<VBox xmlns:fx="http://javafx.com/fxml">
        <Label text="List of Fruits"/>
        <ComboBox>
            <items>
                <FXCollections fx:factory="observableArrayList">
                        <String fx:value="Apple"/>
                        <String fx:value="Banana"/>
                        <String fx:value="Grape"/>
                        <String fx:value="Orange"/>
                </FXCollections>
            </items>

            <value>
                <String fx:value="Orange"/>
            </value>
        </ComboBox>
</VBox>

Listing 26-8Creating a ComboBox, Populating It, and Selecting an Item

```

### 使用生成器

如果`FXMLLoader`不能创建一个类的对象，它会寻找一个可以创建该对象的构建器。构建器是`Builder`接口的一个实现。接口在`javafx.util`包中，它包含一个方法`build()`:

```java
public interface Builder<T> {
   public T build();
}

```

知道如何构建一个特定类型的对象。一个`Builder`与一个`BuilderFactory`一起使用，后者是同一个包中的另一个接口:

```java
public interface BuilderFactory {
    public Builder<?> getBuilder(Class<?> type);
}

```

`FXMLLoader`允许你使用一个`BuilderFactory`。当它不能使用所有其他方法创建一个类的对象时，它通过传递对象的类型作为方法参数来调用`BuilderFactory`的`getBuilder()`方法。如果`BuilderFactory`返回一个非空的`Builder`，加载程序将在`Builder`中设置正在创建的对象的所有属性。最后，它调用`Builder`的`build()`方法来获取对象。`FXMLLoader`类使用`JavaFXBuilderFactory`的一个实例作为默认的`BuilderFactory`。

`FXMLLoader`支持两种类型的`Builders`:

*   如果`Builder`实现了`Map`接口，则使用`put()`方法将对象属性传递给`Builder`。向`put()`方法传递属性的名称和值。

*   如果`Builder`没有实现`Map`接口，那么对于 FXML 中指定的所有属性，`Builder`应该包含基于 JavaBeans 约定的 getter 和 setter 方法。

考虑清单 26-9 中`Item`类的声明。默认情况下，FXML 不能创建一个`Item`对象，因为它没有无参数构造器。该类有两个属性，id 和 name。

```java
// Item.java
package com.jdojo.fxml;

public class Item {
        private Long id;
        private String name;

        public Item(Long id, String name) {
                this.id = id;
                this.name = name;
        }

        public Long getId() {
                return id;
        }

        public void setId(Long id) {
                this.id = id;
        }

        public String getName() {
                return name;
        }

        public void setName(String name) {
                this.name = name;
        }

        @Override
        public String toString() {
                return "id=" + id + ", name=" + name;
        }
}

Listing 26-9An Item Class That Does Not Have a no-args Constructor

```

清单 26-10 包含一个 FXML 文件`items.fxml`的内容。它用`Item`类的三个对象创建了一个`ArrayList`。如果您使用`FXMLLoader`加载这个文件，您会收到一个错误，提示加载程序无法实例化`Item`类。

```java
<!-- items.fxml -->
<?import com.jdojo.fxml.Item?>
<?import java.util.ArrayList?>
<ArrayList>
        <Item name="Kishori" id="100"/>
        <Item name="Ellen" id="200"/>
        <Item name="Kannan" id="300"/>
</ArrayList>

Listing 26-10FXML to Create a List of Item Objects

```

让我们创建一个`Builder`来构建一个`Item`类的对象。清单 26-11 中的`ItemBuilder`类是`Item`类的`Builder`。它声明了`id`和`name`实例变量。当`FXMLLoader`遇到这些属性时，加载程序将调用相应的 setters。setters 将值存储在实例变量中。当加载器需要对象时，它调用`build()`方法，该方法构建并返回一个`Item`对象。

```java
// ItemBuilder.java
package com.jdojo.fxml;

import javafx.util.Builder;

public class ItemBuilder implements Builder<Item> {
        private Long id;
        private String name;

        public Long getId() {
                return id;
        }

        public String getName() {
                return name;
        }

        public void setId(Long id) {
                this.id = id;
        }

        public void setName(String name) {
                this.name = name;
        }

        @Override
        public Item build() {
                return new Item(id, name);
        }

}

Listing 26-11A Builder for the Item Class That Uses Property Setters to Build an Object

```

现在，您需要为`Item`类型创建一个`BuilderFactory`。清单 26-12 中显示的`ItemBuilderFactory`类实现了`BuilderFactory`接口。当`getBuilder()`被传递给`Item`类型时，它返回一个`ItemBuilder`对象。否则，它返回默认的 JavaFX builder。

```java
// ItemBuilderFactory.java
package com.jdojo.fxml;

import javafx.util.Builder;
import javafx.util.BuilderFactory;
import javafx.fxml.JavaFXBuilderFactory;

public class ItemBuilderFactory implements BuilderFactory {
        private final JavaFXBuilderFactory fxFactory =
              new JavaFXBuilderFactory();

        @Override

        public Builder<?> getBuilder(Class<?> type) {
                // You supply a Builder only for Item type
                if (type == Item.class) {
                        return new ItemBuilder();
                }

                // Let the default Builder do the magic
                return fxFactory.getBuilder(type);
        }
}

Listing 26-12A BuilderFactory to Get a Builder for the Item Type

```

清单 26-13 和 26-14 有`Item`类型的`Builder`和`BuilderFactory`实现的代码。这次，`Builder`通过扩展`AbstractMap`类实现了`Map`接口。它覆盖了`put()`方法来读取传入的属性及其值。`entrySet()`方法需要被覆盖，因为它在`AbstractMap`类中被定义为抽象的。您没有任何有用的实现。你只是抛出一个运行时异常。`build()`方法创建并返回一个`Item`类型的对象。`BuilderFactory`实现类似于清单 26-12 中的实现，除了它返回一个`ItemBuilderMap`作为`Item`类型的`Builder`。

```java
// ItemBuilderFactoryMap.java

package com.jdojo.fxml;

import javafx.fxml.JavaFXBuilderFactory;
import javafx.util.Builder;
import javafx.util.BuilderFactory;

public class ItemBuilderFactoryMap implements BuilderFactory {
        private final JavaFXBuilderFactory fxFactory =
               new JavaFXBuilderFactory();

        @Override
        public Builder<?> getBuilder(Class<?> type) {
                if (type == Item.class) {
                    return new ItemBuilderMap();
                }
                return fxFactory.getBuilder(type);
        }
}

Listing 26-14Another BuilderFactory to Get a Builder for the Item Type

```

```java
// ItemBuilderMap.java
package com.jdojo.fxml;

import java.util.AbstractMap;
import java.util.Map;
import java.util.Set;
import javafx.util.Builder;

public class ItemBuilderMap extends AbstractMap<String, Object> implements Builder<Item> {
        private String name;
        private Long id;

        @Override

        public Object put(String key, Object value) {
                if ("name".equals(key)) {
                    this.name = (String)value;
                } else if ("id".equals(key)) {
                    this.id = Long.valueOf((String)value);
                } else {
                    throw new IllegalArgumentException(
                               "Unknown Item property: " + key);
                }

                return null;
        }

        @Override
        public Set<Map.Entry<String, Object>> entrySet() {
                throw new UnsupportedOperationException();
        }

        @Override
        public Item build() {
                return new Item(id, name);
        }

}

Listing 26-13A Builder for the Item Class That Implements the Map Interface

```

让我们为`Item`类测试两个`Builder`。清单 26-15 中的程序对`Item`类使用了两个`Builder`。它从`items.fxml`文件中加载`Item`列表，假设该文件位于`resources/fxml`目录中。

```java
// BuilderTest.java

package com.jdojo.fxml;

import java.io.IOException;
import java.net.URL;
import com.jdojo.util.ResourceUtil;
import java.util.ArrayList;
import javafx.fxml.FXMLLoader;
import javafx.util.BuilderFactory;

public class BuilderTest {
        public static void main(String[] args) throws IOException {
            // Use the Builder with property getter and setter
            loadItems(new ItemBuilderFactory());

            // Use the Builder with Map
            loadItems(new ItemBuilderFactoryMap());
        }

        public static void
           loadItems(BuilderFactory builderFactory) throws IOException {
                URL fxmlUrl = ResourceUtil.getResourceURL("fxml/items.fxml");

            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(fxmlUrl);
            loader.setBuilderFactory(builderFactory);
            ArrayList items = loader.<ArrayList>load();
            System.out.println("List:" + items);
        }
}

List:[id=100, name=Kishori, id=200, name=Ellen, id=300, name=Kannan]
List:[id=100, name=Kishori, id=200, name=Ellen, id=300, name=Kannan]

Listing 26-15Using Builders to Instantiate Item Objects in FXML

```

Tip

您提供给`FXMLLoader`的`BuilderFactory`将替换默认的`BuilderFactory`。您需要确保您的`BuilderFactory`为您的定制类型返回一个特定的`Builder`，为其余的类型返回默认的`Builder`。目前，`FXMLLoader`不允许使用一个以上的`BuilderFactory`。

## 在 FXML 中创建可重用对象

有时，您需要创建不直接属于对象图的对象。但是，它们可能在 FXML 文档中的其他地方使用。例如，您可能想创建一个`Insets`或`Color`并在几个地方重用它们。使用`ToggleGroup`是一个典型的用例。一个`ToggleGroup`被创建一次，并与几个`RadioButton`对象一起使用。

您可以使用`<fx:define>`块在 FXML 中创建一个对象，而不使其成为对象组的一部分。您可以通过其他元素属性值中的`fx:id`来引用在`<fx:define>`块中创建的对象。属性值必须以美元符号($)为前缀:

```java
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Button?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.ToggleGroup?>
<?import javafx.scene.control.RadioButton?>

<VBox fx:controller="com.jdojo.fxml.Test" xmlns:fx="http://javafx.com/fxml">
    <fx:define>
        <Insets fx:id="margin" top="5.0" right="5.0"
                   bottom="5.0" left="5.0"/>
        <ToggleGroup fx:id="genderGroup"/>
    </fx:define>
    <Label text="Gender" VBox.margin="$margin"/>
    <RadioButton text="Male" toggleGroup="$genderGroup"/>
    <RadioButton text="Female" toggleGroup="$genderGroup"/>
    <RadioButton text="Unknown" toggleGroup="$genderGroup" selected="true"/>
    <Button text="Close" VBox.margin="$margin"/>
</VBox>

```

前面的 FXML 在一个`<fx:define>`块中创建了两个对象，一个`Insets`和一个`ToggleGroup`。他们被赋予了`"margin"`的`fx:id`和`"genderGroup"`。通过`"$margin"`和`"$genderGroup"`在作为对象图一部分的控件中引用它们。

Tip

如果属性的值以$符号开始，它被认为是对对象的引用。如果要使用前导$符号作为值的一部分，请用反斜杠(`"\$hello"`)对其进行转义。

## 在属性中指定位置

以@符号开头的属性值表示位置。如果@符号后跟一个正斜杠(@/)，则该位置被认为是相对于`CLASSPATH`的。如果@符号后面没有正斜杠，则该位置被认为是相对于正在处理的 FXML 文件的位置。

在下面的 FXML 中，将根据包含元素的 FXML 文件的位置来解析图像 URL:

```java
<ImageView>
        <Image url="@resources/picture/ksharan.jpg"/>
</ImageView>

```

在下面的 FXML 中，图像 URL 将相对于`CLASSPATH`进行解析:

```java
<ImageView>
        <Image url="@/resources/picture/ksharan.jpg"/>
</ImageView>

```

如果您想使用前导@符号作为属性值的一部分，请用反斜杠`("\@not-a-location"`对其进行转义。

## 使用资源包

在 FXML 中使用`ResourceBundle`比在 Java 代码中使用要容易得多。在属性值中指定来自`ResourceBundle`的键使用默认`Locale`的相应值。如果一个属性值以%符号开头，它将被视为资源包中的键名。运行时，属性值将来自`FXMLLoader`中指定的`ResourceBundle`。如果您想在属性值中使用前导%符号，请用反斜杠将其转义(例如，`"\%hello"`)。

考虑清单 26-16 中的 FXML 内容。它使用`"%greetingText"`作为`Label`的`text`属性的值。属性值以%符号开始。`FXMLLoader`将在`ResourceBundle`中查找`"` `greetingText` `"`的值，并将其用于`text`属性。这一切都是为你做的，甚至不用写一行代码！

```java
<?import javafx.scene.control.Label?>
<Label text="%greetingText"/>

Listing 26-16The Contents of the greetings.fxml File

```

清单 26-17 和 26-18 有`ResourceBundle`文件的内容:一个默认`Locale`名为`greetings.properties`，一个印度`Locale`名为`greetings_hi.properties`。文件名中的后缀`_hi`表示印度语 Hindi。

```java
# The Indian greeting

greetingText = Namaste

Listing 26-18The Contents of the greetings_hi.properties File

```

```java
# The default greeting
greetingText = Hello

Listing 26-17The Contents of the greetings.properties File

```

清单 26-19 中的程序使用了带有`FXMLLoader`的`ResourceBundle`。`ResourceBundle`是从`CLASSPATH`的`resources/resourcebundles`目录中加载的。FXML 文件从类别`ResourceUtil`中引用的文件夹`resources/fxml/greetings.fxml`中加载。该程序从 FXML 文件中加载了两次`Label`:一次是默认的地区 US，另一次是将默认的`Locale`改为 India Hindi。两个`Label`都显示在`VBox`中，如图 26-2 所示。

![img/336502_2_En_26_Fig2_HTML.png](img/336502_2_En_26_Fig2_HTML.png)

图 26-2

使用资源包填充文本属性的标签

```java
// ResourceBundleTest.java
package com.jdojo.fxml;

import java.io.IOException;
import java.net.URL;
import com.jdojo.util.ResourceUtil;
import java.util.Locale;
import java.util.ResourceBundle;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;

import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class ResourceBundleTest extends Application {
        public static void main(String[] args) {
                Application.launch(args);
        }

        @Override
        public void start(Stage stage) throws IOException {
                URL fxmlUrl =
                    ResourceUtil.getResourceURL("fxml/greetings.fxml");

            // Create a ResourceBundle to use in FXMLLoader
            String resourcePath = "resources/resourcebundles/greetings";
            ResourceBundle resourceBundle =
                    ResourceBundle.getBundle(resourcePath);

            // Load the Label for default Locale
            Label defaultGreetingLbl =
                    FXMLLoader.<Label>load(fxmlUrl, resourceBundle);

            // Change the default Locale and load the Label again
            Locale.setDefault(new Locale("hi", "in"));

            // We need to recreate the ResourceBundler to pick up the
                // new default Locale

            resourceBundle = ResourceBundle.getBundle(resourcePath);

            Label indianGreetingLbl =
                    FXMLLoader.<Label>load(fxmlUrl, resourceBundle);

            // Add both Labels to a Vbox
            VBox root =
                    new VBox(5, defaultGreetingLbl, indianGreetingLbl);
            Scene scene = new Scene(root);
            stage.setScene(scene);
            stage.setTitle("Using a ResourceBundle in FXML");
            stage.show();
        }
}

Listing 26-19Using a Resource Bundle with the FXMLLoader

```

## 包括 FXML 文件

使用`<fx:include>`元素，一个 FXML 文档可以包含另一个 FXML 文档。嵌套文档生成的对象图包含在嵌套文档在包含文档中出现的位置。`<fx:include>`元素接受一个`source`属性，该属性的值是嵌套文档的路径:

```java
<fx:include source="nested_document_path"/>

```

如果嵌套文档路径以正斜杠开头，则该路径相对于`CLASSPATH`被解析。否则，它相对于包含文档的路径进行解析。

`<fx:include>`元素可以有`fx:id`属性和所有可用于被包含对象的属性。包含文档中指定的属性会覆盖包含文档中的相应属性。例如，如果您包含一个 FXML 文档，它会创建一个`Button`，那么您可以在包含文档和被包含文档中指定`text`属性。加载包含文档时，将使用包含文档的`text`属性。

FXML 文档可以选择使用根元素的`fx:controller`属性指定一个控制器。规则是每个 FXML 文档最多可以有一个控制器。嵌套文档时，每个文档都可以有自己的控制器。`FXMLLoader`允许您将嵌套的控制器引用注入到主文档的控制器中。您需要遵循命名约定来注入嵌套控制器。主文档的控制器应该有一个可访问的实例变量，其名称为

```java
Instance variable name = "fx:id of the fx:include element" + "Controller"

```

如果`<fx:include>`元素的`fx:id`是“xxx”，那么实例变量名应该是`xxxController`。

考虑清单 26-20 和 26-21 中显示的两个 FXML 文档。`closebutton.fxml`文件创建一个`Button`，将其文本属性设置为`Close`，并附加一个动作事件处理程序。事件处理程序使用 JavaScript 语言。它关闭包含它的窗口。

假设两个文件在同一个目录中，`maindoc.fxml`包括`closebutton.fxml`。它为`<fx:include>`元素指定了`text`和`fx:id`属性。注意，包含的 FXML 指定“Close”作为测试属性，`maindoc.fxml`覆盖了它并将其设置为“Close”。

```java
<!-- maindoc.fxml -->
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Label?>

<VBox fx:controller="com.jdojo.fxml.MainDocController" xmlns:fx="http://javafx.com/fxml">
        <Label text="Testing fx:include"/>

        <!-- Override the text property of the included Button -->
        <fx:include source="closebutton.fxml" fx:id="includedCloseBtn"
               text="Hide"/>
</VBox>

Listing 26-21An FXML Document Using an <fx:include> Element

```

```java
<!-- closebutton.fxml -->
<?language javascript?>
<?import javafx.scene.control.Button?>

<Button fx:controller="com.jdojo.fxml.CloseBtnController"
        text="Close"
        fx:id="closeBtn"
        onAction="#closeWindow"
        xmlns:fx="http://javafx.com/fxml">
</Button>

Listing 26-20An FXML Document That Creates a Close Button to Close the Containing Window

```

两个 FXML 文档都指定了清单 26-22 和 26-23 中列出的控制器。注意，主文档的控制器声明了两个实例变量:一个将引用被包含的`Button`，另一个将引用被包含文档的控制器。请注意，`Button`的引用也将包含在嵌套文档的控制器中。

```java
// MainDocController.java

package com.jdojo.fxml;

import javafx.fxml.FXML;
import javafx.scene.control.Button;

public class MainDocController {
        @FXML
        private Button includedCloseBtn;

        @FXML
        private CloseBtnController includedCloseBtnController;

        @FXML
        public void initialize() {
                System.out.println("MainDocController.initialize()");
                // You can use the nested controller here
        }

}

Listing 26-23The Controller Class for the Main Document

```

```java
// CloseBtnController.java

package com.jdojo.fxml;

import javafx.fxml.FXML;
import javafx.scene.control.Button;

public class CloseBtnController {
        @FXML
        private Button closeBtn;

        @FXML
        public void initialize() {
                System.out.println("CloseBtnController.initialize()");
        }

}

Listing 26-22The ControllerClass for the FXML Defining the Close Button

```

清单 26-24 中的程序加载`maindoc.fxml`并将加载的`VBox`添加到场景中。它显示一个窗口，带有`closebutton.fxml`文件中的*隐藏*按钮。点击`Hide`按钮将关闭窗口。

```java
// FxIncludeTest.java
package com.jdojo.fxml;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
 import com.jdojo.util.ResourceUtil;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class FxIncludeTest  extends Application {
        public static void main(String[] args) {
                Application.launch(args);
        }

        @Override

        public void
           start(Stage stage) throws MalformedURLException, IOException {
                     URL fxmlUrl = ResourceUtil.getResourceURL(
                         "fxml/maindoc.fxml");

                FXMLLoader loader = new FXMLLoader();
                loader.setLocation(fxmlUrl);
                VBox root = loader.<VBox>load();
                Scene scene = new Scene(root);
                stage.setScene(scene);
                stage.setTitle("Nesting Documents in FXML");
                stage.show();
        }
}

Listing 26-24Loading and Using a Nested FXML Document

```

## 使用常量

类、接口和枚举可以定义常量，这些常量是静态的最终变量。您可以使用`fx:constant`属性来引用这些常量。属性值是常量的名称。元素的名称是包含该常量的类型的名称。例如，对于`Long.MAX_VALUE`，您可以使用以下元素:

```java
<Long fx:constant="MAX_VALUE"/>

```

注意，所有枚举常量都属于这个类别，可以使用`fx:constant`属性访问它们。以下元素访问`Pos.CENTER`枚举常量:

```java
<Pos fx:constant="CENTER"/>

```

下面的 FXML 内容访问来自`Integer`和`Long`类以及`Pos`枚举的常量。它将`VBox`的`alignment`属性设置为`Pos.CENTER`:

```java
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.TextField?>
<?import java.lang.Integer?>
<?import java.lang.Long?>
<?import javafx.scene.text.FontWeight?>
<?import javafx.geometry.Pos?>

<VBox xmlns:fx="http://javafx.com/fxml">
        <fx:define>
                <Integer fx:constant="MAX_VALUE" fx:id="minInt"/>
        </fx:define>
        <alignment><Pos fx:constant="CENTER"/></alignment>
        <TextField text="$minInt"/>
        <TextField>
                <text><Long fx:constant="MIN_VALUE"/></text>
        </TextField>

</VBox>

```

## 引用另一个元素

您可以使用`<fx:reference>`元素引用文档中的另一个元素。`fx:id`属性指定了引用元素的`fx:id`:

```java
<fx:reference source="fx:id of the source element"/>

```

下面的 FXML 内容使用一个`<fx:reference>`元素来引用一个`Image`:

```java
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<VBox xmlns:fx="http://javafx.com/fxml">
        <fx:define>
            <Image url="resources/picture/ksharan.jpg" fx:id="myImg"/>
        </fx:define>
        <ImageView>
             <image>
                <fx:reference source="myImg"/>
            </image>
        </ImageView>

</VBox>

```

请注意，您也可以使用变量解引用方法重写前面的 FXML 内容，如下所示:

```java
<VBox xmlns:fx="http://javafx.com/fxml">
        <fx:define>
            <Image url="resources/picture/ksharan.jpg" fx:id="myImg"/>
        </fx:define>
        <ImageView image="$myImg"/>
</VBox>

```

## 复制元素

有时，您想要复制一个元素。在这个上下文中，复制是通过复制源对象的属性来创建新对象。您可以使用`<fx:copy>`元素来实现:

```java
<fx:copy source="fx:id of the source object" />

```

若要复制对象，该类必须提供复制构造器。复制构造器接受同一个类的对象。假设您有一个包含复制构造器的`Item`类:

```java
public class Item {
        private Long id;
        private String name;

        public Item() {
        }

        // The copy constructor
        public Item(Item source) {
                this.id = source.id + 100;
                this.name = source.name + " (Copied)";
        }
        ...
}

```

下面的 FXML 文档在`<fx:define>`块中创建了一个`Item`对象。它多次复制`Item`对象，并将它们添加到`ComboBox`的项目列表中。注意，使用一个`<fx:reference>`元素将源`Item`本身添加到条目列表中:

```java
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.ComboBox?>
<?import javafx.collections.FXCollections?>
<?import com.jdojo.fxml.Item?>

<VBox xmlns:fx="http://javafx.com/fxml">
        <fx:define>
                <Item name="Kishori" id="100" fx:id="myItem"/>
        </fx:define>
        <ComboBox value="$myItem">
            <items>
                <FXCollections fx:factory="observableArrayList">
                    <fx:reference source="myItem"/>
                    <fx:copy source="myItem" />
                    <fx:copy source="myItem" />
                    <fx:copy source="myItem" />
                    <fx:copy source="myItem" />
                </FXCollections>
            </items>
        </ComboBox>

</VBox>

```

## FXML 中的绑定属性

FXML 支持简单的属性绑定。您需要使用属性的属性将其绑定到另一个元素或文档变量的属性。属性值以$符号开始，后面跟着一对花括号。以下 FXML 内容创建了一个带有两个`TextField`的`VBox`。`mirrorText`字段的`text`属性被绑定到`mainText`字段的文本属性:

```java
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.TextField?>

<VBox xmlns:fx="http://javafx.com/fxml">
        <TextField fx:id="mainText" text="Hello"/>
        <TextField fx:id="mirrorText" text="${mainText.text}" disable="true"/>
</VBox>

```

## 创建自定义控件

您可以使用 FXML 创建自定义控件。让我们创建一个带有两个`Label`、一个`TextField`、一个`PasswordField`和两个`Button`的登录表单。注意，根元素是一个`<fx:root>`。元素创建了一个对之前创建的元素的引用。使用`setRoot()`方法在`FXMLLoader`中设置`<fx:root>`元素的值。属性指定了将要注入的根的类型。

```java
<!-- login.fxml -->
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.PasswordField?>

<fx:root type="javafx.scene.layout.GridPane"
              xmlns:fx="http://javafx.com/fxml">
        <Label text="User Id:" GridPane.rowIndex="0"
               GridPane.columnIndex="0"/>
        <TextField fx:id="userId" GridPane.rowIndex="0"
               GridPane.columnIndex="1"/>
        <Label text="Password:" GridPane.rowIndex="1"
               GridPane.columnIndex="0"/>
        <PasswordField fx:id="pwd" GridPane.rowIndex="1"
               GridPane.columnIndex="1"/>
        <Button fx:id="okBtn" text="OK" onAction="#okClicked"
               GridPane.rowIndex="0" GridPane.columnIndex="2"/>
        <Button fx:id="cancelBtn" text="Cancel" onAction="#cancelClicked"
               GridPane.rowIndex="1" GridPane.columnIndex="2"/>
</fx:root>

Listing 26-25The FXML Contents for a Custom Login Form

```

清单 26-26 中的类表示自定义控件的 JavaFX 部分。您将创建一个`LogInControl`类的对象，并将其用作任何其他标准控件。该类也用作`login.fxml`的控制器。在构造器中，类加载 FXML 内容。在加载内容之前，它将自己设置为`FXMLLoader`中的根和控制器。实例变量允许在类中注入`userId`和`pwd`控件。当点击`Button`时，您只需在控制台上打印一条消息。如果您想在实际应用程序中使用这个控件，还需要做更多的工作。当点击 *OK* 和 *Cancel* 按钮时，您需要为用户提供一种挂钩事件通知的方式。

```java
// LoginControl.java
package com.jdojo.fxml;

import java.io.IOException;
import java.net.URL;
import com.jdojo.util.ResourceUtil;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;

public class LoginControl extends GridPane {
        @FXML
        private TextField userId;

        @FXML
        private PasswordField pwd;

        public LoginControl() {
                // Load the FXML
                     URL fxmlUrl =
                         ResourceUtil.getResourceURL("fxml/login.fxml");
                FXMLLoader loader = new FXMLLoader();
                loader.setLocation(fxmlUrl);
                loader.setRoot(this);
                loader.setController(this);
                try {
                        loader.load();
                }
                catch (IOException exception) {
                   throw new RuntimeException(exception);
                }
        }

        @FXML
        private void initialize() {
                // Do some work
        }

        @FXML
        private void okClicked() {
                System.out.println("Ok clicked");
        }

        @FXML
        private void cancelClicked() {
            System.out.println("Cancel clicked");
        }

        public String getUserId() {
                return userId.getText();
        }

        public String getPassword() {
                return pwd.getText();
        }
}

Listing 26-26A Class Implementing the Custom Control

```

清单 26-27 中的程序展示了如何使用自定义控件。使用自定义控件就像创建 Java 对象一样简单。自定义控件扩展了`GridPane`；所以可以作为一个`GridPane`。在 FXML 中使用控件与使用其他控件没有什么不同。该控件提供了一个无参数的构造器，这将允许通过使用一个类名为`<LoginControl>`的元素在 FXML 中创建它。

```java
// LoginTest.java
package com.jdojo.fxml;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class LoginTest extends Application {
        public static void main(String[] args) {
                Application.launch(args);
        }

        @Override
        public void start(Stage stage) {
                // Create the Login custom control
                GridPane root = new LoginControl();
                Scene scene = new Scene(root);
                stage.setScene(scene);
                stage.setTitle("Using FXMl Custom Control");
                stage.show();
        }

}

Listing 26-27Using the Custom Control

```

## 摘要

FXML 是一种基于 XML 的语言，用于为 JavaFX 应用程序构建用户界面。您可以使用 FXML 构建整个场景或场景的一部分。FXML 允许应用程序开发人员将构建 UI 的逻辑与业务逻辑分开。如果应用程序的 UI 部分发生了变化，您不需要重新编译 JavaFX 代码:使用文本编辑器更改 FXML 并重新运行应用程序。您仍然使用 JavaFX 通过 Java 语言编写业务逻辑。FXML 文档是 XML 文档。

在 JavaFX 应用程序中使用 FXML 构建场景图是很常见的。然而，FXML 的使用并不仅限于构建场景图。它可以构建 Java 对象的分层对象图。事实上，它只能用来创建一个对象，比如一个`Person`类的对象。

FXML 文档只是一个文本文件。通常，文件名有一个`.fxml`扩展名(例如`hello.fxml`)。您可以使用任何文本编辑器来编辑 FXML 文档。胶子公司提供了一个名为*场景构建器*的开源可视化编辑器，用于编辑 FXML 文档。场景生成器也可以集成到一些 ide 中。

FXML 允许您使用无参数构造器、`valueOf()`方法、工厂方法和构建器来创建对象。

有时，您需要创建不直接属于对象图的对象。但是，它们可能在 FXML 文档中的其他地方使用。您可以使用`<fx:define>`块在 FXML 中创建一个对象，而不使其成为对象组的一部分。您可以通过其他元素属性值中的`fx:id`来引用在`<fx:define>`块中创建的对象。属性值必须以美元符号($)为前缀。

FXML 允许您通过指定资源的位置来引用资源。以@符号开头的属性值表示位置。如果@符号后面跟一个正斜杠(@/)，则该位置被认为是相对于`CLASSPATH`的。如果@符号后面没有正斜杠，则该位置被认为是相对于正在处理的 FXML 文件的位置。

在 FXML 中使用`ResourceBundle`比在 Java 代码中使用要容易得多。在属性值中指定来自`ResourceBundle`的键使用默认`Locale`的相应值。如果一个属性值以%符号开头，它将被视为资源包中的键名。运行时，属性值将来自`FXMLLoader`中指定的`ResourceBundle`。如果您想在属性值中使用前导%符号，请用反斜杠将其转义(例如，`"\%hello"`)。

使用`<fx:include>`元素，一个 FXML 文档可以包含另一个 FXML 文档。嵌套文档生成的对象图包含在嵌套文档在包含文档中出现的位置。

类、接口和枚举可以定义常量，这些常量是静态的最终变量。您可以使用`fx:constant`属性来引用这些常量。属性值是常量的名称。元素的名称是包含该常量的类型的名称。例如，对于`Long.MAX_VALUE`，可以使用元素`<Long fx:constant="MAX_VALUE"/>`。

您可以使用`<fx:reference>`元素引用文档中的另一个元素。属性`fx:id`指定了被引用元素的`fx:id`。您可以使用`<fx:copy>`元素复制一个元素。它将通过复制源对象的属性来创建一个新对象。

FXML 支持简单的属性绑定。您需要使用属性的属性将其绑定到另一个元素或文档变量的属性。属性值以$符号开始，后面跟着一对花括号。您可以使用 FXML 创建自定义控件。

下一章将讨论 JavaFX 中的打印 API，它允许您在 JavaFX 应用程序中配置打印机和打印节点。*