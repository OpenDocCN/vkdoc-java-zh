# 三、属性和绑定

> The sky is full of vigor and perseverance. Correspondingly, superior people keep their vitality constantly. -I ching

在第 1 和 2 章中，我们向您介绍了 JavaFX 9 平台，它是 Oracle JDK 9 的一部分。您可以用自己喜欢的 IDE 来设置开发环境:Eclipse、NetBeans 或 IntelliJ IDEA。您编写并运行了您的第一个 JavaFX GUI 程序。您学习了 JavaFX 的基本构建块:类`Stage`和`Scene`，以及进入`Scene`的`Node`。毫无疑问，您已经注意到使用用户定义的模型类来表示应用程序状态，并通过属性和绑定将该状态传递给 UI。

在本章中，我们将向您介绍 JavaFX 属性和绑定框架。在回顾了一点历史并展示了一个展示 JavaFX `Property`的各种使用方式的激励性示例之后，我们将介绍框架的关键概念:`Observable`、`ObservableValue`、`WritableValue`、`ReadOnlyProperty`、`Property`和`Binding`。我们向您展示了框架的这些基本接口所提供的功能。然后，我们向您展示如何将`Property`对象绑定在一起，如何利用属性和其他绑定来构建`Binding`对象——使用`Bindings`实用程序类中的工厂方法、fluent 接口 API，或者通过直接扩展实现`Binding`接口的抽象类来降低级别——以及如何使用它们来轻松地将程序一部分中的更改传播到程序的其他部分，而无需过多的编码。然后我们介绍 JavaFX Beans 命名约定，它是原始 JavaBeans 命名约定的扩展，使将数据组织到封装的组件中变得有条不紊。我们通过展示如何将旧式 JavaBeans 属性改编成 JavaFX 属性来结束本章。

因为 JavaFX 属性和绑定框架是 JavaFX 平台的非可视部分，所以本章中的示例程序本质上也是非可视的。我们处理`Boolean`、`Integer`、`Long`、`Float`、`Double`、`String`和`Object`类型属性和绑定，因为这些是 JavaFX 绑定框架专门处理的类型。您的 GUI 构建乐趣将在下一章和后续章节中继续。

## JavaFX 绑定的先驱

在 Java 生命的早期，人们就认识到需要将 Java 组件的属性直接暴露给客户机代码，允许它们观察和操作这些属性，并在它们的值改变时采取行动。Java 1.1 中的 JavaBeans 框架通过现在熟悉的 getter 和 setter 约定提供了对属性的支持。它还通过其`PropertyChangeEvent`和`PropertyChangeListener`机制支持属性变化的传播。尽管 JavaBeans 框架在许多 Swing 应用程序中使用，但它的使用相当麻烦，需要相当多的样板代码。几年来，人们创建了几个高级数据绑定框架，取得了不同程度的成功。JavaFX 属性和绑定框架中 JavaBeans 的继承主要在于定义 JavaFX 组件时的 JavaFX Beans getter、setter 和属性 getter 命名约定。在讲述了 JavaFX 属性和绑定框架的关键概念和接口之后，我们将在本章的后面讨论 JavaFX Beans getter、setter 和属性 getter 命名约定。

JavaFX 属性和绑定框架的另一个继承来自 JavaFX Script 语言，它是 JavaFX 1.x 平台的一部分。尽管 JavaFX 平台不赞成使用 JavaFX Script 语言，而是支持基于 Java 的 API，但这种转变的目标之一是保留 JavaFX Script 的`bind`关键字的大部分功能，它的表达能力让许多 JavaFX 爱好者感到高兴。例如，JavaFX 脚本支持绑定到复杂表达式:

```java
var a = 1;
var b = 10;
var m = 4;
def c = bind for (x in [a..b] where x < m) { x * x };

```

每当`a`、`b`或`m`的值改变时，该代码将自动重新计算`c`的值。

尽管 JavaFX 属性和绑定框架不支持 JavaFX 脚本的所有绑定结构，但它支持许多有用表达式的绑定。在介绍了框架的关键概念和接口之后，我们将更多地讨论如何构建复合绑定表达式。

## 激励人心的例子

让我们从清单 3-1 中的一个例子开始，它通过使用几个`SimpleIntegerProperty`类的实例展示了`Property`接口的功能。

```java
import javafx.beans.InvalidationListener;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;

public class MotivatingExample {
    private static IntegerProperty intProperty;

    public static void main(String[] args) {
        createProperty();
        addAndRemoveInvalidationListener();
        addAndRemoveChangeListener();
        bindAndUnbindOnePropertyToAnother();
    }

    private static void createProperty() {
        System.out.println();
        intProperty = new SimpleIntegerProperty(1024);
        System.out.println("intProperty = " + intProperty);
        System.out.println("intProperty.get() = " + intProperty.get());
        System.out.println("intProperty.getValue() = " + intProperty.getValue().intValue());
    }

    private static void addAndRemoveInvalidationListener() {
        System.out.println();
        final InvalidationListener invalidationListener = observable ->
            System.out.println("The observable has been invalidated: " + observable + ".");

        intProperty.addListener(invalidationListener);
        System.out.println("Added invalidation listener.");

        System.out.println("Calling intProperty.set(2048).");
        intProperty.set(2048);

        System.out.println("Calling intProperty.setValue(3072).");
        intProperty.setValue(Integer.valueOf(3072));

        intProperty.removeListener(invalidationListener);
        System.out.println("Removed invalidation listener.");

        System.out.println("Calling intProperty.set(4096).");
        intProperty.set(4096);
    }

    private static void addAndRemoveChangeListener() {
        System.out.println();
        final ChangeListener changeListener = (ObservableValue observableValue, Object oldValue, Object newValue) ->
            System.out.println("The observableValue has changed: oldValue = " + oldValue + ", newValue = " + newValue);
        intProperty.addListener(changeListener);
        System.out.println("Added change listener.");

        System.out.println("Calling intProperty.set(5120).");
        intProperty.set(5120);

        intProperty.removeListener(changeListener);
        System.out.println("Removed change listener.");

        System.out.println("Calling intProperty.set(6144).");
        intProperty.set(6144);
    }

    private static void bindAndUnbindOnePropertyToAnother() {
        System.out.println();
        IntegerProperty otherProperty = new SimpleIntegerProperty(0);
        System.out.println("otherProperty.get() = " + otherProperty.get());

        System.out.println("Binding otherProperty to intProperty.");
        otherProperty.bind(intProperty);
        System.out.println("otherProperty.get() = " + otherProperty.get());

        System.out.println("Calling intProperty.set(7168).");
        intProperty.set(7168);
        System.out.println("otherProperty.get() = " + otherProperty.get());

        System.out.println("Unbinding otherProperty from intProperty.");
        otherProperty.unbind();
        System.out.println("otherProperty.get() = " + otherProperty.get());

        System.out.println("Calling intProperty.set(8192).");
        intProperty.set(8192);
        System.out.println("otherProperty.get() = " + otherProperty.get());
    }
}

Listing 3-1.
MotivatingExample.java

```

在这个例子中，我们创建了一个名为`intProperty`的`SimpleIntegerProperty`对象，初始值为`1024`。然后我们通过一系列不同的整数更新它的值，同时我们添加然后移除一个`InvalidationListener`，添加然后移除一个`ChangeListener`，最后，创建另一个名为`otherProperty`的`SimpleIntegerProperty`，将其绑定到，然后从`intProperty`解除绑定。我们利用 Java 8 lambda 语法来定义我们的侦听器。示例程序使用了大量的`println`调用来展示程序内部发生的事情。

当我们运行清单 3-1 中的程序时，以下输出被打印到控制台:

```java
intProperty = IntegerProperty [value: 1024]
intProperty.get() = 1024
intProperty.getValue() = 1024

Added invalidation listener.
Calling intProperty.set(2048).
The observable has been invalidated: IntegerProperty [value: 2048].
Calling intProperty.setValue(3072).
The observable has been invalidated: IntegerProperty [value: 3072].
Removed invalidation listener.
Calling intProperty.set(4096).

Added change listener.
Calling intProperty.set(5120).
The observableValue has changed: oldValue = 4096, newValue = 5120
Removed change listener.
Calling intProperty.set(6144).

otherProperty.get() = 0
Binding otherProperty to intProperty.
otherProperty.get() = 6144
Calling intProperty.set(7168).
otherProperty.get() = 7168
Unbinding otherProperty from intProperty.
otherProperty.get() = 7168
Calling intProperty.set(8192).
otherProperty.get() = 7168

```

通过将输出行与程序源代码相关联(或者通过在您喜欢的 IDE 的调试器中单步调试代码)，我们可以得出以下结论。

*   一个`SimpleIntegerProperty`对象，比如`intProperty`和`otherProperty`持有一个`int`值。该值可以用`get()`、`set()`、`getValue()`和`setValue()`方法操作。`get()`和`set()`方法使用原语`int`类型执行它们的操作。`getValue()`和`setValue()`方法使用`Integer`包装器类型。
*   您可以在`intProperty`中添加和删除`InvalidationListener`对象。
*   您可以在`intProperty`中添加和删除`ChangeListener`对象。
*   另一个`Property`对象如`otherProperty`可以将自己绑定到`intProperty`。当这种情况发生时，`otherProperty`接收`intProperty`的值。
*   当在`intProperty`上设置一个新值时，连接到它的任何对象都会得到通知。如果对象被移除，则不会发送通知。
*   当被通知时，`InvalidationListener`对象仅被告知哪个对象正在发出通知，并且该对象仅被称为`Observable`。
*   当被通知时，除了发送通知的对象之外，`ChangeListener`对象还被告知另外两条信息——`oldValue`和`newValue`。发送对象被称为`ObservableValue`。
*   在绑定属性如`otherProperty`的情况下，我们无法从输出中得知`intProperty`中值的变化何时或如何通知它。然而，我们可以推断它一定知道这个变化，因为当我们向`otherProperty`请求它的值时，我们得到了`intProperty`的最新值。

Note

尽管这个激励示例使用了一个`Integer`属性，但是类似的示例也可以使用基于`Boolean`、`Long`、`Float`、`Double`、`String`和`Object`类型的属性。在 JavaFX 属性和绑定框架中，当接口为具体类型扩展或实现时，它们总是为`Boolean`、`Integer`、`Long`、`Float`、`Double`、`String`和`Object`类型完成。

这个例子让我们注意到 JavaFX 属性和绑定框架的一些关键接口和概念:包括`Observable`和相关联的`InvalidationListener`接口、`ObservableValue`和相关联的`ChangeListener`接口、`get()`、`set()`、`getValue()`和`setValue()`方法，它们允许我们直接操作`SimpleIntegerProperty`对象的值，以及`bind()`方法，它们允许我们通过从属于另一个`SimpleIntegerProperty`对象来放弃对`SimpleIntegerProperty`对象的值的直接操作。

在下一节中，我们将更详细地向您展示 JavaFX 属性和绑定框架的这些以及其他一些关键接口和概念。

## 理解关键接口和概念

图 3-1 是一个 UML 图，显示了 JavaFX 属性和绑定框架的关键接口。它包括一些您在上一节中看到的界面，以及一些您还没有看到的界面。

![A323806_4_En_3_Fig1_HTML.jpg](img/A323806_4_En_3_Fig1_HTML.jpg)

图 3-1。

Key interfaces of the JavaFX properties and bindings framework Note

我们没有向您展示 UML 图中接口的完全限定名。这些接口分布在四个包中:`javafx.beans`、`javafx.beans.binding`、`javafx.beans.property`和`javafx.beans.value`。通过查看 JavaFX API 文档或您喜欢的 IDE 的“find class”特性，您可以很容易地确定哪个接口属于哪个包。

### 理解可观察界面

层次结构的根是`Observable`接口。您可以将`InvalidationListener`对象注册到一个`Observable`对象来接收失效事件。在上一节的激励示例中，您已经看到了从一种`Observable`对象，即`SimpleIntegerProperty`对象`intProperty`触发的失效事件。当调用`set()`或`setValue()`方法将底层值从一个`int`更改为另一个`int`时，它被触发。

Note

如果您连续多次使用相同的值调用 setter，JavaFX 属性和绑定框架中的`Property`接口的任何实现只会触发一次失效事件。

另一个引发失效事件的地方是来自`Binding`对象。你还没有看到一个`Binding`对象的例子，但是在本章的后半部分有大量的`Binding`对象。现在我们只注意到一个`Binding`对象可能会变得无效，例如，当它的`invalidate()`方法被调用时，或者如我们在本章后面所展示的，当它的一个依赖项触发一个无效事件时。

Note

如果一个失效事件连续几次失效，那么 JavaFX properties and bindings 框架中的任何一个`Binding`接口实现都只会触发一次。

### 了解 ObservableValue 接口

层次结构中的下一个是`ObservableValue`接口。它只是一个有值的`Observable`。它的`getValue()`方法返回它的值。我们在激励示例中对`SimpleIntegerProperty`对象调用的`getValue()`方法可以被认为是来自这个接口。您可以将`ChangeListener`对象注册到一个`ObservableValue`对象来接收变更事件。

在上一节的激励示例中，您看到了变更事件被激发。当 change 事件触发时，`ChangeListener`接收到另外两条信息:`ObservableValue`对象的旧值和新值。

Note

如果您连续多次使用相同的值调用 setter，JavaFX 属性和绑定框架中的任何`ObservableValue`接口实现只会触发一次 change 事件。

无效事件和变更事件之间的区别在于 JavaFX 属性和绑定框架可以支持惰性评估。我们通过查看激励示例中的三行代码来展示一个例子:

```java
otherProperty.bind(intProperty);
intProperty.set(7168);
System.out.println("otherProperty.get() = " + otherProperty.get());

```

当调用`intProperty.set(7168)`时，它向`otherProperty`触发一个无效事件。在收到这个无效事件时，`otherProperty`简单地记录下它的值不再有效的事实。它不会通过查询`intProperty`来立即重新计算其值。当`otherProperty.get()`被调用时，重新计算被执行。想象一下，如果我们多次调用`intProperty.set()`，而不是像前面的代码那样只调用`intProperty.set()`一次；`otherProperty`仍然只重新计算一次它的值。

Note

`ObservableValue`接口不是`Observable`的唯一直接子接口。在`javafx.collections`包中还有另外四个`Observable`的直接子接口:`ObservableList`、`ObservableMap`、`ObservableSet`和`ObservableArray`，对应的`ListChangeListener`、`MapChangeListener`、`SetChangeListener`和`ArrayChangeListener`作为回调机制。这些 JavaFX 可观察集合将在第七章中介绍。

### 了解可写值接口

这可能是整个章节中最简单的部分，因为`WritableValue`界面确实像它看起来那样简单。它的目的是将`getValue()`和`setValue()`方法注入到这个接口的实现中。JavaFX 属性和绑定框架中`WritableValue`的所有实现类也实现了`ObservableValue`；所以你可以做一个论证，`WritableValue`的值只是为了提供`setValue()`方法。

你已经看到了激励例子中的`setValue()`方法。

### 了解 ReadOnlyProperty 接口

`ReadOnlyProperty`接口在其实现中注入了两个方法。`getBean()`方法应该返回包含`ReadOnlyRroperty`的`Object`，如果不包含在`Object`中，则返回 null。如果`ReadOnlyProperty`没有名字，那么`getName()`方法应该返回`ReadOnlyProperty`的名字或者空字符串。

包含对象和名称提供了关于`ReadOnlyProperty`的上下文信息。属性的上下文信息在无效事件的传播或值的重新计算中不起任何直接作用。但是，如果提供的话，会在一些外围计算中考虑到。

在我们的激励示例中，`intProperty`是在没有任何上下文信息的情况下构建的。如果我们使用完整的构造器给它命名，

```java
intProperty = new SimpleIntegerProperty(null, "intProperty", 1024);

```

输出将包含属性名:

```java
intProperty = IntegerProperty [name: intProperty, value: 1024]

```

### 了解属性接口

现在我们来到关键接口层次的底部。到目前为止，`Property`接口拥有我们已经研究过的所有四个接口作为它的超接口:`Observable`、`ObservableValue`、`ReadOnlyProperty`和`WritableValue`。因此，它继承了这些接口的所有方法。它还提供了自己的五种方法:

```java
void bind(ObservableValue<? extends T> observableValue);
void unbind();
boolean isBound();
void bindBidirectional(Property<T> tProperty);
void unbindBidirectional(Property<T> tProperty);

```

在上一节的激励示例中，您已经看到了两种有效的方法:`bind()`和`unbind()`。

调用`bind()`会在`Property`对象和`ObservableValue`参数之间创建一个单向绑定或依赖关系。一旦他们进入这种关系，调用`Property`对象上的`set()`或`setValue()`方法将导致抛出一个`RuntimeException`。调用`Property`对象上的`get()`或`getValue()`方法将返回`ObservableValue`对象的值。当然，改变`ObservableValue`对象的值会使`Property`对象失效。调用`unbind()`释放`Property`对象可能有的任何现有单向绑定。如果单向绑定生效，`isBound()`方法返回`true`；否则，返回`false`。

调用`bindBidirectional()`会在`Property`调用者和`Property`参数之间创建一个双向绑定。注意，与接受`ObservableValue`参数的`bind()`方法不同，`bindBidirectional()`方法接受`Property`参数。只有两个`Property`对象可以双向绑定在一起。一旦它们进入这种关系，在任一个`Property`对象上调用`set()`或`setValue()`方法将导致两个对象的值都被更新。调用`unbindBidirectional()`释放调用者和参数可能有的任何现有双向绑定。清单 3-2 中的程序展示了一个简单的双向绑定。

```java
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;

public class BidirectionalBindingExample {
    public static void main(String[] args) {
        System.out.println("Constructing two StringProperty objects.");
        StringProperty prop1 = new SimpleStringProperty("");
        StringProperty prop2 = new SimpleStringProperty("");

        System.out.println("Calling bindBidirectional.");
        prop2.bindBidirectional(prop1);

        System.out.println("prop1.isBound() = " + prop1.isBound());
        System.out.println("prop2.isBound() = " + prop2.isBound());

        System.out.println("Calling prop1.set(\"prop1 says: Hi!\")");
        prop1.set("prop1 says: Hi!");
        System.out.println("prop2.get() returned:");
        System.out.println(prop2.get());

        System.out.println("Calling prop2.set(prop2.get() + \"\\nprop2 says: Bye!\")");
        prop2.set(prop2.get() + "\nprop2 says: Bye!");
        System.out.println("prop1.get() returned:");
        System.out.println(prop1.get());
    }
}

Listing 3-2.
BidirectionalBindingExample.java

```

在这个例子中，我们创建了两个名为`prop1`和`prop2`的`SimpleStringProperty`对象，在它们之间创建了一个双向绑定，然后在两个属性上分别名为`set()`和`get()`。

当我们运行清单 3-2 中的程序时，以下输出被打印到控制台:

```java
Constructing two StringProperty objects.
Calling bindBidirectional.
prop1.isBound() = false
prop2.isBound() = false
Calling prop1.set("prop1 says: Hi!")
prop2.get() returned:
prop1 says: Hi!
Calling prop2.set(prop2.get() + "\nprop2 says: Bye!")
prop1.get() returned:
prop1 says: Hi!
prop2 says: Bye!

```

Caution

每个`Property`对象一次最多可以有一个活动的单向绑定。它可以有任意多的双向绑定。`isBound()`方法只适用于单向绑定。当单向绑定已经生效时，用不同的`ObservableValue`参数第二次调用`bind()`将会解除现有的绑定并用新的替换它。

### 了解绑定接口

`Binding`接口定义了四种揭示接口意图的方法。一个`Binding`对象是一个`ObservableValue`，它的有效性可以用`isValid()`方法查询，用`invalidate()`方法设置。它有一个依赖列表，可以用`getDependencies()`方法获得。最后一个`dispose()`方法发信号通知绑定将不再被使用，它所使用的资源可以被清理。

从这个对`Binding`接口的简短描述中，我们可以推断出它代表了一个具有多个依赖关系的单向绑定。我们想象，每一个依赖项都可以是一个`ObservableValue`，`Binding`注册到这个 ?? 来接收无效事件。当调用`get()`或`getValue()`方法时，如果绑定无效，则重新计算其值。

JavaFX 属性和绑定框架不提供任何实现`Binding`接口的具体类。但是，它提供了多种方法来轻松创建自己的`Binding`对象:可以在框架中扩展抽象基类；您可以在实用程序类`Bindings`中使用一组静态方法，从现有的常规 Java 值(即不可观察的值)、属性和绑定中创建新的绑定；您还可以使用各种属性和绑定类中提供的一组方法，并形成一个流畅的接口 API 来创建新的绑定。我们将在本章后面的“创建绑定”一节中介绍实用程序方法和 fluent 接口 API。现在，我们通过扩展`DoubleBinding`抽象类向您展示第一个绑定示例。清单 3-3 中的程序使用绑定来计算一个矩形的面积。

```java
import javafx.beans.binding.DoubleBinding;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;

public class RectangleAreaExample {
    public static void main(String[] args) {
        System.out.println("Constructing x with initial value of 2.0.");
        final DoubleProperty x = new SimpleDoubleProperty(null, "x", 2.0);
        System.out.println("Constructing y with initial value of 3.0.");
        final DoubleProperty y = new SimpleDoubleProperty(null, "y", 3.0);
        System.out.println("Creating binding area with dependencies x and y.");
        DoubleBinding area = new DoubleBinding() {
            private double value;

            {
                super.bind(x, y);
            }

            @Override
            protected double computeValue() {
                System.out.println("computeValue() is called.");
                return x.get() * y.get();
            }
        };
        System.out.println("area.get() = " + area.get());
        System.out.println("area.get() = " + area.get());
        System.out.println("Setting x to 5");
        x.set(5);
        System.out.println("Setting y to 7");
        y.set(7);
        System.out.println("area.get() = " + area.get());
    }
}

Listing 3-3.
RectangleAreaExample.java

```

在匿名内部类中，我们调用超类`DoubleBinding`中受保护的`bind()`方法，通知超类我们想要监听来自`DoubleProperty`对象`x`和`y`的失效事件。我们最终在超类`DoubleBinding`中实现了受保护的抽象`computeValue()`方法，以便在需要重新计算时进行实际计算。

当我们运行清单 3-3 中的程序时，以下输出被打印到控制台:

```java
Constructing x with initial value of 2.0.
Constructing y with initial value of 3.0.
Creating binding area with dependencies x and y.
computeValue() is called.
area.get() = 6.0
area.get() = 6.0
Setting x to 5
Setting y to 7
computeValue() is called.
area.get() = 35.0

```

注意，当我们连续两次调用`area.get()`时，`computeValue()`只被调用一次。

Caution

`DoubleBinding`抽象类包含一个空的默认实现`dispose()`和一个返回空列表的默认实现`getDependencies()`。为了使这个例子成为一个正确的`Binding`实现，我们应该覆盖这两个方法来正确地运行。

现在您已经牢牢掌握了 JavaFX 属性和绑定框架的关键接口和概念，我们将向您展示这些通用接口如何专用于特定类型的接口，以及如何在特定类型的抽象和具体类中实现。

## 键接口的特定类型专门化

我们在上一节中没有强调这个事实，因为我们相信省略它不会影响那里的解释，但是除了`Observable`和`InvalidationListener`，其余的接口都是带有类型参数`<T>`的通用接口。在本节中，我们将研究这些通用接口是如何专用于感兴趣的特定类型的:`Boolean`、`Integer`、`Long`、`Float`、`Double`、`String`和`Object`。我们还研究了框架的一些抽象和具体类，并探索了每个类的典型使用场景。

Note

这些接口的专门化也存在于`List`、`Map`和`Set`中。它们是为处理可观察集合而设计的。我们将在第七章中讨论可观测集合。

### 特定类型接口的通用主题

尽管通用接口的专门化方式并不完全相同，但存在一个共同的主题:

*   `Boolean`型直接专门化。
*   `Integer`、`Long`、`Float`和`Double`类型通过`Number`超类型特殊化。
*   `String`型通过`Object`型专门化。

这个主题存在于所有关键接口的特定于类型的专门化中。例如，我们检查`ObservableValue<T>`接口的子接口:

*   `ObservableBooleanValue`扩展了`ObservableValue<Boolean>`，它提供了一个额外的方法。
    *   `boolean get();`
*   `ObservableNumberValue`扩展了`ObservableValue<Number>`，它提供了四个额外的方法。
    *   `int intValue();`
    *   `long longValue();`
    *   `float floatValue();`
    *   `double doubleValue();`
*   `ObservableObjectValue<T>`扩展了`ObservableValue<T>`，它提供了一个额外的方法。
    *   `T get();`
*   `ObservableIntegerValue`、`ObservableLongValue`、`ObservableFloatValue`和`ObservableDoubleValue`扩展了`ObservableNumberValue`，并且每个都提供了一个额外的`get()`方法来返回适当的原始类型值。
*   `ObservableStringValue`扩展了`ObservableObjectValue<String>`并继承了其返回`String`的`get()`方法。

注意，我们在示例中使用的`get()`方法是在特定于类型的`ObservableValue`子接口中定义的。类似的检查揭示了我们在示例中使用的`set()`方法是在特定于类型的`WritableValue`子接口中定义的。

这种派生层次结构的一个实际结果是，任何数字属性都可以在任何其他数字属性或绑定上调用`bind()`。实际上，`bind()`方法对任何数字属性的签名如下:

```java
void bind(ObservableValue<? extends Number>  observable);

```

任何数值属性和绑定都可以赋给泛型参数类型。清单 3-4 中的程序显示，任何不同特定类型的数字属性都可以相互绑定。

```java
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.FloatProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.LongProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleFloatProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleLongProperty;

public class NumericPropertiesExample {
    public static void main(String[] args) {
        IntegerProperty i = new SimpleIntegerProperty(null, "i", 1024);
        LongProperty l = new SimpleLongProperty(null, "l", 0L);
        FloatProperty f = new SimpleFloatProperty(null, "f", 0.0F);
        DoubleProperty d = new SimpleDoubleProperty(null, "d", 0.0);
        System.out.println("Constructed numerical properties i, l, f, d.");

        System.out.println("i.get() = " + i.get());
        System.out.println("l.get() = " + l.get());
        System.out.println("f.get() = " + f.get());
        System.out.println("d.get() = " + d.get());

        l.bind(i);
        f.bind(l);
        d.bind(f);
        System.out.println("Bound l to i, f to l, d to f.");

        System.out.println("i.get() = " + i.get());
        System.out.println("l.get() = " + l.get());
        System.out.println("f.get() = " + f.get());
        System.out.println("d.get() = " + d.get());

        System.out.println("Calling i.set(2048).");
        i.set(2048);

        System.out.println("i.get() = " + i.get());
        System.out.println("l.get() = " + l.get());
        System.out.println("f.get() = " + f.get());
        System.out.println("d.get() = " + d.get());

        d.unbind();
        f.unbind();
        l.unbind();
        System.out.println("Unbound l to i, f to l, d to f.");

        f.bind(d);
        l.bind(f);
        i.bind(l);
        System.out.println("Bound f to d, l to f, i to l.");

        System.out.println("Calling d.set(10000000000L).");
        d.set(10000000000L);

        System.out.println("d.get() = " + d.get());
        System.out.println("f.get() = " + f.get());
        System.out.println("l.get() = " + l.get());
        System.out.println("i.get() = " + i.get());
    }
}

Listing 3-4.
NumericPropertiesExample.java

```

在本例中，我们创建了四个数字属性，并将它们绑定到一个大小递减的链中，以演示绑定是否按预期工作。然后，我们颠倒了链的顺序，将 double 属性的值设置为一个会溢出 integer 属性的数字，以强调这样一个事实:即使您可以将不同大小的数值属性绑定在一起，但是当依赖属性的值超出绑定属性的范围时，将应用普通的 Java 数值转换。

当我们运行清单 3-4 中的程序时，以下内容被打印到控制台:

```java
Constructed numerical properties i, l, f, d.
i.get() = 1024
l.get() = 0
f.get() = 0.0
d.get() = 0.0
Bound l to i, f to l, d to f.
i.get() = 1024
l.get() = 1024
f.get() = 1024.0
d.get() = 1024.0
Calling i.set(2048).
i.get() = 2048
l.get() = 2048
f.get() = 2048.0
d.get() = 2048.0
Unbound l to i, f to l, d to f.
Bound f to d, l to f, i to l.
Calling d.set(10000000000L).
d.get() = 1.0E10
f.get() = 1.0E10
l.get() = 10000000000
i.get() = 1410065408

```

### 常用类别

我们现在给出四个包`javafx.beans`、`javafx.beans.binding`、`javafx.beans.property`和`javafx.beans.value`的内容的调查。在本节中，`SimpleIntegerProperty`系列的类是指在`Boolean`、`Integer`、`Long`、`Float`、`Double`、`String`和`Object`类型上外推的类。所以说的话也适用于`SimpleBooleanProperty`，以此类推。

*   JavaFX 属性和绑定框架中最常用的类是`SimpleIntegerProperty`系列的类。它们提供了`Property`接口的所有功能，包括惰性评估。到目前为止，本章的所有例子都使用了它们。
*   JavaFX 属性和绑定框架中的另一组具体类是`ReadOnlyIntegerWrapper`系列的类。这些类实现了`Property`接口，但也有一个`getReadOnlyProperty()`方法，该方法返回一个与主`Property`同步的`ReadOnlyProperty`。当你需要一个完整的`Property`来实现一个组件，但是你只想把一个`ReadOnlyProperty`交给组件的客户端时，它们非常方便使用。
*   抽象类的`IntegerPropertyBase`系列可以被扩展以提供完整的`Property`类的实现，尽管实际上`SimpleIntegerProperty`系列的类更容易使用。在`IntegerPropertyBase`系列类中唯一的抽象方法是`getBean()`和`getName()`。
*   可以扩展抽象类的`ReadOnlyIntegerPropertyBase`系列来提供`ReadOnlyProperty`类的实现。这很少是必要的。在`ReadOnlyIntegerPropertyBase`系列的类中仅有的抽象方法是`get()`、`getBean()`和`getName()`。
*   在调用`addListener()`之前，`WeakInvalidationListener`和`WeakChangeListener`类可以用来包装`InvalidationListener`和`ChangeListener`实例。它们保存包装的侦听器实例的弱引用。只要您持有对您这边的包装侦听器的引用，弱引用将保持活动状态，并且您将接收事件。当您使用完包装的侦听器并从您的一端取消引用它时，弱引用将符合垃圾收集的条件，然后再进行垃圾收集。所有 JavaFX 属性和绑定框架`Observable`对象都知道如何在弱引用被垃圾收集后清理弱侦听器。当侦听器在使用后没有被删除时，这可以防止内存泄漏。`WeakInvalidationListener`和`WeakListener`类实现了`WeakListener`接口，如果包装的监听器实例被垃圾收集，其`wasGarbageCollected()`方法将返回`true`。

这涵盖了驻留在`javafx.beans`、`javafx.beans.property`和`javafx.beans.value`包中的所有 JavaFX 属性和绑定 API，以及`javafx.beans.binding`包中的一些 API，但不是全部。`javafx.beans.property.adapters`包提供了旧式 JavaBeans 属性和 JavaFX 属性之间的适配器。我们将在“使 JavaBeans 属性适应 JavaFX 属性”一节中介绍这些适配器。`javafx.beans.binding`包的其余类是 API，帮助您从现有的属性和绑定中创建新的绑定。这是下一节的重点。

## 创建绑定

现在，我们将注意力转向从现有的属性和绑定中创建新的绑定。在本章前面的“理解关键接口和概念”一节中，您已经了解到绑定是一个可观察的值，它有一系列依赖项，这些依赖项也是可观察的值。

JavaFX 属性和绑定框架提供了三种创建新绑定的方法:

*   扩展了`IntegerBinding`系列的抽象类。
*   使用绑定——在实用程序类`Bindings`中创建静态方法。
*   使用`IntegerExpression`系列抽象类提供的 fluent 接口 API。

您在“理解绑定接口”一节中看到了直接扩展方法。接下来我们将探索`Bindings`实用程序类。

### 了解绑定实用程序类

`Bindings`类包含 236 个工厂方法，这些方法利用现有的可观察值和常规值进行新的绑定。考虑到可观察值和常规 Java(不可观察)值都可以用于构建新的绑定，大多数方法都被重载。至少有一个参数必须是可观察值。下面是九个重载的`add()`方法的签名:

```java
public static NumberBinding add(ObservableNumberValue n1, ObservableNumberValue n2)
public static DoubleBinding add(ObservableNumberValue n, double d)
public static DoubleBinding add(double d, ObservableNumberValue n)
public static NumberBinding add(ObservableNumberValue n, float f)
public static NumberBinding add(float f, ObservableNumberValue n)
public static NumberBinding add(ObservableNumberValue n, long l)
public static NumberBinding add(long l, ObservableNumberValue n)
public static NumberBinding add(ObservableNumberValue n, int i)
public static NumberBinding add(int i, ObservableNumberValue n)

```

当调用`add()`方法时，它返回一个`NumberBinding`,其依赖项包括所有可观察值参数，其值是其两个参数值的和。类似的重载方法也存在于`subtract()`、`multiply()`和`divide()`中。

Note

从上一节回忆起，`ObservableIntegerValue`、`ObservableLongValue`、`ObservableFloatValue`和`ObservableDoubleValue`是`ObservableNumberValue`的子类。所以刚才说的四种算术方法，可以取这些可观测数值的任意组合，也可以取任何不可观测值。

清单 3-5 中的程序使用`Bindings`中的算术方法计算笛卡尔平面中顶点为`(x1, y1)`、`(x2, y2)`、`(x3, y3)`的三角形的面积，使用以下公式:

```java
 Area = (x1*y2 + x2*y3 + x3*y1 – x1*y3 – x2*y1 – x3*y2) / 2

```

```java
import javafx.beans.binding.Bindings;
import javafx.beans.binding.NumberBinding;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;

public class TriangleAreaExample {
    public static void main(String[] args) {
        IntegerProperty x1 = new SimpleIntegerProperty(0);
        IntegerProperty y1 = new SimpleIntegerProperty(0);
        IntegerProperty x2 = new SimpleIntegerProperty(0);
        IntegerProperty y2 = new SimpleIntegerProperty(0);
        IntegerProperty x3 = new SimpleIntegerProperty(0);
        IntegerProperty y3 = new SimpleIntegerProperty(0);

        final NumberBinding x1y2 = Bindings.multiply(x1, y2);
        final NumberBinding x2y3 = Bindings.multiply(x2, y3);
        final NumberBinding x3y1 = Bindings.multiply(x3, y1);
        final NumberBinding x1y3 = Bindings.multiply(x1, y3);
        final NumberBinding x2y1 = Bindings.multiply(x2, y1);
        final NumberBinding x3y2 = Bindings.multiply(x3, y2);

        final NumberBinding sum1 = Bindings.add(x1y2, x2y3);
        final NumberBinding sum2 = Bindings.add(sum1, x3y1);
        final NumberBinding sum3 = Bindings.add(sum2, x3y1);
        final NumberBinding diff1 = Bindings.subtract(sum3, x1y3);
        final NumberBinding diff2 = Bindings.subtract(diff1, x2y1);
        final NumberBinding determinant = Bindings.subtract(diff2, x3y2);
        final NumberBinding area = Bindings.divide(determinant, 2.0D);

        x1.set(0); y1.set(0);
        x2.set(6); y2.set(0);
        x3.set(4); y3.set(3);

        printResult(x1, y1, x2, y2, x3, y3, area);

        x1.set(1); y1.set(0);
        x2.set(2); y2.set(2);
        x3.set(0); y3.set(1);

        printResult(x1, y1, x2, y2, x3, y3, area);
    }

    private static void printResult(IntegerProperty x1, IntegerProperty y1,
                                    IntegerProperty x2, IntegerProperty y2,
                                    IntegerProperty x3, IntegerProperty y3,
                                    NumberBinding area) {
        System.out.println("For A(" +
                x1.get() + "," + y1.get() + "), B(" +
                x2.get() + "," + y2.get() + "), C(" +
                x3.get() + "," + y3.get() + "), the area of triangle ABC is " + area.getValue());
    }
}

Listing 3-5.
TriangleAreaExample.java

```

我们用`IntegerProperty`来表示坐标。构建`NumberBinding area`使用了`Bindings`的所有四种算术工厂方法。因为我们从`IntegerProperty`对象开始，即使来自`Bindings`的算术工厂方法的返回类型是`NumberBinding`，实际返回的对象，直到`determinant`，都是`IntegerBinding`对象。我们在`divide()`调用中使用了`2.0D`而不仅仅是`2`来强制划分为`double`划分，而不是`int`划分。我们构建的所有属性和绑定形成一个树形结构，以`area`为根，中间绑定为内部节点，属性`x1`、`y1`、`x2`、`y2`、`x3`、`y3`为叶。如果我们使用正则算术表达式的语法来解析面积公式的数学表达式，这个树类似于我们将得到的解析树。

当我们运行清单 3-5 中的程序时，以下输出被打印到控制台:

```java
For A(0,0), B(6,0), C(4,3), the area of triangle ABC is 9.0
For A(1,0), B(2,2), C(0,1), the area of triangle ABC is 1.5

```

除了算术方法之外，`Bindings`类还有以下工厂方法。

*   逻辑运算符:`and`、`or`、`not`
*   数字运算符:`min`、`max`、`negate`
*   对象运算符:`isNull`，`isNotNull`
*   字符串运算符:`length`、`isEmpty`、`isNotEmpty`
*   关系运算符:
    *   `equal`
    *   `equalIgnoreCase`
    *   `greaterThan`
    *   `greaterThanOrEqual`
    *   `lessThan`
    *   `lessThanOrEqual`
    *   `notEqual`
    *   `notEqualIgnoreCase`
*   创建运算符:
    *   `createBooleanBinding`
    *   `createIntegerBinding`
    *   `createLongBinding`
    *   `createFloatBinding`
    *   `createDoubleBinding`
    *   `createStringBinding`
    *   `createObjectBinding`
*   选择运算符:
    *   `select`
    *   `selectBoolean`
    *   `selectInteger`
    *   `selectLong`
    *   `selectFloat`
    *   `selectDouble`
    *   `selectString`

除了创建操作符和选择操作符，前面的操作符都执行您认为它们会执行的操作。对象运算符仅对可观察的字符串值和可观察的对象值有意义。字符串运算符仅对可观察的字符串值有意义。除了`IgnoreCase`以外的所有关系运算符都适用于数值。在比较`float`或`double`值时，数值的`equal`和`notEqual`操作符有第三个`double`公差参数。`equal`和`notEqual`操作符也适用于`boolean`、字符串和对象值。对于字符串和对象值，`equal`和`notEqual`操作符使用`equals()`方法比较它们的值。

创建操作符提供了一种无需直接扩展抽象基类就能创建绑定的便捷方式。它接受一个`Callable`和任意数量的依赖项作为参数。清单 3-3 中的区域双重绑定可以使用 lambda 表达式作为`Callable`重写，如下所示:

```java
DoubleBinding area = Bindings.createDoubleBinding(() -> {
    return x.get() * y.get();
}, x, y);

```

选择操作符对所谓的 Java FX bean 进行操作，Java bean 是根据 Java FX bean 规范构造的 Java 类。我们将在本章后面的“理解 Java FX bean 约定”一节中讨论 Java FX bean。

在`Bindings`中有许多处理可观察集合的方法。我们将在第七章中介绍它们。

这涵盖了`Bindings`中返回绑定对象的所有方法。`Bindings`中有 18 个方法不返回绑定对象。各种`bindBidirectional()`和`unbindBidirectional()`方法创建双向绑定。事实上，各种属性类中的`bindBidirectional()`和`unbindBidirectional()`方法简单地调用了`Bindings`类中相应的方法。`bindContent()`和`unbindContent()`方法将一个普通集合绑定到一个可观察的集合。`convert()`、`concat()`和一对重载的`format()`方法返回`StringExpression`对象。最后，`when()`方法返回一个`When`对象。

`When`和`StringExpression`类是创建绑定的 fluent 接口 API 的一部分，我们将在下一小节中介绍。

### 了解 Fluent 接口 API

如果你问，“为什么有人会给一个方法命名为`when()`？”以及“`When`类会封装什么样的信息？”欢迎加入俱乐部。当您没有注意到的时候，面向对象编程社区发明了一种全新的 API 设计方法，它完全无视几十年来面向对象实践的原则。这种新方法不是封装数据和将业务逻辑分布到相关的域对象中，而是产生一种 API 风格，它鼓励方法链接，并使用一种方法的返回类型来确定哪种方法可用于火车的下一节车厢。选择方法名称不是为了传达完整的意思，而是为了让整个方法链读起来像一个流畅的句子。这种风格被称为流畅的界面 API。

Note

你可以在 Martin Fowler 的网站上找到关于 fluent 接口的更全面的阐述，在本章的最后引用。

用于创建绑定的 fluent 接口 API 在`IntegerExpression`系列的类中定义。`IntegerExpression`是`IntegerProperty`和`IntegerBinding`的超类，使得`IntegerExpression`的方法在`IntegerProperty`和`IntegerBinding`类中也可用。四个数值表达式类共享一个公共的超接口`NumberExpression`，所有的方法都在这里定义。特定于类型的表达式类覆盖了一些产生`NumberBinding`的方法，以返回更合适的绑定类型。

下面列出了可用于七种属性和绑定的方法:

*   对于`BooleanProperty`和`BooleanBinding`
    *   `BooleanBinding and(ObservableBooleanValue b)`
    *   `BooleanBinding or(ObservableBooleanValue b)`
    *   `BooleanBinding not()`
    *   `BooleanBinding isEqualTo(ObservableBooleanValue b)`
    *   `BooleanBinding isNotEqualTo(ObservableBooleanValue b)`
    *   `StringBinding asString()`
*   适用于所有数字属性和绑定
    *   `BooleanBinding isEqualTo(ObservableNumberValue m)`
    *   `BooleanBinding isEqualTo(ObservableNumberValue m, double err)`
    *   `BooleanBinding isEqualTo(double d, double err)`
    *   `BooleanBinding isEqualTo(float f, double err)`
    *   `BooleanBinding isEqualTo(long l)`
    *   `BooleanBinding isEqualTo(long l, double err)`
    *   `BooleanBinding isEqualTo(int i)`
    *   `BooleanBinding isEqualTo(int i, double err)`
    *   `BooleanBinding isNotEqualTo(ObservableNumberValue m)`
    *   `BooleanBinding isNotEqualTo(ObservableNumberValue m, double err)`
    *   `BooleanBinding isNotEqualTo(double d, double err)`
    *   `BooleanBinding isNotEqualTo(float f, double err)`
    *   `BooleanBinding isNotEqualTo(long l)`
    *   `BooleanBinding isNotEqualTo(long l, double err)`
    *   `BooleanBinding isNotEqualTo(int i)`
    *   `BooleanBinding isNotEqualTo(int i, double err)`
    *   `BooleanBinding greaterThan(ObservableNumberValue m)`
    *   `BooleanBinding greaterThan(double d)`
    *   `BooleanBinding greaterThan(float f)`
    *   `BooleanBinding greaterThan(long l)`
    *   `BooleanBinding greaterThan(int i)`
    *   `BooleanBinding lessThan(ObservableNumberValue m)`
    *   `BooleanBinding lessThan(double d)`
    *   `BooleanBinding lessThan(float f)`
    *   `BooleanBinding lessThan(long l)`
    *   `BooleanBinding lessThan(int i)`
    *   `BooleanBinding greaterThanOrEqualTo(ObservableNumberValue m)`
    *   `BooleanBinding greaterThanOrEqualTo(double d)`
    *   `BooleanBinding greaterThanOrEqualTo(float f)`
    *   `BooleanBinding greaterThanOrEqualTo(long l)`
    *   `BooleanBinding greaterThanOrEqualTo(int i)`
    *   `BooleanBinding lessThanOrEqualTo(ObservableNumberValue m)`
    *   `BooleanBinding lessThanOrEqualTo(double d)`
    *   `BooleanBinding lessThanOrEqualTo(float f)`
    *   `BooleanBinding lessThanOrEqualTo(long l)`
    *   `BooleanBinding lessThanOrEqualTo(int i)`
    *   `StringBinding asString()`
    *   `StringBinding asString(String str)`
    *   `StringBinding asString(Locale locale, String str)`
*   对于`IntegerProperty`和`IntegerBinding`
    *   `IntegerBinding negate()`
    *   `NumberBinding add(ObservableNumberValue n)`
    *   `DoubleBinding add(double d)`
    *   `FloatBinding add(float f)`
    *   `LongBinding add(long l)`
    *   `IntegerBinding add(int i)`
    *   `NumberBinding subtract(ObservableNumberValue n)`
    *   `DoubleBinding subtract(double d)`
    *   `FloatBinding subtract(float f)`
    *   `LongBinding subtract(long l)`
    *   `IntegerBinding subtract(int i)`
    *   `NumberBinding multiply(ObservableNumberValue n)`
    *   `DoubleBinding multiply(double d)`
    *   `FloatBinding multiply(float f)`
    *   `LongBinding multiply(long l)`
    *   `IntegerBinding multiply(int i)`
    *   `NumberBinding divide(ObservableNumberValue n)`
    *   `DoubleBinding divide(double d)`
    *   `FloatBinding divide(float f)`
    *   `LongBinding divide(long l)`
    *   `IntegerBinding divide(int i)`
*   对于`LongProperty`和`LongBinding`
    *   `LongBinding negate()`
    *   `NumberBinding add(ObservableNumberValue n)`
    *   `DoubleBinding add(double d)`
    *   `FloatBinding add(float f)`
    *   `LongBinding add(long l)`
    *   `LongBinding add(int i)`
    *   `NumberBinding subtract(ObservableNumberValue n)`
    *   `DoubleBinding subtract(double d)`
    *   `FloatBinding subtract(float f)`
    *   `LongBinding subtract(long l)`
    *   `LongBinding subtract(int i)`
    *   `NumberBinding multiply(ObservableNumberValue n)`
    *   `DoubleBinding multiply(double d)`
    *   `FloatBinding multiply(float f)`
    *   `LongBinding multiply(long l)`
    *   `LongBinding multiply(int i)`
    *   `NumberBinding divide(ObservableNumberValue n)`
    *   `DoubleBinding divide(double d)`
    *   `FloatBinding divide(float f)`
    *   `LongBinding divide(long l)`
    *   `LongBinding divide(int i)`
*   对于`FloatProperty`和`FloatBinding`
    *   `FloatBinding negate()`
    *   `NumberBinding add(ObservableNumberValue n)`
    *   `DoubleBinding add(double d)`
    *   `FloatBinding add(float g)`
    *   `FloatBinding add(long l)`
    *   `FloatBinding add(int i)`
    *   `NumberBinding subtract(ObservableNumberValue n)`
    *   `DoubleBinding subtract(double d)`
    *   `FloatBinding subtract(float g)`
    *   `FloatBinding subtract(long l)`
    *   `FloatBinding subtract(int i)`
    *   `NumberBinding multiply(ObservableNumberValue n)`
    *   `DoubleBinding multiply(double d)`
    *   `FloatBinding multiply(float g)`
    *   `FloatBinding multiply(long l)`
    *   `FloatBinding multiply(int i)`
    *   `NumberBinding divide(ObservableNumberValue n)`
    *   `DoubleBinding divide(double d)`
    *   `FloatBinding divide(float g)`
    *   `FloatBinding divide(long l)`
    *   `FloatBinding divide(int i)`
*   对于`DoubleProperty`和`DoubleBinding`
    *   `DoubleBinding negate()`
    *   `DoubleBinding add(ObservableNumberValue n)`
    *   `DoubleBinding add(double d)`
    *   `DoubleBinding add(float f)`
    *   `DoubleBinding add(long l)`
    *   `DoubleBinding add(int i)`
    *   `DoubleBinding subtract(ObservableNumberValue n)`
    *   `DoubleBinding subtract(double d)`
    *   `DoubleBinding subtract(float f)`
    *   `DoubleBinding subtract(long l)`
    *   `DoubleBinding subtract(int i)`
    *   `DoubleBinding multiply(ObservableNumberValue n)`
    *   `DoubleBinding multiply(double d)`
    *   `DoubleBinding multiply(float f)`
    *   `DoubleBinding multiply(long l)`
    *   `DoubleBinding multiply(int i)`
    *   `DoubleBinding divide(ObservableNumberValue n)`
    *   `DoubleBinding divide(double d)`
    *   `DoubleBinding divide(float f)`
    *   `DoubleBinding divide(long l)`
    *   `DoubleBinding divide(int i)`
*   对于`StringProperty`和`StringBinding`
    *   `StringExpression concat(Object obj)`
    *   `BooleanBinding isEqualTo(ObservableStringValue str)`
    *   `BooleanBinding isEqualTo(String str)`
    *   `BooleanBinding isNotEqualTo(ObservableStringValue str)`
    *   `BooleanBinding isNotEqualTo(String str)`
    *   `BooleanBinding isEqualToIgnoreCase(ObservableStringValue str)`
    *   `BooleanBinding isEqualToIgnoreCase(String str)`
    *   `BooleanBinding isNotEqualToIgnoreCase(ObservableStringValue str)`
    *   `BooleanBinding isNotEqualToIgnoreCase(String str)`
    *   `BooleanBinding greaterThan(ObservableStringValue str)`
    *   `BooleanBinding greaterThan(String str)`
    *   `BooleanBinding lessThan(ObservableStringValue str)`
    *   `BooleanBinding lessThan(String str)`
    *   `BooleanBinding greaterThanOrEqualTo(ObservableStringValue str)`
    *   `BooleanBinding greaterThanOrEqualTo(String str)`
    *   `BooleanBinding lessThanOrEqualTo(ObservableStringValue str)`
    *   `BooleanBinding lessThanOrEqualTo(String str)`
    *   `BooleanBinding isNull()`
    *   `BooleanBinding isNotNull()`
    *   `IntegerBinding length()`
    *   `BooleanExpression isEmpty()`
    *   `BooleanExpression isNotEmpty()`
*   对于`ObjectProperty`和`ObjectBinding`
    *   `BooleanBinding isEqualTo(ObservableObjectValue<?> obj)`
    *   `BooleanBinding isEqualTo(Object obj)`
    *   `BooleanBinding isNotEqualTo(ObservableObjectValue<?> obj)`
    *   `BooleanBinding isNotEqualTo(Object obj)`
    *   `BooleanBinding isNull()`
    *   `BooleanBinding isNotNull()`

使用这些方法，您可以创建无限多种绑定，方法是从属性开始，调用适合该属性类型的方法之一来获取绑定，调用适合该绑定类型的方法之一来获取另一个绑定，依此类推。这里值得指出的一个事实是，特定于类型的数值表达式的所有方法都是在返回类型为`NumberBinding`的`NumberExpression`基本接口中定义的，并且在具有相同参数签名但返回类型更特定的特定于类型的表达式类中被覆盖。这种用相同的参数签名但更具体的返回类型覆盖子类中的方法的方式被称为协变返回类型覆盖，并且自 Java 5 以来一直是 Java 语言的一个特性。这一事实的结果之一是，用 fluent 接口 API 构建的数字绑定比用`Bindings`类中的工厂方法构建的绑定有更多特定的类型。

有时有必要将特定于类型的表达式转换为保存相同类型值的对象表达式。这可以通过特定于类型的表达式类中的`asObject()`方法来完成。可以使用 expressions 类中的静态方法进行转换。对于`IntegerExpression`，这些静态方法如下:

```java
static IntegerExpression integerExpression(ObservableIntegerValue value)
static <T extends java.lang.Number> IntegerExpression integerExpression(ObservableValue<T> value)

```

清单 3-6 中的程序是对清单 3-5 中三角形区域示例的修改，它使用了流畅的接口 API，而不是调用`Bindings`类中的工厂方法。

```java
import javafx.beans.binding.Bindings;
import javafx.beans.binding.NumberBinding;
import javafx.beans.binding.StringExpression;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;

public class TriangleAreaFluentExample {
    public static void main(String[] args) {
        IntegerProperty x1 = new SimpleIntegerProperty(0);
        IntegerProperty y1 = new SimpleIntegerProperty(0);
        IntegerProperty x2 = new SimpleIntegerProperty(0);
        IntegerProperty y2 = new SimpleIntegerProperty(0);
        IntegerProperty x3 = new SimpleIntegerProperty(0);
        IntegerProperty y3 = new SimpleIntegerProperty(0);

        final NumberBinding area = x1.multiply(y2)
                .add(x2.multiply(y3))
                .add(x3.multiply(y1))
                .subtract(x1.multiply(y3))
                .subtract(x2.multiply(y1))
                .subtract(x3.multiply(y2))
                .divide(2.0D);

        StringExpression output = Bindings.format(
                "For A(%d,%d), B(%d,%d), C(%d,%d), the area of triangle ABC is %3.1f",
                x1, y1, x2, y2, x3, y3, area);

        x1.set(0); y1.set(0);
        x2.set(6); y2.set(0);
        x3.set(4); y3.set(3);

        System.out.println(output.get());

        x1.set(1); y1.set(0);
        x2.set(2); y2.set(2);
        x3.set(0); y3.set(1);

        System.out.println(output.get());
    }
}

Listing 3-6.
TriangleAreaFluentExample.java

```

请注意清单 3-5 中用于构建区域绑定的 13 行代码和 12 个中间变量是如何减少到清单 3-6 中不使用中间变量的 7 行代码的。我们还使用了`Bindings.format()`方法来构建一个名为`output`的`StringExpression`对象。有两个带签名的重载`Bindings.format()`方法:

```java
StringExpression format(Locale locale, String format, Object... args)
StringExpression format(String format, Object... args)

```

它们的工作方式与相应的`String.format()`方法类似，它们根据格式规范`format`和`Locale locale`或者默认的`Locale`对值`args`进行格式化。如果`args`中的任何一个是`ObservableValue`，其变化将反映在`StringExpression`中。

当我们运行清单 3-6 中的程序时，以下输出被打印到控制台:

```java
For A(0,0), B(6,0), C(4,3), the area of triangle ABC is 9.0
For A(1,0), B(2,2), C(0,1), the area of triangle ABC is 1.5

```

接下来，我们将揭开`When`类的神秘面纱，以及它在构建本质上是 if/then/else 表达式的绑定中所扮演的角色。`When`类有一个接受`ObservableBooleanValue`参数的构造器:

```java
public When(ObservableBooleanValue b)

```

它有以下 11 个重载的`then()`方法。

```java
When.NumberConditionBuilder then(ObservableNumberValue n)
When.NumberConditionBuilder then(double d)
When.NumberConditionBuilder then(float f)
When.NumberConditionBuilder then(long l)
When.NumberConditionBuilder then(int i)
When.BooleanConditionBuilder then(ObservableBooleanValue b)
When.BooleanConditionBuilder then(boolean b)
When.StringConditionBuilder then(ObservableStringValue str)
When.StringConditionBuilder then(String str)
When.ObjectConditionBuilder<T> then(ObservableObjectValue<T> obj)
When.ObjectConditionBuilder<T> then(T obj)

```

从`then()`方法返回的对象类型取决于参数的类型。如果参数是数值类型，无论是可观察的还是不可观察的，返回类型都是嵌套类`When.NumberConditionBuilder`。同样，对于布尔参数，返回类型是`When.BooleanConditionBuilder`；对于字符串参数，`When.StringConditionBuilder`；而对于对象论证，`When.ObjectConditionBuilder`。

这些条件构建器又有下面的`otherwise()`方法。

*   对于`When.NumberConditionBuilder`
    *   `NumberBinding otherwise(ObservableNumberValue n)`
    *   `DoubleBinding otherwise(double d)`
    *   `NumberBinding otherwise(float f)`
    *   `NumberBinding otherwise(long l)`
    *   `NumberBinding otherwise(int i)`
*   对于`When.BooleanConditionBuilder`
    *   `BooleanBinding otherwise(ObservableBooleanValue b)`
    *   `BooleanBinding` `otherwise(boolean b)`
*   对于`When.StringConditionBuilder`
    *   `StringBinding otherwise(ObservableStringValue str)`
    *   `StringBinding otherwise(String str)`
*   对于`When.ObjectConditionBuilder`
    *   `ObjectBinding<T> otherwise(ObservableObjectValue<T>  obj)`
    *   `ObjectBinding<T> otherwise(T obj)`

这些方法签名的最终效果是，您可以通过以下方式构建一个类似于 if/then/else 表达式的绑定:

```java
new When(b).then(x).otherwise(y)

```

`b`是一个`ObservableBooleanValue`，`x`和`y`是类似的类型，可以是可观测的，也可以是不可观测的。最终的绑定将是类似于`x`和`y`的类型。

清单 3-7 中的程序使用来自`When`类的 fluent 接口 API 来计算给定边`a`、`b`和`c`的三角形的面积。回想一下，要形成三角形，三条边必须满足以下条件:

```java
a + b > c, b + c > a, c + a > b.

```

当满足上述条件时，可以使用 Heron 公式计算三角形的面积:

```java
Area = sqrt(s * (s – a) * (s – b) * (s – c))

```

其中`s`是半参数:

```java
s = (a + b + c) / 2.

```

```java
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.When;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
public class HeronsFormulaExample {
    public static void main(String[] args) {
        DoubleProperty a = new SimpleDoubleProperty(0);
        DoubleProperty b = new SimpleDoubleProperty(0);
        DoubleProperty c = new SimpleDoubleProperty(0);

        DoubleBinding s = a.add(b).add(c).divide(2.0D);

        final DoubleBinding areaSquared = new When(
                        a.add(b).greaterThan(c)
                        .and(b.add(c).greaterThan(a))
                        .and(c.add(a).greaterThan(b)))
                .then(s.multiply(s.subtract(a))
                        .multiply(s.subtract(b))
                        .multiply(s.subtract(c)))
                .otherwise(0.0D);

        a.set(3);
        b.set(4);
        c.set(5);
        System.out.printf("Given sides a = %1.0f, b = %1.0f, and c = %1.0f," +
                " the area of the triangle is %3.2f\n", a.get(), b.get(), c.get(),
                Math.sqrt(areaSquared.get()));

        a.set(2);
        b.set(2);
        c.set(2);
        System.out.printf("Given sides a = %1.0f, b = %1.0f, and c = %1.0f," +
                " the area of the triangle is %3.2f\n", a.get(), b.get(), c.get(),
                Math.sqrt(areaSquared.get()));
    }
}

Listing 3-7.
HeronsFormulaExample.java

```

由于`DoubleExpression`中没有现成的绑定方法来计算平方根，我们为`areaSquared`创建了一个`DoubleBinding`。`When()`的构造器参数是由`a`、`b`和`c`三个条件构建的`BooleanBinding`。`then()`方法的参数是计算三角形面积平方的`DoubleBinding`。因为`then()`参数是数字，所以`otherwise()`参数也必须是数字。我们选择使用`0.0D`来表示遇到了无效的三角形。

Note

除了使用`When()`构造器，还可以使用`Bindings`实用程序类中的工厂方法`when()`来创建`When`对象。

当我们运行清单 3-7 中的程序时，以下输出被打印到控制台:

```java
Given sides a = 3, b = 4, and c = 5, the area of the triangle is 6.00.
Given sides a = 2, b = 2, and c = 2, the area of the triangle is 1.73.

```

如果清单 3-7 中定义的绑定让您有点晕头转向，您并不孤单。我们选择这个例子只是为了说明由`When`类提供的 fluent 接口 API 的使用。事实上，我们在“理解绑定接口”一节中首次介绍的直接子类化方法可能更适合这个例子。

清单 3-8 中的程序通过使用直接扩展方法解决了与清单 3-7 相同的问题。

```java
import javafx.beans.binding.DoubleBinding;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;

public class HeronsFormulaDirectExtensionExample {
    public static void main(String[] args) {
        final DoubleProperty a = new SimpleDoubleProperty(0);
        final DoubleProperty b = new SimpleDoubleProperty(0);
        final DoubleProperty c = new SimpleDoubleProperty(0);

        DoubleBinding area = new DoubleBinding() {
            {
                super.bind(a, b, c);
            }
            @Override
            protected double computeValue() {
                double a0 = a.get();
                double b0 = b.get();
                double c0 = c.get();

                if ((a0 + b0 > c0) && (b0 + c0 > a0) && (c0 + a0 > b0)) {
                    double s = (a0 + b0 + c0) / 2.0D;
                    return Math.sqrt(s * (s - a0) * (s - b0) * (s - c0));
                } else {
                    return 0.0D;
                }
            }
        };

        a.set(3);
        b.set(4);
        c.set(5);
        System.out.printf("Given sides a = %1.0f, b = %1.0f, and c = %1.0f," +
                " the area of the triangle is %3.2f\n", a.get(), b.get(), c.get(),
                area.get());

        a.set(2);
        b.set(2);
        c.set(2);
        System.out.printf("Given sides a = %1.0f, b = %1.0f, and c = %1.0f," +
                " the area of the triangle is %3.2f\n", a.get(), b.get(), c.get(),
                area.get());
    }
}

Listing 3-8.
HeronsFormulaDirectExtensionExample.java

```

对于复杂的表达式和超出可用运算符范围的表达式，首选直接扩展方法。

现在，您已经掌握了`javafx.beans`、`javafx.beans.binding`、`javafx.beans.property`和`javafx.beans.value`包中的所有 API，您已经准备好超越 JavaFX 属性和绑定框架的细节，并学习如何将这些属性组织成称为 JavaFX Beans 的更大的组件。

## 了解 JavaFX Beans 约定

JavaFX 引入了 JavaFX Beans 的概念，这是一组为 Java 对象提供属性支持的约定。在本节中，我们将讨论指定 JavaFX Beans 属性的命名约定、实现 JavaFX Beans 属性的几种方法，以及选择绑定的使用。

### JavaFX Beans 规范

多年来，Java 一直使用 JavaBeans API 来表示对象的属性。JavaBeans 属性由一对 getter 和 setter 方法表示。属性更改通过激发 setter 代码中的属性更改事件传播到属性更改侦听器。

JavaFX 引入了 JavaFX Beans 规范，该规范通过 JavaFX 属性和绑定框架中的属性类的帮助，为 Java 对象添加了属性支持。

Caution

财产这个词在这里有两种不同的含义。当我们说“JavaFX Beans 属性”时，应该理解为是指类似于 JavaBeans 属性的更高层次的概念。当我们说“JavaFX 属性和绑定框架属性”时，应该理解为是指`Property`或`ReadOnlyProperty`接口的各种实现，比如`IntegerProperty`、`StringProperty`等等。JavaFX Beans 属性是使用 JavaFX 属性和绑定框架属性指定的。

像它们的 JavaBeans 对应物一样，JavaFX Beans 属性是由 Java 类中的一组方法指定的。要在 Java 类中定义 JavaFX Beans 属性，需要提供三个方法:getter、setter 和属性 getter。对于类型为`double`的名为`height`的属性，有三种方法:

```java
public final double getHeight();
public final void setHeight(double h);
public DoubleProperty heightProperty();

```

getter 和 setter 方法的名称遵循 JavaBeans 约定。它们是通过将“`get`”和“`set`”与首字母大写的属性名称连接起来获得的。对于`boolean`类型属性，getter 名称也可以以`is`开头。属性 getter 的名称是通过将属性的名称与“`Property`”连接起来获得的。要定义一个只读的 JavaFX Beans 属性，您可以移除 setter 方法，或者将其更改为私有方法，并将属性 getter 的返回类型更改为`ReadOnlyProperty`。

该规范仅涉及 JavaFX Beans 属性的接口，并没有强加任何实现约束。根据 JavaFX Bean 可能拥有的属性数量以及这些属性的使用模式，有几种实现策略。毫不奇怪，它们都使用 JavaFX 属性和绑定框架属性作为 JavaFX Beans 属性值的后备存储。我们将在接下来的两个小节中向您展示这些策略。

### 理解急切实例化的属性策略

热切实例化属性策略是实现 JavaFX Beans 属性的最简单方式。对于要在对象中定义的每个 JavaFX Beans 属性，您需要在类中引入一个私有字段，该字段属于适当的 JavaFX 属性和绑定框架属性类型。这些私有字段在 bean 构建时被实例化。getter 和 setter 方法简单地调用私有字段的`get()`和`set()`方法。属性 getter 只是返回私有字段本身。

清单 3-9 中的程序定义了一个具有`int`属性`i`、`String`属性`str`和`Color`属性`color`的 JavaFX Bean。

```java
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.scene.paint.Color;

public class JavaFXBeanModelExample {
    private IntegerProperty i = new SimpleIntegerProperty(this, "i", 0);
    private StringProperty str = new SimpleStringProperty(this, "str", "Hello");
    private ObjectProperty<Color> color = new SimpleObjectProperty<Color>(this, "color",
 Color.BLACK);

    public final int getI() {
        return i.get();
    }

    public final void setI(int i) {
        this.i.set(i);
    }

    public IntegerProperty iProperty() {
        return i;
    }

    public final String getStr() {
        return str.get();
    }

    public final void setStr(String str) {
        this.str.set(str);
    }

    public StringProperty strProperty() {
        return str;
    }

    public final Color getColor() {
        return color.get();
    }

    public final void setColor(Color color) {
        this.color.set(color);
    }

    public ObjectProperty<Color> colorProperty() {
        return color;
    }
}

Listing 3-9.
JavaFXBeanModelExample.java

```

这是一个简单的 Java 类。在这个实现中，我们只想指出两件事。首先，按照惯例，getter 和 setter 方法被声明为`final`。第二，当私有字段被初始化时，我们用完整的上下文信息调用简单的属性构造器，并把`this`作为第一个参数提供给它们。在本章之前的所有例子中，我们使用`null`作为简单属性构造器的第一个参数，因为这些属性不是更高级 JavaFX Bean 对象的一部分。

清单 3-10 中的程序定义了一个视图类，它监视清单 3-9 中定义的 JavaFX Bean 的一个实例。它通过连接更改监听器来观察 bean 的`i`、`str`和`color`属性的更改，这些监听器将任何更改打印到控制台。

```java
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.scene.paint.Color;

public class JavaFXBeanViewExample {
    private JavaFXBeanModelExample model;

    public JavaFXBeanViewExample(JavaFXBeanModelExample model) {
        this.model = model;
        hookupChangeListeners();
    }

    private void hookupChangeListeners() {
        model.iProperty().addListener(new ChangeListener<Number>() {
            @Override
            public void changed(ObservableValue<? extends Number> observableValue, Number
            oldValue, Number newValue) {
                System.out.println("Property i changed: old value = " + oldValue + ", new
                value = " + newValue);
            }
        });

        model.strProperty().addListener(new ChangeListener<String>() {
            @Override
            public void changed(ObservableValue<? extends String> observableValue, String
            oldValue, String newValue) {
                System.out.println("Property str changed: old value = " + oldValue + ", new
                value = " + newValue);
            }
        });

        model.colorProperty().addListener(new ChangeListener<Color>() {
            @Override
            public void changed(ObservableValue<? extends Color> observableValue, Color
            oldValue, Color newValue) {
                System.out.println("Property color changed: old value = " + oldValue + ",
                new value = " + newValue);
            }
        });
    }
}

Listing 3-10.
JavaFXBeanViewExample.java

```

清单 3-11 中的程序定义了一个可以修改模型对象的控制器。

```java
import javafx.scene.paint.Color;

public class JavaFXBeanControllerExample {
    private JavaFXBeanModelExample model;
    private JavaFXBeanViewExample view;

    public JavaFXBeanControllerExample(JavaFXBeanModelExample model, JavaFXBeanViewExampleÉ
 view) {
        this.model = model;
        this.view = view;
    }

    public void incrementIPropertyOnModel() {
        model.setI(model.getI() + 1);
    }

    public void changeStrPropertyOnModel() {
        final String str = model.getStr();
        if (str.equals("Hello")) {
            model.setStr("World");
        } else {
            model.setStr("Hello");
        }
    }

    public void switchColorPropertyOnModel() {
        final Color color = model.getColor();
        if (color.equals(Color.BLACK)) {
            model.setColor(Color.WHITE);
        } else {
            model.setColor(Color.BLACK);
        }
    }
}

Listing 3-11.
JavaFXBeanControllerExample.java

```

请注意，这不是一个成熟的控制器，它对视图对象的引用不做任何事情。清单 3-12 中的程序提供了一个主程序，它以典型的模型-视图-控制器模式组装并测试驱动清单 3-9 到 3-11 中的类。

```java
public class JavaFXBeanMainExample {
    public static void main(String[] args) {
        JavaFXBeanModelExample model = new JavaFXBeanModelExample();
        JavaFXBeanViewExample view = new JavaFXBeanViewExample(model);
        JavaFXBeanControllerExample controller = new JavaFXBeanControllerExample(model, view);

        controller.incrementIPropertyOnModel();
        controller.changeStrPropertyOnModel();
        controller.switchColorPropertyOnModel();
        controller.incrementIPropertyOnModel();
        controller.changeStrPropertyOnModel();
        controller.switchColorPropertyOnModel();
    }
}

Listing 3-12.
JavaFXbeanMainExample.java

```

当我们运行清单 3-9 到 3-12 中的程序时，以下输出被打印到控制台:

```java
Property i changed: old value = 0, new value = 1
Property str changed: old value = Hello, new value = World
Property color changed: old value = 0x000000ff, new value = 0xffffffff
Property i changed: old value = 1, new value = 2
Property str changed: old value = World, new value = Hello
Property color changed: old value = 0xffffffff, new value = 0x000000ff

```

### 理解延迟实例化属性策略

如果您的 JavaFX Bean 有许多属性，那么在 Bean 创建时预先实例化所有的 properties 对象可能是一种过于繁重的方法。如果只有少数属性被实际使用，那么所有 properties 对象的内存都被浪费了。在这种情况下，您可以使用几个延迟实例化的属性策略之一。两种典型的策略是半懒惰实例化策略和全懒惰实例化策略。

在半懒惰策略中，只有在使用不同于默认值的值调用 setter 时，或者在调用属性 getter 时，属性对象才会被实例化。清单 3-13 中的程序说明了这个策略是如何实现的。

```java
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;

public class JavaFXBeanModelHalfLazyExample {
    private static final String DEFAULT_STR = "Hello";
    private StringProperty str;

    public final String getStr() {
        if (str != null) {
            return str.get();
        } else {
            return DEFAULT_STR;
        }
    }

    public final void setStr(String str) {
        if ((this.str != null) || !(str.equals(DEFAULT_STR))) {
            strProperty().set(str);
        }
    }

    public StringProperty strProperty() {
        if (str == null) {
            str = new SimpleStringProperty(this, "str", DEFAULT_STR);
        }
        return str;
    }
}

Listing 3-13.
JavaFXBeanModelHalfLazyExample.java

```

在这种策略中，客户端代码可以多次调用 getter，而无需实例化属性对象。如果 property 对象为空，getter 只返回默认值。一旦用一个不同于默认值的值调用 setter，它将调用属性 getter，该属性 getter 惰性地实例化属性对象。如果客户端代码直接调用属性 getter，属性对象也会被实例化。

在全懒策略中，只有在调用属性 getter 时，属性对象才会被实例化。只有当属性对象已经被实例化时，getter 和 setter 才会检查它；否则，它们会通过一个单独的字段。

清单 3-14 中的程序展示了一个全懒惰属性的例子。

```java
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;

public class JavaFXBeanModelFullLazyExample {
    private static final String DEFAULT_STR = "Hello";
    private StringProperty str;
    private String _str = DEFAULT_STR;

    public final String getStr() {
        if (str != null) {
            return str.get();
        } else {
            return _str;
        }
    }

    public final void setStr(String str) {
        if (this.str != null) {
            this.str.set(str);
        } else {
            _str = str;
        }
    }

    public StringProperty strProperty() {
        if (str == null) {
            str = new SimpleStringProperty(this, "str", _str);
        }
        return str;
    }
}

Listing 3-14.
JavaFXBeanModelFullLazyExample.java

```

Caution

全惰性实例化策略会产生额外的字段开销，以稍微延长对属性实例化的需求。类似地，半懒惰和全懒惰实例化策略都要付出实现复杂性和运行时性能的代价，以获得潜在的运行时内存占用减少的好处。这是软件工程中一个经典的权衡情况。您选择哪种策略将取决于您的应用环境。我们的建议是，只有在需要的时候才引入优化。

### 使用选择绑定

正如您在“理解绑定实用程序类”一节中看到的，`Bindings`实用程序类包含七个选择操作符。这些运算符的方法签名是:

*   `select(Object root, String… steps)`
*   `selectBoolean(Object root, String… steps)`
*   `selectDouble(Object root, String… steps)`
*   `selectFloat(Object root, String… steps)`
*   `selectInteger(Object root, String… steps)`
*   `selectLong(Object root, String… steps)`
*   `selectString(Object root, String… steps)`

这些选择操作符允许您创建观察深度嵌套的 JavaFX Beans 属性的绑定。假设您有一个具有属性的 JavaFX bean，其类型是具有属性的 JavaFX bean，其类型是具有属性的 JavaFX bean，依此类推。假设你正在通过一个`ObjectProperty`观察这个属性链的根。然后，您可以创建一个绑定来观察深度嵌套的 JavaFX Beans 属性，方法是调用一个 select 方法，该方法的类型与深度嵌套的 JavaFX Beans 属性的类型相匹配，并将`ObjectProperty`作为根，将到达深度嵌套的 JavaFX Beans 属性的后续 JavaFX Beans 属性名称作为其余参数。

Note

还有另一组选择方法，将一个`ObservableValue`作为第一个参数。它们是在 JavaFX 2.0 中引入的。以`Object`作为第一个参数的 select 方法集允许我们使用任何 Java 对象，而不仅仅是 JavaFX Beans，作为选择绑定的根。

在下面的例子中，我们使用了`javafx.scene.effect`包中的几个类——`Lighting`和`Light`——来说明选择操作符是如何工作的。在本书后面的章节中，我们会教你如何将光照应用到 JavaFX 场景图中。目前，我们感兴趣的是，`Lighting`是一个 JavaFX bean，它有一个名为`light`的属性，其类型为`Light`，而`Light`也是一个 JavaFX bean，它有一个名为`color`的属性，其类型为`Color`(在`javafx.scene.paint`中)。

清单 3-15 中的程序说明了如何观察灯光的颜色。

```java
import javafx.beans.binding.Bindings;
import javafx.beans.binding.ObjectBinding;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.scene.effect.Light;
import javafx.scene.effect.Lighting;
import javafx.scene.paint.Color;

public class SelectBindingExample {
    public static void main(String[] args) {
        ObjectProperty<Lighting> root = new SimpleObjectProperty<>(new Lighting());
        final ObjectBinding<Color> selectBinding = Bindings.select(root, "light", "color");
        selectBinding.addListener(new ChangeListener<Color>() {
            @Override
            public void changed(ObservableValue<? extends Color> observableValue, Color
                oldValue, Color newValue) {
                System.out.println("\tThe color changed:\n\t\told color = " +
                    oldValue + ",\n\t\tnew color = " + newValue);
            }
        });

        System.out.println("firstLight is black.");
        Light firstLight = new Light.Point();
        firstLight.setColor(Color.BLACK);

        System.out.println("secondLight is white.");
        Light secondLight = new Light.Point();
        secondLight.setColor(Color.WHITE);

        System.out.println("firstLighting has firstLight.");
        Lighting firstLighting = new Lighting();
        firstLighting.setLight(firstLight);

        System.out.println("secondLighting has secondLight.");
        Lighting secondLighting = new Lighting();
        secondLighting.setLight(secondLight);

        System.out.println("Making root observe firstLighting.");
        root.set(firstLighting);

        System.out.println("Making root observe secondLighting.");
        root.set(secondLighting);

        System.out.println("Changing secondLighting's light to firstLight");
        secondLighting.setLight(firstLight);

        System.out.println("Changing firstLight's color to red");
        firstLight.setColor(Color.RED);
    }
}

Listing 3-15.
SelectBindingExample.java

```

在这个例子中，`root`是观察`Lighting`物体的`ObjectProperty`。绑定`colorBinding`观察`Lighting`对象的`light`属性的`color`属性，即`root`的值。然后，我们创建了一些`Light`和`Lighting`对象，并以各种方式更改了它们的配置。

当我们运行清单 3-15 中的程序时，以下输出被打印到控制台:

```java
firstLight is black.
secondLight is white.
firstLighting has firstLight.
secondLighting has secondLight.
Making root observe firstLighting.
    The color changed:
        old color = 0xffffffff,
        new color = 0x000000ff
Making root observe secondLighting.
    The color changed:
        old color = 0x000000ff,
        new color = 0xffffffff
Changing secondLighting's light to firstLight
    The color changed:
        old color = 0xffffffff,
        new color = 0x000000ff
Changing firstLight's color to red
    The color changed:
        old color = 0x000000ff,
        new color = 0xff0000ff

```

不出所料，`root`观察到的物体配置的每一个变化都会触发一个变化事件，`colorBinding`的值总是反映当前`Lighting`物体在`root`中的光线颜色。

Caution

如果提供的属性名与 JavaFX bean 中的任何属性名都不匹配，JavaFX 属性和绑定框架不会发出任何警告。它将只包含类型的默认值:`null`表示对象类型，零表示数值类型，`false`表示`boolean`类型，空字符串表示字符串类型。

## 使 JavaBeans 属性适应 JavaFX 属性

自 JavaBeans 规范发布以来的许多年里，为各种项目、产品和库编写了许多 JavaBeans。为了更好地帮助 Java 开发人员利用这些 JavaBean，在`javafx.beans.properties.adapter`包中提供了一组适配器，通过在 JavaBeans 属性之外创建一个 JavaFX 属性，使它们在 JavaFX 世界中有用。

在本节中，我们首先通过一个简单的例子简要回顾 JavaBeans 规范对属性、绑定属性和约束属性的定义。然后，我们向您展示如何使用适配器从 JavaBeans 属性创建 JavaFX 属性。

### 了解 JavaBeans 属性

JavaBeans 属性是使用熟悉的 getter 和 setter 命名约定定义的。如果只提供了 getter，则属性是“只读”的，如果同时提供了 getter 和 setter，则属性是“读/写”的。JavaBeans 事件由事件对象、事件监听器接口和 JavaBean 上的监听器注册方法组成。JavaBeans 属性可以使用两种特殊的事件:当 JavaBeans 属性改变时，可以触发一个`PropertyChange`事件；当 JavaBeans 属性改变时，也可以触发一个`VetoableChange`事件；而如果监听器抛出一个`PropertyVetoException`，属性更改应该不会生效。setter 触发`PropertyChange`事件的属性称为绑定属性。其 setter 触发`VetoableChange`事件的属性称为受约束属性。助手类`PropertyChangeSupport`和`VetoableChangeSupport`允许在 JavaBean 类中轻松定义绑定属性和约束属性。

清单 3-16 用三个属性定义了一个 JavaBean`Person`:`name`、`address`和`phoneNumber`。`address`属性是一个绑定属性，`phoneNumber`属性是一个约束属性。

```java
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyVetoException;
import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;

public class Person {
    private PropertyChangeSupport propertyChangeSupport;
    private VetoableChangeSupport vetoableChangeSupport;
    private String name;
    private String address;
    private String phoneNumber;

    public Person() {
        propertyChangeSupport = new PropertyChangeSupport(this);
        vetoableChangeSupport = new VetoableChangeSupport(this);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        String oldAddress = this.address;
        this.address = address;
        propertyChangeSupport.firePropertyChange("address", oldAddress, this.address);
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(String phoneNumber) throws PropertyVetoException {
        String oldPhoneNumber = this.phoneNumber;
        vetoableChangeSupport.fireVetoableChange("phoneNumber", oldPhoneNumber, phoneNumber);
        this.phoneNumber = phoneNumber;
        propertyChangeSupport.firePropertyChange("phoneNumber", oldPhoneNumber, this.phoneNumber);
    }

    public void addPropertyChangeListener(PropertyChangeListener l) {
        propertyChangeSupport.addPropertyChangeListener(l);
    }

    public void removePropertyChangeListener(PropertyChangeListener l) {
        propertyChangeSupport.removePropertyChangeListener(l);
    }

    public PropertyChangeListener[] getPropertyChangeListeners() {
        return propertyChangeSupport.getPropertyChangeListeners();
    }

    public void addVetoableChangeListener(VetoableChangeListener l) {
        vetoableChangeSupport.addVetoableChangeListener(l);
    }

    public void removeVetoableChangeListener(VetoableChangeListener l) {
        vetoableChangeSupport.removeVetoableChangeListener(l);
    }

    public VetoableChangeListener[] getVetoableChangeListeners() {
        return vetoableChangeSupport.getVetoableChangeListeners();
    }
}

Listing 3-16.
Person.java

```

### 了解 JavaFX 属性适配器

`javafx.beans.property.adapter`包中的接口和类可以用来轻松地将 JavaBeans 属性适配到 JavaFX 属性。`ReadOnlyJavaBeanProperty`接口是`ReadOnlyProperty`的子接口，增加了两个方法:

```java
void dispose()
void fireValueChangedEvent()

```

`JavaBeanProperty`接口扩展了`ReadOnlyJavaBeanProperty`和`Property`接口。这两个接口中的每一个都有针对`Boolean`、`Integer`、`Long`、`Float`、`Double`、`Object`和`String`类型的具体类专门化。这些类没有公共构造器。相反，提供了生成器类来创建这些类型的实例。我们在下面的示例代码中使用了`JavaBeanStringProperty`类。相同的模式适用于所有其他 JavaFX 属性适配器。`JavaBeanStringPropertyBuilder`支持以下方法:

```java
public static JavaBeanStringPropertyBuilder create()
public JavaBeanStringProperty build()
public JavaBeanStringPropertyBuilder name(java.lang.String)
public JavaBeanStringPropertyBuilder bean(java.lang.Object)
public JavaBeanStringPropertyBuilder beanClass(java.lang.Class<?>)
public JavaBeanStringPropertyBuilder getter(java.lang.String)
public JavaBeanStringPropertyBuilder setter(java.lang.String)
public JavaBeanStringPropertyBuilder getter(java.lang.reflect.Method)
public JavaBeanStringPropertyBuilder setter(java.lang.reflect.Method)

```

要使用构建器，首先调用它的静态方法`create()`。然后调用返回构建器本身的方法链。最后，调用`build()`方法来创建属性。大多数情况下，调用`bean()`和`name()`方法来指定 JavaBean 实例和属性名就足够了。`getter()`和`setter()`方法可以用来指定一个不遵循命名约定的 getter 和 setter。`beanClass()`方法可以用来指定 JavaBean 类。在构建器上预先设置 JavaBean 类允许您更有效地为同一个 JavaBean 类的多个实例的同一个 JavaBeans 属性创建适配器。

Note

尽管 JavaFX 场景、控件等类的构建器已经被弃用，但是`javafx.beans.property.adapter`包中的构建器并没有被弃用。它们是生成 JavaBeans 属性适配器所必需的。

清单 3-17 中的程序说明了将`Person`类的三个 JavaBeans 属性改编成`JavaBeanStringProperty`对象。

```java
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.adapter.JavaBeanStringProperty;
import javafx.beans.property.adapter.JavaBeanStringPropertyBuilder;

import java.beans.PropertyVetoException;

public class JavaBeanPropertiesExample {
    public static void main(String[] args) throws NoSuchMethodException {
        adaptJavaBeansProperty();
        adaptBoundProperty();
        adaptConstrainedProperty();
    }

    private static void adaptJavaBeansProperty() throws NoSuchMethodException {
        Person person = new Person();
        JavaBeanStringProperty nameProperty = JavaBeanStringPropertyBuilder.create()
            .bean(person)
            .name("name")
            .build();
        nameProperty.addListener((observable, oldValue, newValue) -> {
            System.out.println("JavaFX property " + observable + " changed:");
            System.out.println("\toldValue = " + oldValue + ", newValue = " + newValue);
        });

        System.out.println("Setting name on the JavaBeans property");
        person.setName("Stephen Chin");
        System.out.println("Calling fireValueChange");
        nameProperty.fireValueChangedEvent();
        System.out.println("nameProperty.get() = " + nameProperty.get());

        System.out.println("Setting value on the JavaFX property");
        nameProperty.set("Johan Vos");
        System.out.println("person.getName() = " + person.getName());
    }

    private static void adaptBoundProperty() throws NoSuchMethodException {
        System.out.println();
        Person person = new Person();
        JavaBeanStringProperty addressProperty = JavaBeanStringPropertyBuilder.create()
            .bean(person)
            .name("address")
            .build();
        addressProperty.addListener((observable, oldValue, newValue) -> {
            System.out.println("JavaFX property " + observable + " changed:");
            System.out.println("\toldValue = " + oldValue + ", newValue = " + newValue);
        });

        System.out.println("Setting address on the JavaBeans property");
        person.setAddress("12345 Main Street");
    }

    private static void adaptConstrainedProperty() throws NoSuchMethodException {
        System.out.println();
        Person person = new Person();
        JavaBeanStringProperty phoneNumberProperty = JavaBeanStringPropertyBuilder.create()
            .bean(person)
            .name("phoneNumber")
            .build();
        phoneNumberProperty.addListener((observable, oldValue, newValue) -> {
            System.out.println("JavaFX property " + observable + " changed:");
            System.out.println("\toldValue = " + oldValue + ", newValue = " + newValue);
        });

        System.out.println("Setting phoneNumber on the JavaBeans property");
        try {
            person.setPhoneNumber("800-555-1212");
        } catch (PropertyVetoException e) {
            System.out.println("A JavaBeans property change is vetoed.");
        }

        System.out.println("Bind phoneNumberProperty to another property");
        SimpleStringProperty stringProperty = new SimpleStringProperty("866-555-1212");
        phoneNumberProperty.bind(stringProperty);

        System.out.println("Setting phoneNumber on the JavaBeans property");
        try {
            person.setPhoneNumber("888-555-1212");
        } catch (PropertyVetoException e) {
            System.out.println("A JavaBeans property change is vetoed.");
        }
        System.out.println("person.getPhoneNumber() = " + person.getPhoneNumber());
    }
}

Listing 3-17.
JavaBeanPropertiesExamples.java

```

在`adaptJavaBeanProperty()`方法中，我们实例化了一个`Person` bean，并将其`name` JavaBeans 属性改编为 JavaFX `JavaBeanStringProperty`。为了帮助你理解什么时候一个`ChangeEvent`被传递到`nameProperty`，我们给它添加了一个`ChangeListener`(以 lambda 表达式的形式)。因为`name`不是一个绑定属性，当我们调用`person.setName()`时，`nameProperty`并不知道这个变化。为了通知`nameProperty`这个变化，我们调用它的`fireValueChangedEvent()`方法。当我们调用`nameProperty.get()`时，我们得到我们在`person` bean 上设置的名称。相反，在我们调用`nameProperty.set()`之后，对`person.getName()`的调用将返回我们在`nameProperty`上设置的内容。

在`adaptBoundProperty()`方法中，我们实例化了一个`Person` bean，并将其`address` JavaBeans 属性改编为 JavaFX `JavaBeanStringProperty`。为了帮助你理解什么时候一个`ChangeEvent`被传递到`addressProperty`，我们给它添加了一个`ChangeListener`(以 lambda 表达式的形式)。因为`address`是一个绑定属性，所以`addressProperty`被注册为`person` bean 的`PropertyChangeListener`；因此，当我们调用`person.setAddress()`时，会立即通知`addressProperty`，而无需我们调用`fireValuechangedEvent()`方法。

在`adaptConstrainedProperty()`方法中，我们实例化了一个`Person` bean，并将其`phoneNumber` JavaBeans 属性改编为`JavaBeanStringProperty`。我们再次添加了一个`ChangeListener`。因为`phoneNumber`是一个受约束的属性，`phoneNumberProperty`能够否决`person.setPhoneNumber()`调用。当这种情况发生时，`person.setPhoneNumber()`调用抛出一个`PropertyVetoException`。如果它本身绑定到另一个 JavaFX 属性，那么`phoneNumberProperty`将否决这样的更改。我们调用`person.setPhoneNumber()`两次，一次是在将`phoneNumberProperty`绑定到另一个 JavaFX 属性之前，一次是在绑定`phoneNumberProperty`之后。第一个调用成功地改变了`phoneNumberProperty`的值，第二个调用抛出了一个`PropertyVetoException`。

当我们运行清单 3-17 中的程序时，以下输出被打印到控制台:

```java
Setting name on the JavaBeans property
Calling fireValueChange
JavaFX property StringProperty [bean: Person@776ec8df, name: name, value: Stephen Chin] changed:
        oldValue = null, newValue = Stephen Chin
nameProperty.get() = Stephen Chin
Setting value on the JavaFX property
JavaFX property StringProperty [bean: Person@776ec8df, name: name, value: Johan Vos] changed:
        oldValue = Stephen Chin, newValue = Johan Vos
person.getName() = Johan Vos

Setting address on the JavaBeans property
JavaFX property StringProperty [bean: Person@41629346, name: address, value: 12345 main Street] changed:
        oldValue = null, newValue = 12345 main Street

Setting phoneNumber on the JavaBeans property
JavaFX property StringProperty [bean: Person@6d311334, name: phoneNumber, value: 800-555-1212] changed:
        oldValue = null, newValue = 800-555-1212
Bind phoneNumberProperty to another property
JavaFX property StringProperty [bean: Person@6d311334, name: phoneNumber, value: 866-555-1212] changed:
        oldValue = 800-555-1212, newValue = 866-555-1212
Setting phoneNumber on the JavaBeans property
A JavaBeans property change is vetoed.
person.getPhoneNumber() = 866-555-1212

```

## 摘要

在本章中，您学习了 JavaFX 属性和绑定框架的基础知识，以及 JavaFX Beans 规范。你现在应该明白下面的重要原则。

*   JavaFX 属性和绑定是框架的基础。
*   它们符合框架的关键接口。
*   它们触发两种事件:无效事件和变更事件。
*   框架提供的所有属性和绑定都延迟重新计算它们的值——只有在请求值时。为了迫使他们急切地重新评估，需要附上一个`ChangeListener`。
*   从现有的属性和绑定中以三种方式之一创建新的绑定:使用`Bindings`实用程序类的工厂方法，使用 fluent 接口 API，或者直接扩展抽象类的`IntegerBinding`系列。
*   JavaFX Beans 规范使用三种方法来定义属性:getter、setter 和属性 getter。
*   JavaFX Beans 属性可以通过急切、半懒惰和全懒惰策略来实现。
*   旧式 JavaBeans 属性可以很容易地适应 JavaFX 属性。

## 资源

以下是关于属性和绑定的有用资源。

*   马丁·福勒关于流畅接口 API 的文章: [`www.martinfowler.com/bliki/FluentInterface.html`](http://www.martinfowler.com/bliki/FluentInterface.html)
*   Oracle 的 JavaFX.com 上的属性和绑定教程: [`http://docs.oracle.com/javase/8/javafx/properties-binding-tutorial/`](http://docs.oracle.com/javase/8/javafx/properties-binding-tutorial/)
*   Michael Heinrichs 的博客包含了关于 JavaFX 属性和绑定的条目: [`http://blog.netopyr.com/`](http://blog.netopyr.com/)