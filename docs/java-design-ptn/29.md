# 二十九、常见问题

本章是本书所有章节中“问答”部分的子集。这些问题中有许多没有在某些章节中讨论，因为相关的模式还没有涉及到。因此，除了下面的问答，强烈建议您通读本书的所有“问答”部分，以便更好地理解所有模式。

1.  **你最喜欢哪种设计模式？**

    这取决于许多因素，如背景、情况、需求、制约因素等等。如果你知道所有的模式，你有更多的选择。

2.  开发人员为什么要使用设计模式？

    它们是对现实软件开发中反复出现的软件设计问题的可重用解决方案。

3.  **命令模式和纪念模式有什么区别？**

    命令模式存储所有的动作，但是记忆模式只在请求时保存状态。此外，命令模式对每个动作都有撤销和重做操作，但是 memento 模式不需要这样。

4.  **facade 模式和 builder 模式有什么区别？**

    facade 模式的目的是使代码的特定部分更容易使用。它从开发者那里抽象出细节。

    构建器模式将对象的构造与其表示分离开来。在第 3 章中，导演调用相同的`construct()`方法来创造不同类型的车辆。换句话说，您可以使用相同的构造过程来创建多种类型。

5.  **构建者模式和策略模式有什么区别？它们有相似的 UML 表示。**

    你首先需要理解意图。构建者模式属于创造模式的范畴，而策略模式属于行为模式的范畴。他们关注的领域不同。使用构建器模式，您可以使用相同的构造过程来创建多种类型，而使用策略模式，您可以在运行时自由选择算法。

6.  **命令模式和解释器模式有什么区别？**

    在命令模式中，命令基本上是对象。在解释器模式中，命令是句子。有时候解释器模式可能看起来很方便，但是您必须记住构建一个解释器的成本。

7.  责任链模式和观察者模式有什么区别？

    在 observer 模式中，所有注册用户都被并行通知/获取请求(主题的更改),但是在 chain-of-responsibility 模式中，您可能没有到达 chain 的末端，所以所有用户不需要处理相同的场景。位于链开始的用户可以更早地处理请求。

8.  责任链模式和装饰者模式有什么区别？

    它们一点也不相同，但你可能会觉得它们在结构上很相似。与前面的区别类似，在责任链模式中，只有一个类处理请求，但是在装饰器模式中，所有的类都处理请求。您必须记住，装饰器只在添加和删除责任的上下文中有效，如果您可以将装饰器模式与单一责任原则结合起来，您就可以在运行时添加/删除单一责任。

9.  **调解人模式和观察者模式有什么区别？**

    GoF 说，“这些是竞争模式。它们之间的区别在于，观察者通过引入观察者和主体对象来分发通信，而中介对象封装了其他对象之间的通信。”我建议你考虑一下第 21 章中的中介模式例子。在这个例子中，两个工人总是从他们的老板那里得到信息。他们是否喜欢这些信息并不重要。但是如果他们只是简单的观察者，那么他们应该可以取消他们老板对他们的控制，有效地说“我不想看到来自老板/Raghu 的消息。”

    GoF 还发现，与制作可重用的中介相比，当你制作可重用的观察者和主体时，你可能会面临更少的挑战。但是关于交流的流程，中介模式比观察者模式得分更高。

10.  单例类和静态类，你更喜欢哪一个？

    首先要记住的是，Java 不支持顶级静态类。您可以创建单例类的对象，这在静态类中是不可能的。因此，继承和多态的概念可以用单例类来实现。现在让我们考虑一种支持全阶段静态类的语言(比如 C#)。在这种情况下，一些开发人员认为在现实世界的应用程序中模仿静态类(例如，考虑单元测试场景)是具有挑战性的。

11.  如何区分代理和适配器？

    代理在与它们的主体相似的接口上工作，但是适配器在不同的接口上工作(对于它们所适应的对象)。

12.  代理和装饰者有什么不同？

    有不同类型的代理，它们因实现而异。因此，看起来有些实现接近装饰者。例如，保护代理可以像装饰器一样实现。但是你必须记住，装饰者专注于增加责任，而代理者专注于控制对对象的访问。

13.  中介和门面有什么不同？

    总的来说，两者都简化了复杂的系统。在中介模式中，中介和内部子系统之间存在双向连接，而在外观模式中，您提供单向连接(子系统不知道外观)。

14.  享元模式和状态模式之间有什么联系吗？

    GoF 说 flyweight 模式可以帮助你决定*何时以及如何*共享状态对象。

15.  简单工厂、工厂方法和抽象工厂设计模式之间有什么相似之处？

    它们都封装了对象创建。他们建议你编写抽象(接口)代码，而不是具体的类。这些工厂中的每一个都通过减少对具体类的依赖来促进松散耦合。

16.  简单工厂、工厂方法和抽象工厂设计模式有什么区别？

    这是你在各种工作面试中可能会面临的一个重要问题。建议你看清楚。所以，参考第 [5](05.html) 章“问答环节”第 3 题的回答。

17.  如何区分单例模式和工厂方法模式？

    单例模式确保您每次都能获得一个唯一的实例。它还限制创建其他实例。

    但是工厂方法模式并没有说你只能得到一个唯一的实例。大多数情况下，这种模式用于创建任意多的实例，并且这些实例不一定是唯一的。这些新类型化的实例可以实现一个公共基类。(还记得*工厂方法让一个类将实例化推迟到 GoF 定义中的子类*吗？)

18.  如何区分构建者模式和原型模式？

    在原型模式中，您使用的是克隆/复制机制。因此，在最后，您可能想要覆盖最初的实现(注意在我们的 Ford 类和 Nano 类的实现中的单词 *@override* )。但是改变遗留(或原始)代码并不总是容易的。

    除了这一点，当您使用克隆机制时，您不需要考虑具有不同参数的构造函数。

    但是在构建器模式实现中，使用带有不同参数的构造器是很常见的。

19.  如何区分访问者模式和策略模式？

    在策略模式中，每个子类使用不同的算法来解决一个共同的问题。但是在访问者设计模式中，每个访问者子类可能提供不同的功能。

20.  空对象和代理有什么不同？

    一般来说，代理在某些时候作用于真实对象，它们也可以提供行为。但是空对象不做任何这样的操作。

21.  如何区分解释者模式和访问者模式？

    在解释器模式中，您将简单的语法表示为对象结构，但是在访问者模式中，您定义了想要在对象结构上使用的特定操作。除此之外，解释器可以直接访问所需的属性，但是在访问者模式中，您需要特殊的功能(类似于观察者)来访问它们。

22.  如何区分 flyweight 模式和对象池模式？

    我没有在本书中讨论对象池模式。但是如果你已经了解了对象池模式，你会注意到在 flyweight 模式中，flyweight 有内部和外部状态。因此，如果一个 flyweight 有两种状态，那么这两种状态是分开的，客户端需要将状态的一部分传递给它。此外，一般而言，客户端不会更改固有状态，因为它是共享的。

    对象池模式不存储外部状态的任何部分；所有状态信息都存储/封装在池化对象中。此外，客户端可以更改池化对象的状态。

23.  库(或框架)与设计模式有什么相似/不同之处？

    它们不是设计模式。它们提供了可以直接在应用程序中使用的实现。但是他们可以在那些实现中使用模式的概念。