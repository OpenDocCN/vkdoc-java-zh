# 9.用 Gson 解析和创建 JSON 对象

Gson 是用于解析和创建 JSON 对象的另一个 API。本章探索了这个开源谷歌产品的最新版本。

## Gson 是什么？

Gson(也称为 Google Gson)是一个基于 Java 的小型库，用于解析和创建 JSON 对象。谷歌为自己的项目开发了 Gson，但后来从 1.0 版本开始，Gson 公开可用。根据维基百科，最新版本(在撰写本文时)是 2.6.1。

Gson 的开发目标如下:

*   提供简单的`toJson()`和`fromJson()`方法将 Java 对象转换成 JSON 对象，反之亦然。
*   允许预先存在的不可修改对象与 JSON 相互转换。
*   为 Java 泛型提供广泛的支持。
*   允许对象的自定义表示。
*   支持任意复杂的对象(具有深度继承层次和广泛使用泛型类型)。

Gson 通过将 JSON 对象反序列化为 Java 对象来解析 JSON 对象。类似地，它通过将 Java 对象序列化为 JSON 对象来创建 JSON 对象。Gson 依靠 Java 的反射 API 来协助序列化和反序列化。

### 获取和使用 Gson

Gson 作为单个 Jar 文件分发；`gson-2.6.1.jar`是编写时最新的 Jar 文件。要获取这个 Jar 文件，将浏览器指向 [`http://search.maven.org/#artifactdetails|com.google.code.gson|gson|2.6.1|jar`](http://search.maven.org/#artifactdetails%7Ccom.google.code.gson%7Cgson%7C2.6.1%7Cjar) ，从页面底部附近的列表中选择`gson-2.6.1.jar`，并下载。另外，您可能想下载`gson-2.6.1-javadoc.jar`，它包含这个 API 的 Javadoc。

Note

Gson 根据 Apache 许可证版本 2.0 ( [`www.apache.org/licenses/`](http://www.apache.org/licenses/) )进行许可。

使用`gson-2.6.1.jar`很容易。编译源代码或运行应用程序时，只需将它包含在类路径中，如下所示:

```java
javac -cp gson-2.6.1.jar source file

java -cp gson-2.6.1.jar;. main classfile

```

## 探索 GSon

Gson 由 30 多个类和接口组成，分布在四个包中:

*   `com.google.gson`:这个包提供了对`Gson`的访问，它是使用 Gson 的主类。
*   `com.google.gson.annotations`:这个包提供了与 Gson 一起使用的注释类型。
*   这个包提供了一个从泛型类型中获取类型信息的工具类。
*   `com.google.gson.stream`:这个包提供了用于读写 JSON 编码值的实用程序类。

在本节中，我首先向您介绍`Gson`类。然后，我将重点放在`Gson`反序列化(解析 JSON 对象)和`Gson`序列化(创建 JSON 对象)上。最后，我简要讨论了 Gson 的其他特性，比如注释和类型适配器。

### Gson 类简介

`Gson`类处理 JSON 和 Java 对象之间的转换。您可以通过使用`Gson()`构造函数实例化这个类，或者通过使用`com.google.gson.GsonBuilder`类获得一个`Gson`实例。以下代码片段演示了这两种方法:

```java
Gson gson1 = new Gson();
Gson gson2 = new GsonBuilder()
     .registerTypeAdapter(Id.class, new IdTypeAdapter())
     .serializeNulls()
     .setDateFormat(DateFormat.LONG)
     .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)
     .setPrettyPrinting()
     .setVersion(1.0)
     .create();

```

当您想要使用默认配置时调用`Gson()`，当您想要覆盖默认配置时使用`GsonBuilder`。配置方法调用被链接在一起，最后调用`GsonBuilder`的`Gson` `create()`方法以返回结果`Gson`对象。

`Gson`支持以下默认配置(列表不完整；查看`Gson`和`GsonBuilder`文档了解更多信息):

*   `Gson`为`java.lang.Enum`、`java.util.`、[、`Map`、](http://docs.oracle.com/javase/6/docs/api/java/util/Map.html?is-external=true#class%20or%20interface%20in%20java.util)[、`URL`、](http://docs.oracle.com/javase/6/docs/api/java/net/URL.html?is-external=true#class%20or%20interface%20in%20java.net)、`java.net.`、`URI`、、`java.util.`、[、`Locale`、](http://docs.oracle.com/javase/6/docs/api/java/util/Locale.html?is-external=true#class%20or%20interface%20in%20java.util)、`java.util.`、[、`Date`、`java.math.`、](http://docs.oracle.com/javase/6/docs/api/java/util/Date.html?is-external=true#class%20or%20interface%20in%20java.util)[、`BigDecimal`、`java.math.`、](http://docs.oracle.com/javase/6/docs/api/java/math/BigDecimal.html?is-external=true#class%20or%20interface%20in%20java.math)[、`BigInteger`、](http://docs.oracle.com/javase/6/docs/api/java/math/BigInteger.html?is-external=true#class%20or%20interface%20in%20java.math)实例提供了默认的序列化和反序列化。您可以通过`GsonBuilder.registerTypeAdapter(Type, Object)`注册一个类型适配器(稍后讨论)来改变默认表示。
*   生成的 JSON 文本省略了所有的`null`字段。然而，它在数组中保留了`null` s，因为数组是一个有序列表。同样，如果一个字段不是`null`，但是它生成的 JSON 文本是空的，那么这个字段将被保留。您可以通过调用`GsonBuilder.serializeNulls()`配置`Gson`来序列化`null`值。
*   默认`Date`格式与`java.text.` [`DateFormat.DEFAULT`](http://docs.oracle.com/javase/6/docs/api/java/text/DateFormat.html?is-external=true#DEFAULT%23class%20or%20interface%20in%20java.text) 相同。这种格式在序列化过程中忽略日期的毫秒部分。您可以通过调用`GsonBuilder.setDateFormat(int)`或`GsonBuilder.setDateFormat(String)`来更改默认格式。
*   输出 JSON 文本的默认字段命名策略与 Java 中的相同。例如，一个名为`versionNumber`的 Java 类字段在 JSON 中将被输出为`"versionNumber"`。同样的规则也适用于将传入的 JSON 映射到 Java 类。您可以通过调用`GsonBuilder.setFieldNamingPolicy(FieldNamingPolicy` `)`来更改此策略。
*   由`toJson()`方法生成的 JSON 文本被简洁地表示出来:所有不需要的空白都被删除。您可以通过调用`GsonBuilder.setPrettyPrinting()`来改变这种行为。
*   默认情况下，`Gson`忽略`@` `Since`和`@Until`标注。您可以通过调用`GsonBuilder.setVersion(double)`来启用`Gson`使用这些注释。
*   默认情况下，`Gson`忽略`@` `Expose`标注。您可以通过调用`GsonBuilder.excludeFieldsWithoutExposeAnnotation()`使`Gson`只序列化/反序列化那些用这个注释标记的字段。
*   默认情况下，`Gson`将`transient`或`static`字段排除在序列化和反序列化考虑之外。您可以通过调用`GsonBuilder.excludeFieldsWithModifiers(int...)`来改变这种行为。

一旦有了一个`Gson`对象，就可以调用各种`fromJson()`和`toJson()`方法在 JSON 和 Java 对象之间进行转换。例如，清单 [9-1](#Par33) 给出了一个简单的应用程序，它获得了一个`Gson`对象，并根据 JSON 原语演示了 JSON-Java 对象转换。

```java
 import com.google.gson.Gson;

public class GsonDemo
{
   public static void main(String[] args)
   {
      Gson gson = new Gson();
      String name = gson.fromJson("\"John Doe\"", String.class);
      System.out.println(name);
      gson.toJson(256, System.out);
   }

}

Listing 9-1.Converting Between JSON and Java Primitives

```

清单 [9-1](#Par33) 的`main()`方法首先实例化`Gson`，保持其默认配置。然后，它调用`Gson`的`<T> T fromJson(String json, Class<T> classOfT)`泛型方法将指定的基于`java.lang.String`的 JSON 文本(在`json`中)反序列化为指定类的对象(`classOfT`)，这个对象恰好是`String`。

JSON 字符串`"John Doe"`(双引号是必需的)，被表示为 Java `String`对象，被转换(去掉双引号)为 Java `String`对象。对该对象的引用被分配给`name`。

在输出返回的名字后，`main()`调用`Gson`的`void toJson(Object src, Appendable writer)`方法将自动装箱的整数`256`(由编译器存储在`java.lang.Integer`对象中)转换成 JSON 整数，并将结果输出到标准输出流。

编译清单 [9-1](#Par33) 如下:

```java
javac -cp gson-2.6.1.jar GsonDemo.java

```

运行生成的应用程序，如下所示:

```java
java -cp gson-2.6.1.jar;. GsonDemo

```

您应该观察到以下输出:

```java
John Doe

256

```

产量并不可观，但这是一个开始。在接下来的两节中，您将看到更多有用的反序列化和序列化示例。

### 通过反序列化解析 JSON 对象

除了将 JSON 原语(比如数字或字符串)解析成它们的 Java 等价物之外，`Gson`还允许您将 JSON 对象解析成 Java 对象。例如，假设您有下面的 JSON 对象，它描述了一个人:

```java
{ "name": "John Doe", "age": 45 }

```

此外，假设您有以下 Java 类:

```java
class Person
{
   String name;
   int age;
}

```

您可以使用前面的`fromJson()`方法将 JSON 对象解析成`Person`类的实例，如清单 [9-2](#Par49) 所示。

```java
import com.google.gson.Gson;

public class GsonDemo
{
   static class Person
   {
      String name;
      int age;

      Person(String name, int age)
      {
         this.name = name;
         this.age = age;
      }

      @Override
      public String toString()
      {
         return name + ": " + age;
      }
   }

   public static void main(String[] args)
   {
      Gson gson = new Gson();
      String json = "{ name: \"John Doe\", age: 45 }";
      Person person = gson.fromJson(json, Person.class);
      System.out.println(person);
   }
}

Listing 9-2.Parsing a JSON Object into a Java Object

```

清单 [9-2](#Par49) 声明了一个`GsonDemo`类和一个嵌套的`Person`类，后者根据姓名和年龄描述了一个人。

`GsonDemo`的`main()`方法首先实例化`Gson`，保持其默认配置。然后，它构造一个基于`String`的 JSON 对象来表示一个人，并将该对象与`Person.class`一起传递给`fromJson(String json, Class<T> classOfT). fromJson()`，解析存储在传递给`json`的字符串中的姓名和年龄，并使用`Person.class`和反射 API 来创建一个`Person`对象，并用姓名和年龄填充它。对`Person`对象的引用被返回并存储在`person`变量中，随后被传递给`System.out.println()`。这个方法最终调用`Person`的`toString()`方法来返回`Person`对象的字符串表示，然后将这个字符串写入标准输出流。

编译清单 [9-2](#Par49) 并运行生成的应用程序。您应该观察到以下输出:

```java
John Doe: 45

```

#### 定制的 JSON 对象解析

前面的`gson.fromJson(json, Person.class)`方法调用依赖于`Gson`的默认反序列化机制来解析 JSON 对象。您经常会遇到需要将复杂的 JSON 对象解析成 Java 对象的情况，这些 Java 对象的类与要解析的 JSON 对象的结构不同。您可以使用定制的反序列化器来执行这种解析，反序列化器控制 JSON 对象如何映射到 Java 对象。

`com.google.gson.JsonDeserializer<T>`接口描述了一个定制的反序列化器。传递给`T`的参数标识了反序列化器所使用的类型。例如，当需要解析结构稍有不同的 JSON 对象时，可以将`Person`传递给`T`。

`JsonDeserializer`声明一个处理反序列化的方法(JSON 对象解析):

```java
T deserialize(JsonElement json,Type typeOfT,
              JsonDeserializationContext context)

```

`deserialize()`是`Gson`在反序列化过程中调用的回调方法。使用以下参数调用此方法:

*   `json`标识被反序列化的 JSON 元素。
*   `typeOfT`标识要反序列化的 Java 对象的类型`json`。
*   `context`标识执行反序列化的上下文。(我将在后面详细介绍上下文。)

当传递给`json`的 JSON 元素与传递给`typeOfT`的类型不兼容时`deserialize()`抛出`com.google.gson.JsonParseException`。因为`JsonParseException`扩展了 [`java.lang.RuntimeException`](http://docs.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html?is-external=true#class%20or%20interface%20in%20java.lang) ，所以不用追加`throws`子句。

About Jsonelement

`com.google.gson.JsonElement`类表示一个 JSON 元素(比如一个数字、一个布尔值或者一个数组)。它提供了多种获取元素值的方法，如`double getAsDouble()`、`boolean getAsBoolean()`和`JsonArray getAsJsonArray()`。

`JsonElement`是一个抽象类，作为以下 JSON 元素类的超类(在`com.google.gson`包中):

*   `JsonArray`:表示 JSON 的数组类型的具体类。一个数组是一组`JsonElement`的列表，每一个都可以是不同的类型。这是一个有序列表，意味着元素添加的顺序是保留的。
*   `JsonNull`:表示 JSON `null`值的具体类。
*   `JsonObject`:表示 JSON 对象类型的具体类。一个对象由名称-值对组成，其中名称是字符串，值是任何其他类型的`JsonElement`，这导致了一个`JsonElement`的树。
*   `JsonPrimitive`:表示 JSON 的数字、字符串或布尔类型之一的具体类。

除了`JsonNull`，这些子类都提供了各种获取元素值的方法。

创建一个`JsonDeserializer`对象后，需要用`Gson`注册它。通过调用下面的`GsonBuilder`方法来完成这个任务:

```java
GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) 

```

传递给`type`的对象标识了解串器的类型，传递给`typeAdapter`的对象标识了解串器。因为`registerTypeAdapter(Type, Object)`返回一个`GsonBuilder`对象，所以只能在`GsonBuilder`上下文中使用这个方法。

为了演示定制的 JSON 对象解析，考虑前面的 JSON 对象的扩展版本:

```java
{ "first-name": "John", "last-name": "Doe", "age": 45, "address": "Box 1 " }

```

这个 JSON 对象与之前的 JSON 对象有很大的不同，之前的 JSON 对象由`name`和`age`字段组成:

*   字段`name`已经被重构为`first-name`和`last-name`字段。注意，连字符(`-`)不是 Java 标识符的合法字符。
*   添加了一个`address`字段。

如果您通过用这个新对象替换分配给`json`的对象来修改清单 [9-2](#Par49) ，您应该不会对下面的输出感到惊讶:

```java
null: 45

```

解析完全混乱了。但是，您可以通过引入以下自定义反序列化程序来解决此问题:

```java
class PersonDeserializer implements JsonDeserializer<Person>
{
   @Override
   public Person deserialize(JsonElement json, Type typeOfT,  JsonDeserializationContext context)
   {
      JsonObject jsonObject = json.getAsJsonObject();
      String firstName = jsonObject.get("first-name").getAsString();
      String lastName = jsonObject.get("last-name").getAsString();
      int age = jsonObject.getAsJsonPrimitive("age").getAsInt();
      String address = 

jsonObject.get("address").getAsString();
      return new Person(firstName + " " + lastName, 45);
   }
}

```

当定制的反序列化器与之前的 JSON 对象一起使用时，`deserialize()`只被调用一次，并且类型为`JsonObject`的对象被传递给`json`。您可以将这个值转换成一个`JsonObject`，就像在`JsonObject jsonObject = (JsonObject) json;`中一样。或者，您可以调用`JsonElement`的`JsonObject` `getAsJsonObject()`方法来获取`JsonObject`引用，这是`deserialize()`首先要完成的。

获得`JsonObject`引用后，`deserialize()`调用其`JsonElement` `get(` [`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang) `memberName)`方法返回一个`JsonElement`作为所需的`memberName`值。第一个调用从`first-name`传递到`get()`；您希望获得这个 JSON 字段的值。因为返回一个`JsonPrimitive`来代替`JsonElement`，所以对`JsonPrimitive`的 [`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang) `getAsString()`方法的调用被链接到`JsonPrimitive`引用，并获得`first-name`的值。按照这种模式获取`last-name`和`address`字段的值。

为了多样化，我决定在`age`领域做一些不同的事情。我调用`JsonObject`的`JsonPrimitive` `getAsJsonPrimitive(` [`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang) `memberName)`方法返回一个`JsonPrimitive`引用对应`age`。然后，我调用`JsonPrimitive`的`int getAsInt()`方法返回整数值。

获得所有字段值后，创建并返回一个`Person`对象。因为我重用了清单 [9-2](#Par49) 中所示的`Person`类，并且因为这个类中没有`address`字段，所以我丢弃了`address`的值。您可能想要修改`Person`来包含这个字段。

下面的代码片段展示了如何实例化`PersonDeserializer`并用`GsonBuilder`实例注册它，该实例也用于获取`Gson`实例，以便调用`fromJson()`，通过 person 反序列化器解析之前的 JSON 对象:

```java
GsonBuilder gsonBuilder = new GsonBuilder();
gsonBuilder.registerTypeAdapter(Person.class, new PersonDeserializer());
Gson gson = gsonBuilder.create();

```

我已经将这些代码片段组合成一个工作应用程序。清单 [9-3](#Par89) 展示了应用程序的源代码。

```java
import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

public class GsonDemo
{
   static class Person
   {
      String name;
      int age;

      Person(String name, int age)
      {
         this.name = name;
         this.age = age;
      }

      @Override
      public String toString()
      {
         return name + ": " + age;
      }
   }

   public static void main(String[] args)
   {
      class PersonDeserializer implements JsonDeserializer<Person>
      {
         @Override
         public Person deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
         {
            JsonObject jsonObject = json.getAsJsonObject();
            String firstName = jsonObject.get("first-name").getAsString();
            String lastName = jsonObject.get("last-name").getAsString();
            int age = jsonObject.getAsJsonPrimitive("age").getAsInt();
            String address = jsonObject.get("address").getAsString();
            return new Person(firstName + " " + lastName, 45);
         }
      }
      GsonBuilder gsonBuilder = new GsonBuilder();
      gsonBuilder.registerTypeAdapter(Person.class, new PersonDeserializer());
      Gson gson = gsonBuilder.create();
      String json = "{ first-name: \"John\", last-name: \"Doe\", " + "age: 45, address: \"Box 1\" }";
      Person person = gson.fromJson(json, Person.class);
      System.out.println(person);
   }
}

Listing 9-3.Parsing a JSON Object into a Java Object via a Custom Deserializer

```

编译清单 [9-3](#Par89) 并运行生成的应用程序。您应该观察到以下输出:

```java
John Doe: 45

```

### 通过序列化创建 JSON 对象

`Gson`让您通过调用`Gson`的`toJson()`方法之一，从 Java 对象创建 JSON 对象。清单 9-4 提供了一个简单的演示。

```java
import com.google.gson.Gson;

public class GsonDemo
{
   static class Person
   {
      String name;
      int age;

      Person(String name, int age)
      {
         this.name = name;
         this.age = age;
      }
   }

   public static void main(String[] args)
   {
      Person p = new Person("Jane Doe", 59);
      Gson gson = new Gson();
      String json = gson.toJson(p);
      System.out.println(json);
   }
}

Listing 9-4.Creating a JSON Object from a Java Object

```

清单 [9-4](#Par93) 的`main()`方法首先从嵌套的`Person`类创建一个`Person`对象。然后它创建一个`Gson`对象，并调用该对象的[`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang)`toJson(`[`Object`](http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#class%20or%20interface%20in%20java.lang)`src)`方法将`Person`对象序列化为其等效的 JSON 字符串表示，由`toJson(Object)`返回。

编译清单 [9-4](#Par93) 并运行生成的应用程序。您应该观察到以下输出:

```java
{"name":"Jane Doe","age":59}

```

如果您更喜欢将 JSON 对象写到文件、字符串缓冲区或其他一些`java.lang.Appendable`中，您可以调用`void toJson(Object src, Appendable writer)`来完成这项任务。这个`toJson()`变体将其输出发送到指定的`writer`，如清单 [9-5](#Par98) 所示。

```java
import java.io.FileWriter;
import java.io.IOException;

import com.google.gson.Gson;

public class GsonDemo
{
   static class Student
   {
      String name;
      int id;
      int[] grades;

      Student(String name, int id, int... grades)
      {
         this.name = name;
         this.id = id;
         this.grades = grades;
      }

   }

   public static void main(String[] args) throws IOException
   {
      Student s = new Student("John Doe", 820787, 89, 78, 97, 65);
      Gson gson = new Gson();
      FileWriter fw = new FileWriter("student.json");
      gson.toJson(s, fw);
      fw.close();
   }
}

Listing 9-5.Creating a JSON Object from a Java Object and Writing the JSON Object to a File

```

清单 [9-5](#Par98) 的`main()`方法首先从嵌套的`Student`类中创建一个`Student`对象。然后创建`Gson`和`java.io.FileWriter`对象，并调用`Gson`对象的`toJson(` [`Object`](http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#class%20or%20interface%20in%20java.lang) `, Appendable)`方法将`Student`对象序列化为其等效的 JSON 字符串表示，并将结果写入`student.json`。然后关闭文件写入器，以便将缓冲的内容写入文件(您可以改为指定`fw.flush();`)。

如果您运行这个应用程序，您将不会观察到任何输出。但是，您应该观察到一个包含以下内容的`student.json`文件:

```java
{"name":"John Doe","id":820787,"grades":[89,78,97,65]}

```

Note

当出现 I/O 错误时，`void toJson(Object src, Appendable writer)`抛出未检查的`com.google.gson.JsonIOException`。

#### 定制的 JSON 对象创建

前面的`gson.toJson(p)`和`gson.` `toJson` `(s, fw)`方法调用依靠`Gson`的默认序列化机制来创建 JSON 对象。您经常会遇到需要从 Java 对象创建 JSON 对象的情况，这些 Java 对象的类与要创建的 JSON 对象的结构不同。您可以使用定制的序列化程序来执行这种创建，它控制 Java 对象如何映射到 JSON 对象。

`com.google.gson.JsonSerializer<T>`接口描述了一个定制的串行化器。传递给`T`的参数标识了正在使用的序列化程序的类型。例如，当需要创建结构稍有不同的 JSON 对象时，可以将`Person`传递给`T`。

`JsonSerializer`声明一个处理序列化(JSON 对象创建)的方法:

```java
JsonElement serialize(T src, Type typeOfSrc,
                      JsonSerializationContext context)

```

`serialize()`是`Gson`在序列化过程中调用的回调方法。使用以下参数调用此方法:

*   `src`标识需要序列化的 Java 对象。
*   `typeOfSrc`标识由`src`指定的要序列化的 Java 对象的实际类型。
*   `context`标识执行序列化的上下文。(我将在后面详细介绍上下文。)

创建一个`JsonSerializer`对象后，需要用`Gson`注册它。通过调用下面的`GsonBuilder`方法来完成这个任务:

```java
GsonBuilder registerTypeAdapter(Type type, Object typeAdapter)

```

传递给`type`的对象标识串行器的类型，传递给`typeAdapter`的对象标识串行器。因为`registerTypeAdapter(Type, Object)`返回一个`GsonBuilder`对象，所以只能在`GsonBuilder`上下文中使用这个方法。

为了演示定制的 JSON 对象创建，考虑清单 [9-6](#Par115) 中的`Book`类。

```java
public class Book
{
   private String title;
   private String[] authors;
   private String isbn10;
   private String isbn13;

   public Book(String title, String[] authors, String isbn10, String isbn13)
   {
      this.title = title;
      this.authors = authors;
      this.isbn10 = isbn10;
      this.isbn13 = isbn13;
   }

   public String getTitle()
   {
      return title;
   }

   public String[] getAuthors()
   {
      return authors;
   }

   public String getIsbn10()
   {
      return isbn10;
   }

   public String getIsbn13()
   {
      return isbn13;
   }
}

Listing 9-6.Describing a Book as a Title, List of Authors, and ISBN Numbers

```

继续，假设`Book`对象将被序列化为具有以下格式的 JSON 对象:

```java
{
   "title": title

   "lead-author": author0

   "other-authors": [ author1, author2, ... ]
   "isbn-10": isbn10

   "isbn-13": isbn13

}

```

您不能使用默认序列化，因为`Book`类没有声明`lead-author`、`other-authors`、`isbn-10`和`isbn-13`字段。在任何情况下，缺省序列化都会创建与 Java 类的字段名相匹配的 JSON 属性名(对于 Java 标识符，连字符是非法的)。为了证明您无法使用默认序列化获得所需的 JSON 对象，假设您尝试执行以下代码片段:

```java
Book book = new Book("PHP and MySQL Web Development, Second Edition", new String[] { "Luke Welling", "Laura Thomson" }, "067232525X", "075-2063325254");
Gson gson = new Gson();
System.out.println(gson.toJson(book));

```

此代码片段生成以下输出:

```java
{"title":"PHP and MySQL Web Development, Second Edition","authors":["Luke Welling","Laura Thomson"],"isbn10":"067232525X","isbn13":"075-2063325254"}

```

输出与预期的 JSON 对象不匹配。但是，您可以通过引入以下自定义序列化程序来解决此问题:

```java
class BookSerializer implements JsonSerializer<Book>
{
   @Override
   public JsonElement serialize(Book src, Type typeOfSrc,                                 JsonSerializationContext context)
   {
      JsonObject jsonObject = new JsonObject();
      jsonObject.addProperty("title", src.getTitle());
      jsonObject.addProperty("lead-author", src.getAuthors()[0]);
      JsonArray jsonOtherAuthors = new JsonArray();
      for (int i = 1; i < src.getAuthors().length; i++)
      {

         JsonPrimitive jsonAuthor =
            new JsonPrimitive(src.getAuthors()[i]);
         jsonOtherAuthors.add(jsonAuthor);
      }
      jsonObject.add("other-authors", jsonOtherAuthors);
      jsonObject.addProperty("isbn-10", src.getIsbn10());
      jsonObject.addProperty("isbn-13", src.getIsbn13());
      return jsonObject;
   }
}

```

当自定义序列化程序与之前的 Java `Book`对象一起使用时，`serialize()`只被调用一次，而`Book`对象被传递给`src`。因为这个方法需要一个 JSON 对象，`serialize()`首先创建一个`JsonObject`实例。

`JsonObject`声明了几个`addProperty()`方法，用于向一个`JsonObject`实例表示的 JSON 对象添加属性。`serialize()`调用`void addProperty(`[`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang)`property,`[`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang)`value)`方法添加`title`、`lead-author`、`isbn-10`和`isbn-13`属性。

`other-authors`属性的处理方式不同。首先，`serialize()`创建一个`JsonArray`实例，并用除第一作者之外的所有作者填充它。然后，调用`JsonObject`的`void add(` [`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang) `property,` `JsonElement` `value)`方法将`JsonArray`对象添加到`JsonObject`中。

序列化完成后，`serialize()`返回创建并填充的`JsonObject`。

下面的代码片段展示了如何实例化`BookSerializer`并用一个`GsonBuilder`实例注册它，该实例也用于获得一个`Gson`实例以便调用`toJson()`，通过图书序列化程序创建所需的 JSON 对象:

```java
GsonBuilder gsonBuilder = new GsonBuilder();
gsonBuilder.registerTypeAdapter(Book.class, new BookSerializer());

Gson gson = gsonBuilder.create();

```

我已经将这些代码片段组合成一个工作应用程序。清单 [9-7](#Par131) 展示了应用程序的源代码。

```java
import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class GsonDemo
{
   public static void main(String[] args)
   {
      class BookSerializer implements JsonSerializer<Book>
      {
         @Override
         public JsonElement serialize(Book src, Type typeOfSrc, JsonSerializationContext context)
         {
            JsonObject jsonObject = new JsonObject();
            jsonObject.addProperty("title", src.getTitle());
            jsonObject.addProperty("lead-author", src.getAuthors()[0]);
            JsonArray jsonOtherAuthors = new JsonArray();
            for (int i = 1; i < src.getAuthors().length; i++)
            {
               JsonPrimitive jsonAuthor =
                  new JsonPrimitive(src.getAuthors()[i]);
               jsonOtherAuthors.add(jsonAuthor);
            }
            jsonObject.add("other-authors", jsonOtherAuthors); 

            jsonObject.addProperty("isbn-10", src.getIsbn10());
            jsonObject.addProperty("isbn-13", src.getIsbn13());
            return jsonObject;
         }
      }
      GsonBuilder gsonBuilder = new GsonBuilder();
      gsonBuilder.registerTypeAdapter(Book.class, new BookSerializer());
      Gson gson = gsonBuilder.setPrettyPrinting().create();
      Book book = new Book("PHP and MySQL Web Development, Second Edition", new String[] { "Luke Welling", "Laura Thomson" }, "067232525X", "075-2063325254");
      System.out.println(gson.toJson(book));
   }
}

Listing 9-7.Creating a JSON Object from a Java Object via a Custom Serializer

```

编译清单 [9-7](#Par131) 并运行生成的应用程序。您应该观察到下面的输出，它已经被漂亮地打印出来(通过对`GsonBuilder`对象的`setPrettyPrinting()`方法调用)以使输出更加清晰:

```java
{
  "title": "PHP and MySQL Web Development, Second Edition",
  "lead-author": "Luke Welling",
  "other-authors": [
    "Laura Thomson"
  ],
  "isbn-10": "067232525X",
  "isbn-13": "075-2063325254"
}

```

### 了解更多关于 Gson 的信息

现在您已经对 Gson 库的基础有了相当好的理解，您可能想了解这个库提供的其他特性。在这一节中，我将向您介绍注释、上下文、Gson 对泛型的支持以及类型适配器。

Note

我对 Gson 其他特性的介绍并不详尽。查看“Gson 用户指南”( [`https://github.com/google/gson/blob/master/UserGuide.md`](https://github.com/google/gson/blob/master/UserGuide.md) )来了解我没有涉及的主题，比如实例创建者。

#### 释文

Gson 提供了几种注释类型(在`com.google.gson.annotations`包中)来简化序列化和反序列化:

*   `Expose`:向 Gson 的序列化和/或反序列化机制暴露或隐藏带注释的字段。
*   `JsonAdapter`:标识与类或字段一起使用的类型适配器。(我将在以后关注类型适配器时讨论这种注释类型。)
*   `SerializedName`:表示应该将带注释的字段或方法序列化为 JSON，并将提供的名称值作为其名称。
*   `Since`:标识序列化字段或类型的起始版本号。如果创建的`Gson`对象的版本号小于`@Since`注释中的值，那么带注释的字段/类型将不会被序列化。
*   `Until`:标识序列化字段或类型的结束版本号。如果创建的`Gson`对象的版本号等于或大于`@Until`注释中的值，那么带注释的字段/类型将不会被序列化。

Note

根据 Gson 文档，`Since`和`Until`对于在 web 服务上下文中管理 JSON 类的版本非常有用。

##### 显示和隐藏字段

默认情况下，`Gson`不会序列化和反序列化标记为`transient`(或`static`)的字段。你可以调用`GsonBuilder`的`GsonBuilder excludeFieldsWithModifiers(int... modifiers)`方法来改变这种行为。另外，`Gson`允许您通过使用`Expose`注释类型的实例来注释这些字段，从而有选择地确定要序列化和/或反序列化哪些非`transient`字段。

`Expose`提供了以下元素，用于确定字段是否可以序列化以及是否可以反序列化:

*   `serialize`:当`true`时，标有此`@Expose`注释的字段被序列化为 JSON 文本；否则，该字段不会被序列化。默认值为`true`。
*   `deserialize`:当`true`时，标有此`@Expose`注释的字段从 JSON 文本反序列化；否则，该字段不会被反序列化。默认值为`true`。

以下代码片段显示了如何使用`Expose`和这些元素，以便名为`someField`的字段将被序列化而不是反序列化:

```java
@Expose(serialize = true, deserialize = false)
int someField;

```

默认情况下，`Gson`忽略`Expose`。您必须配置`Gson`,通过调用下面的`GsonBuilder`方法来公开/隐藏用`@Expose`注释的字段:

```java
GsonBuilder excludeFieldsWithoutExposeAnnotation()

```

创建一个`GsonBuilder`对象，然后调用`GsonBuilder`的`excludeFieldsWithoutExposeAnnotation()`方法，然后调用该对象的`Gson create()`方法，以返回一个已配置的`Gson`对象:

```java
GsonBuilder gsonb = new GsonBuilder();
gsonb.excludeFieldsWithoutExposeAnnotation();
Gson gson = gsonb.create();

```

清单 [9-8](#Par154) 描述了一个演示`Expose`注释类型的应用程序。

```java
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import com.google.gson.annotations.Expose;

public class GsonDemo
{
   static class SomeClass
   {
      transient int id;
      @Expose(serialize = true, deserialize = true)
      transient String password;
      @Expose(serialize = false, deserialize = false)
      int field1;
      @Expose(serialize = false, deserialize = true)
      int field2;
      @Expose(serialize = true, deserialize = false)
      int field3;
      @Expose(serialize = true, deserialize = true)
      int field4;
      @Expose(serialize = true, deserialize = true)
      static int field5;
      static int field6;
   }

   public static void main(String[] args)
   {
      SomeClass sc = new SomeClass();
      sc.id = 1;
      sc.password = "abc";
      sc.field1 = 2;
      sc.field2 = 3;
      sc.field3 = 4;
      sc.field4 = 5;
      sc.field5 = 6;
      sc.field6 = 7;
      GsonBuilder gsonb = new GsonBuilder();
      gsonb.excludeFieldsWithoutExposeAnnotation();
      Gson gson = gsonb.create();
      String json = gson.toJson(sc);
      System.out.println(json);
      SomeClass sc2 = gson.fromJson(json, SomeClass.class);
      System.out.printf("id = %d%n", sc2.id);
      System.out.printf("password = %s%n", sc2.password);
      System.out.printf("field1 = %d%n", sc2.field1);
      System.out.printf("field2 = %d%n", sc2.field2);
      System.out.printf("field3 = %d%n", sc2.field3);
      System.out.printf("field4 = %d%n", sc2.field4);
      System.out.printf("field5 = %d%n", sc2.field5);
      System.out.printf("field6 = %d%n", sc2.field6);
   }
}

Listing 9-8.Exposing and Hiding Fields to and from Serialization and Deserialization

```

清单 [9-8](#Par154) 展示了带有`transient`实例字段的`Expose`以及非`transient`实例字段和`static`字段。

编译清单 [9-8](#Par154) 并运行生成的应用程序。您应该观察到以下输出:

```java
{"field3":4,"field4":5}
id = 0
password = null
field1 = 0
field2 = 0
field3 = 0

field4 = 5
field5 = 6
field6 = 7

```

第一个输出行显示只有`field3`和`field4`被序列化。其他字段不序列化。

第二行和第三行显示`transient id`和`password`字段接收默认值。`transient`字段未被序列化/反序列化。

第四、第五和第六行显示默认的`0`值被分配给`field1`、`field2`和`field3`。对于`field1`和`field3`，`deserialize`被分配给`false`，因此只能将默认值分配给这些字段。因为`field2`没有序列化，所以唯一可以赋给它的值是`0`。

第七行显示`5`被分配给`field4`。这是有意义的，因为`serialize`和`deserialize`元素被赋予了`true`。

因为`static`字段没有被序列化或反序列化，所以它们保持初始值，如第八和第九行所示(对于`field5`和`field6`)。

Note

即使`Gson`序列化了`static`字段，`field6`也不会被序列化，因为它没有用`@Expose`注释，也因为`gsonb.excludeFieldsWithoutExposeAnnotation()`方法调用，导致`Gson`绕过没有用`@` `Expose`注释的字段。

##### 更改字段名称

当您只想在序列化和反序列化期间更改字段和/或方法名时，您不必使用`JsonSerializer<T>`和`JsonDeserializer<T>`；比如把`isbn10`改成`isbn-10`，把`isbn13`改成`isbn-13`。您可以使用`SerializedName`来代替，如下所示:

```java
@SerializedName("isbn-10")
String isbn10;
@SerializedName("isbn-13")
String isbn13;

```

JSON 对象表示`isbn-10`和`isbn-13`属性名，而 Java 类表示`isbn10`和`isbn13`字段名称。

清单 [9-9](#Par168) 描述了一个演示`SerializedName`注释类型的应用程序。

```java
import com.google.gson.Gson;

import com.google.gson.annotations.SerializedName;

public class GsonDemo
{
   static class Book
   {
      String title;
      @SerializedName("isbn-10")
      String isbn10;
      @SerializedName("isbn-13")
      String isbn13;
   }

   public static void main(String[] args)
   {
      Book book = new Book();
      book.title = "PHP and MySQL Web Development, Second Edition";
      book.isbn10 = "067232525X";
      book.isbn13 = "075-2063325254";
      Gson gson = new Gson();
      String json = gson.toJson(book);
      System.out.println(json);
      Book book2 = gson.fromJson(json, Book.class);
      System.out.printf("title = %s%n", book2.title);
      System.out.printf("isbn10 = %s%n", book2.isbn10);
      System.out.printf("isbn13 = %s%n", book2.isbn13);
   }
}

Listing 9-9.Changing Names

```

编译清单 [9-9](#Par168) 并运行生成的应用程序。您应该观察到以下输出:

```java
{"title":"PHP and MySQL Web Development, Second Edition","isbn-10":"067232525X","isbn-13":"075-2063325254"}
title = PHP and MySQL Web Development, Second Edition
isbn10 = 067232525X
isbn13 = 075-2063325254

```

##### 版本控制

`Since`和`Until`对你的类版本化很有用。使用这些注释类型，您可以确定哪些字段和/或类型被序列化为 JSON 对象。

每个`@Since`和`@Until`注释都接收一个双精度浮点值作为其参数。该值指定版本号，如下所示:

```java
@Since(1.0) private String userID;
@Since(1.0) private String password;
@Until(1.1) private String emailAddress;

```

`@Since(1.0)`表示它注释的字段将被序列化为大于或等于`1.0`的所有版本。类似地，`@Until(1.1)`表示它注释的字段将被序列化为小于`1.1`的所有版本。

与`@Since`或`@Until`版本参数相比较的版本号由下面的`GsonBuilder`方法指定:

```java
GsonBuilder setVersion(double ignoreVersionsAfter)

```

与`Expose`一样，您首先创建一个`GsonBuilder`对象，然后在该对象上用期望的版本号调用该方法，最后在`GsonBuilder`对象上调用`create()`以返回一个新创建的`Gson`对象:

```java
GsonBuilder gsonb = new GsonBuilder();
gsonb.setVersion(2.0);
Gson gson = gsonb.create();

```

清单 [9-10](#Par180) 描述了一个演示`Since`和`Until`注释类型的应用程序。

```java
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import com.google.gson.annotations.Since;
import com.google.gson.annotations.Until;

public class GsonDemo
{
   @Since(1.0)
   @Until(2.5)
   static class SomeClass
   {
      @Since(1.1)
      @Until(1.5)
      int field;
   }

   public static void main(String[] args)
   {
      SomeClass sc = new SomeClass();
      sc.field = 1;
      GsonBuilder gsonb = new GsonBuilder();
      gsonb.setVersion(0.9);
      Gson gson = gsonb.create();
      System.out.printf("%s%n%n", gson.toJson(sc));
      gsonb.setVersion(1.0);
      gson = gsonb.create();
      System.out.printf("%s%n%n", gson.toJson(sc));
      gsonb.setVersion(1.1);
      gson = gsonb.create();
      System.out.printf("%s%n%n", gson.toJson(sc));
      gsonb.setVersion(1.5);
      gson = gsonb.create();
      System.out.printf("%s%n%n", gson.toJson(sc));
      gsonb.setVersion(2.5);
      gson = gsonb.create();
      System.out.printf("%s%n", gson.toJson(sc));
   }
}

Listing 9-10.Versioning a Class and Its Fields

```

清单 [9-10](#Par180) 呈现了一个嵌套的`SomeClass`，只要传递给`setVersion()`的版本号范围从`1.0`到几乎`2.5`，它就会被序列化。这个类提供了一个名为`field`的字段，只要传递给`setVersion()`的版本号范围从`1.1`到几乎`1.5`，这个字段就会被序列化。

编译清单 [9-10](#Par180) 并运行生成的应用程序。您应该观察到以下输出:

```java
null

{}

{"field":1}

{}

Null

```

#### 内容

由`JsonSerializer`和`JsonDeserializer`接口声明的`serialize()`和`deserialize()`方法分别用`com.google.gson.JsonSerializationContext`和`com.google.gson.JsonDeserializationContext`对象调用，作为它们的最终参数。这些对象提供了对特定 Java 对象执行默认序列化和默认反序列化的`serialize()`和`deserialize()`方法。在处理不需要特殊处理的嵌套 Java 对象时，您会发现它们非常方便。

假设您有下面的`Date`和`Employee`类:

```java
class Date
{
   int year;
   int month;
   int day;

   Date(int year, int month, int day)
   {
      this.year = year;
      this.month = month;
      this.day = day;
   }
}

class Employee
{
   String name;
   Date hireDate;
}

```

现在，假设您决定创建一个定制的序列化程序，将`emp-name`和`hire-date`属性(而不是`name`和`hireDate`属性)添加到生成的 JSON 对象中。因为在序列化过程中没有改变`Date`字段的名称或顺序，所以可以利用传递给`JsonSerializer`的`serialize()`方法的上下文来处理序列化的这一部分。

以下代码片段显示了序列化`Employee`对象及其嵌套的`Date`对象的序列化程序:

```java
class EmployeeSerializer implements JsonSerializer<Employee>
{
   @Override
   public JsonElement serialize(Employee emp, Type typeOfSrc,                                 JsonSerializationContext context)
   {
      JsonObject jo = new JsonObject();
      jo.addProperty("emp-name", emp.name);
      jo.add("hire-date", context.serialize(emp.hireDate));
      return jo;
   }
}

```

`serialize()`首先创建一个`JsonObject`来描述序列化的 JSON 对象。然后，它将一个以雇员姓名为值的`emp-name`属性添加到这个`JsonObject`中。因为默认序列化可以序列化`hireDate`字段，`serialize()`调用`context.serialize(emp.hireDate)`生成属性值。这个值和`hire-date`属性名被添加到从方法返回的`JsonObject`中。

清单 [9-11](#Par192) 展示了演示这个`serialize()`方法的应用程序的源代码。

```java
import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class GsonDemo
{

   static class Date
   {
      int year;
      int month;
      int day;

      Date(int year, int month, int day)
      {
         this.year = year;
         this.month = month;
         this.day = day;
      }
   }

   static class Employee
   {
      String name;
      Date hireDate;
   }

   public static void main(String[] args)
   {
      Employee e = new Employee();
      e.name = "John Doe";
      e.hireDate = new Date(1982, 10, 12);
      GsonBuilder gb = new GsonBuilder();
      class EmployeeSerializer implements JsonSerializer<Employee>
      {
         @Override
         public JsonElement serialize(Employee emp, Type typeOfSrc, JsonSerializationContext context)
         {
            JsonObject jo = new JsonObject();
            jo.addProperty("emp-name", emp.name);
            jo.add("hire-date", context.serialize(emp.hireDate));
            return jo;
         }
      }

      gb.registerTypeAdapter(Employee.class, new EmployeeSerializer());
      Gson gson = gb.create();
      System.out.printf("%s%n%n", gson.toJson(e));
   }
}

Listing 9-11.Leveraging a Context to Serialize a Date

```

编译清单 [9-11](#Par192) 并运行生成的应用程序。您应该观察到以下输出:

```java
{"emp-name":"John Doe","hire-date":{"year":1982,"month":10,"day":12}}

```

#### 泛型支持

当您调用[`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang)`toJson(`[`Object`](http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#class%20or%20interface%20in%20java.lang)`src)`或`void toJson(Object src, Appendable writer)`时，`Gson`调用`src.getClass()`来获取`src`的`java.lang.Class`对象，以便它可以反射性地了解要序列化的字段。同样，当您调用一个反序列化方法，如`<T> T fromJson(`[`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang)`json,`[`Class`](http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true#class%20or%20interface%20in%20java.lang)`<T> classOfT)`，`Gson`使用传递给`classOfT`的`Class`对象来帮助它反射性地构建一个结果 Java 对象。对于从非泛型类型实例化的对象，这些操作可以正常工作。但是，当从泛型类型创建对象时，可能会出现问题，因为泛型类型信息会因类型擦除而丢失。考虑下面的代码片段:

```java
List<String> weekdays = Arrays.asList("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
String json = gson.toJson(weekdays);
System.out.printf("%s%n%n", json);
System.out.printf("%s%n%n",
                  gson.fromJson(json, weekdays.getClass()));

```

变量`weekdays`是通用类型`java.util.List<String>`的对象。`toJson()`方法调用`weekdays.getClass()`，并发现`List`作为类型。但是，它仍然成功地将`weekdays`序列化为下面的 JSON 对象:

```java
["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]

```

反序列化不成功。当调用`gson.fromJson(json, weekdays.getClass())`时，这个方法抛出一个`java.lang.ClassCastException`类的实例。在内部，它试图将`java.util.ArrayList`转换为`java.util.Arrays$ArrayList`，但这不起作用。

这个问题的解决方案是指定正确的`List<String>`参数化类型(泛型类型实例),而不是从`weekdays.getClass()`返回的原始`List`类型。为此，您使用了`com.google.gson.reflect.TypeToken<T>`类。

`TypeToken<T>`表示一个通用类型`T`，并在运行时启用类型信息的检索，这是`Gson`所需要的。使用如下表达式实例化`TypeToken`:

```java
Type listType = new TypeToken<List<String>>() {}.getType();

```

这个习惯用法定义了一个匿名的本地内部类，其继承的`getType()`方法将完全参数化的类型作为一个`java.lang.reflect.Type`对象返回。在这段代码中，返回了以下类型:

```java
java.util.List<java.lang.String>

```

将得到的`Type`对象传递给`<T> T fromJson(`[`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang)`json,`[`Type`](http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Type.html?is-external=true#class%20or%20interface%20in%20java.lang.reflect)`typeOfT)`方法，如下:

```java
gson.fromJson(json, listType)

```

这个方法调用解析 JSON 对象并将其作为`List<String>`返回。

您可能希望使用如下表达式输出结果:

```java
System.out.printf("%s%n%n", gson.fromJson(json, listType));

```

但是，您会收到一个抛出的`ClassCastException`,声明您不能将`ArrayList`强制转换为`java.lang.Object[]`,而是观察输出。问题的解决方案是向`List`引入一个强制转换，如下所示:

```java
System.out.printf("%s%n%n", (List) gson.fromJson(json, listType));

```

进行此更改后，您将观察到以下输出:

```java
[Sun, Mon, Tue, Wed, Thu, Fri, Sat]

```

清单 [9-12](#Par192) 展示了一个应用程序的源代码，演示了这个问题以及其他面向泛型的序列化/反序列化问题，以及如何解决它们。

```java
import java.lang.reflect.Type;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

import com.google.gson.Gson;

import com.google.gson.reflect.TypeToken;

import java.util.Arrays;
import java.util.List;

public class GsonDemo
{
   static
   class Vehicle<T>
   {
      T vehicle;

      T get()
      {
         return vehicle;
      }

      void set(T vehicle)
      {
         this.vehicle = vehicle;
      }

      @Override
      public String toString()
      {
         System.out.printf("Class of vehicle: %s%n", vehicle.getClass());
         return "Vehicle: " + vehicle.toString();
      }
   }

   static
   class Truck
   {
      String make;
      String model;

      Truck(String make, String model)
      {
         this.make = make;
         this.model = model;
      }

      @Override
      public String toString()
      {
         return "Make: " + make + " Model: " + model;
      }
   }

   public static void main(String[] args)
   {
      Gson gson = new Gson();

      // ...

      System.out.printf("PART 1%n");
      System.out.printf("------%n%n");

      List<String> weekdays = Arrays.asList("Sun", "Mon", "Tue", "Wed", "Thu

", "Fri", "Sat");
      String json = gson.toJson(weekdays);
      System.out.printf("%s%n%n", json);
      try
      {
         System.out.printf("%s%n%n", gson.fromJson(json, weekdays.getClass()));
      }
      catch (ClassCastException cce)
      {
         cce.printStackTrace();
         System.out.println();
      }
      Type listType = new TypeToken<List<String>>() {}.getType(); System.out.printf("Type = %s%n%n", listType);
      try
      {
         System.out.printf("%s%n%n", gson.fromJson(json, listType));
      }
      catch (ClassCastException cce)
      {
         cce.printStackTrace();
         System.out.println();
      }
      System.out.printf("%s%n%n", (List) gson.fromJson(json, listType));

      // ...

      System.out.printf("PART 2%n");
      System.out.printf("------%n%n");

      Truck truck = new Truck("Ford", "F150");
      Vehicle<Truck> vehicle = new Vehicle<>();
      vehicle.set(truck);

      json = gson.toJson(vehicle);
      System.out.printf("%s%n%n", json);
      System.out.printf("%s%n%n", gson.fromJson(json, vehicle.getClass()));

      // ...

      System.out.printf("PART 3%n");
      System.out.printf("------%n%n");

      Map<String, String> map = new HashMap<String, String>()
      {
         {
            put("key", "value");
         }
      };
      System.out.printf("Map = %s%n%n", map);
      System.out.printf("%s%n%n", gson.toJson(map));
      System.out.printf("%s%n%n", gson.fromJson(gson.toJson(map),
                                                map.getClass()));

      // ...

      System.out.printf("PART 4%n");
      System.out.printf("------%n%n");

      Type vehicleType = new TypeToken<Vehicle<Truck>>() {}.getType();
      json = gson.toJson(vehicle, vehicleType);
      System.out.printf("%s%n%n", json);
      System.out.printf("%s%n%n", (Vehicle) gson.fromJson(json, vehicleType));

      Type mapType = new TypeToken<Map<String,String>>() {}.getType();
      System.out.printf("%s%n%n", gson.toJson(map, mapType));
      System.out.printf("%s%n%n", (Map) gson.fromJson(gson.toJson(map, mapType), mapType));
   }
}

Listing 9-12.Serializing and Deserializing Objects Based on Generic Types

```

清单 [9-12](#Par192) 的`GsonDemo`类被组织成嵌套的`Vehicle`和`Truck static`类，后跟`main()`入口点方法。这种方法分为四个部分，演示问题和解决方案。下面是输出，我将在讨论`main()`时引用它:

```java
PART 1
------

["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]

java.lang.ClassCastException: Cannot cast java.util.ArrayList to java.util.Arrays$ArrayList
        at java.lang.Class.cast(Class.java:3369)
        at com.google.gson.Gson.fromJson(Gson.java:766)
        at GsonDemo.main(GsonDemo.java:75)

Type = java.util.List<java.lang.String>

java.lang.ClassCastException: java.util.ArrayList cannot be cast to [Ljava.lang.Object;
        at GsonDemo.main(GsonDemo.java:86)

[Sun, Mon, Tue, Wed, Thu, Fri, Sat]

PART 2
------

{"vehicle":{"make":"Ford","model":"F150"}}

Class of vehicle: class com.google.gson.internal.LinkedTreeMap
Vehicle: {make=Ford, model=F150}

PART 3
------

Map = {key=value}

null

null

PART 4
------

{"vehicle":{"make":"Ford","model":"F150"}}

Class of vehicle: class GsonDemo$Truck
Vehicle: Make: Ford Model: F150

{"key":"value"}

{key=value}

```

第 1 部分主要关注前面讨论的`List<String>`例子。输出显示通过`toJson()`成功序列化，接着是通过`gson.fromJson(json, weekdays.getClass()`不成功反序列化，接着是存储在第一个创建的`TypeToken`实例中的类型，接着是有强制转换问题的成功反序列化，接着是没有强制转换问题的成功反序列化。

第 2 部分关注名为`vehicle`的`Vehicle<Truck>`对象的序列化和反序列化。这个通用对象通过一个`gson.toJson(vehicle)`调用被成功序列化。虽然您经常可以成功地将通用对象传递给`toJson(Object src)`，但是这个方法偶尔会失败，正如我将要展示的。对`gson.fromJson(json, vehicle.getClass())`的后续调用试图反序列化输出，但是有一个问题:您观察到的是`Vehicle: {make=Ford, model=F150}`而不是`Vehicle: Make: Ford Model: F150`。因为指定了`Vehicle`而不是完整的`Vehicle<Truck>`通用类型，所以`Vehicle`类中的`vehicle`字段被指定为`com.google.gson.internal.LinkedTreeMap`而不是`Truck`作为其类型。

第 3 部分试图基于一个匿名子类`java.util.HashMap`序列化和反序列化一个 map。第一个`null`值显示`toJson()`没有成功:`toJson()`的内部`map.getClass()`调用返回一个`GsonDemo$2`引用，它没有提供对要序列化的对象的洞察。第二个`null`值是通过`fromJson(`[`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang)`json,`[`Class`](http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true#class%20or%20interface%20in%20java.lang)`<T> classOfT)`中的`null`到`json`得到的。

第 4 部分展示了如何修复第 2 部分和第 3 部分中的问题。这个部分创建了`TypeToken<Vehicle<Truck>>`和`TypeToken<Map<String,String>>`对象来存储`Vehicle<Truck>`和`Map<String, String>`参数化类型。这些对象然后被传递给`String toJson(Object src,` [`Type`](http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Type.html?is-external=true#class%20or%20interface%20in%20java.lang.reflect) `typeOfSrc)`和`<T> T fromJson(`[`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang)`json,`[`Type`](http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Type.html?is-external=true#class%20or%20interface%20in%20java.lang.reflect)`typeOfT)`方法的`type`参数。(虽然`gson.toJson(vehicle, vehicleType)`不是必需的，因为序列化与`gson.toJson(vehicle)`一起工作，但是为了安全起见，您应该养成基于`TypeToken`实例传递一个`Type`对象作为第二个参数的习惯。)

Note

当指定对象(`src`和从`classOfT`派生的对象)的任何字段基于通用类型时，`toJson(Object src)`、`<T> T fromJson(String json,`、[、](http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true#class%20or%20interface%20in%20java.lang)、`<T> classOfT)`和类似的方法都能正常工作。唯一的规定是指定的对象不能是类属的。

#### 类型适配器

在本章的前面，我展示了如何使用`JsonSerializer`和`JsonDeserializer`(分别)将 Java 对象序列化为 JSON 字符串，反之亦然。这些接口简化了 Java 对象和 JSON 字符串之间的转换，但是增加了一个处理中间层。

中间层由将 Java 对象和 JSON 字符串转换为`JsonElement`的代码组成。这种转换降低了解析或创建无效 JSON 字符串的风险，但它确实需要时间来执行，这会影响性能。通过使用`com.google.gson.TypeAdapter<T>`类，您可以避开中间层并创建更高效的代码，其中`T`标识 Java 类序列化源和反序列化目标。

Note

你应该更喜欢效率更高的`TypeAdapter`而不是效率更低的`JsonSerializer`和`JsonDeserializer`。事实上，`Gson`使用内部的`TypeAdapter`实现来处理 Java 对象和 JSON 字符串之间的转换。

`TypeAdapter`是一个抽象类，它声明了几个具体的方法以及下面的一对抽象方法:

*   `T` `read(` `JsonReader` `in)`:读取一个 JSON 值(数组、对象、字符串、数字、布尔或`null`)，转换成 Java 对象，返回。返回值可能是`null`。
*   `void write(` `JsonWriter` `out,` `T` `value)`:写一个 JSON 值(数组、对象、字符串、数字、布尔或`null`)，传递给`value`。

当一个 I/O 问题发生时，每个方法抛出`java.io.IOException`。

`read()`和`write()`方法分别读取 JSON 标记序列和写入 JSON 标记序列。对于`read()`，这些令牌的来源是具体的`com.google.gson.stream.JsonReader`类的一个实例。对于`write()`，这些令牌的目的地是具体的`com.google.gson.stream.JsonWriter`类。令牌由`com.google.gson.stream.JsonToken`枚举描述(例如`BEGIN_ARRAY`表示左方括号)。通过调用`JsonReader`和`JsonWriter`方法来读写它们，如下所示:

*   `void beginObject()`:这个`JsonReader`方法使用 JSON 流中的下一个令牌，并断言它是一个新对象的开始。一个伴随的`void endObject()`方法消耗来自 JSON 流的下一个令牌，并断言它是当前对象的结尾。当出现 I/O 问题时，这两种方法都会抛出`IOException`。
*   `JsonWriter name(String name)`:这个`JsonWriter`方法对属性名进行编码，不能是发生 I/O 问题时抛出的`null. IOException`。

创建了一个`TypeAdapter`子类后，通过调用我之前介绍的`GsonBuilder registerTypeAdapter(Type type, Object typeAdapter)`方法，实例化它并向`Gson`注册实例。传递给`type`的对象表示其对象被序列化或反序列化的类。传递给`typeAdapter`的对象是类型适配器实例。

清单 [9-13](#Par235) 展示了演示类型适配器的应用程序的源代码。

```java
import java.io.IOException;

import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.TypeAdapter;

import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

public class GsonDemo
{

   static
   class Country
   {
      String name;
      int population;
      String[] cities;

      Country() {}

      Country(String name, int population, String... cities)
      {
         this.name = name;
         this.population = population;
         this.cities = cities;
      }
   }

   public static void main(String[] args)
   {
      class CountryAdapter extends TypeAdapter<Country>
      {
         @Override
         public Country read(JsonReader in) throws IOException
         {
            Country c = new Country();
            List<String> cities = new ArrayList<>();
            in.beginObject();
            while (in.hasNext())
               switch (in.nextName())
               {
                  case "name":
                     c.name = in.nextString();
                              break;

                  case "population":
                     c.population = in.nextInt();
                     break;

                  case "cities":
                     in.beginArray();
                     while (in.hasNext())
                        cities.add(in.nextString());
                     in.endArray();
                     c.cities = cities.toArray(new String[0]); 

               }
            in.endObject();
            return c;
         }

         @Override
         public void write(JsonWriter out, Country c) throws IOException
         {
            out.beginObject();
            out.name("name").value(c.name);
            out.name("population").value(c.population);
            out.name("cities");
            out.beginArray();
            for (int i = 0; i < c.cities.length; i++)
               out.value(c.cities[i]);
            out.endArray();
            out.endObject();
         }
      }
      Gson gson = new GsonBuilder().
                     registerTypeAdapter(Country.class,                                         new CountryAdapter()).
                     create();

      Country c = new Country("England", 53012456 /* 2011 census */, "London", "Birmingham", "Cambridge");
      String json = gson.toJson(c);
      System.out.println(json);
      c = gson.fromJson(json, c.getClass());
      System.out.printf("Name = %s%n", c.name);
      System.out.printf("Population = %d%n", c.population);
      System.out.print("Cities = ");
      for (String city: c.cities)
         System.out.print(city + " ");
      System.out.println();
   }
}

Listing 9-13.Serializing and Deserializing a Country Object via a Type Adapter

```

清单 [9-13](#Par235) 的`GsonDemo`类嵌套了一个`Country`类(它将一个国家描述为一个名称、一个人口数和一组城市名),并且还提供了一个`main()`入口点方法。

`main()`方法首先声明一个本地`CountryAdapter`类，该类扩展了`TypeAdapter<Country>. CountryAdapter`并覆盖了`read()`和`write()`方法来处理序列化和反序列化任务。

`read()`方法首先创建一个新的`Country`对象，它将存储从被反序列化的 JSON 对象中读取的值(并从`JsonReader`参数中访问)。

在创建一个列表来存储将要读取的城市名数组之后，`read()`调用`beginObject()`来断言从令牌流中读取的下一个令牌是 JSON 对象的开始。

此时，`read()`进入一个`while`循环。当`JsonReader`的`boolean hasNext()`方法返回`true`时，这个循环继续:有另一个对象元素。

每个`while`循环迭代执行一个`switch`语句，调用`JsonReader`的`String nextName()`方法返回下一个令牌，这是 JSON 对象中的一个属性名。然后，它将令牌与三种可能性(`name`、`population`或`cities`)进行比较，并执行相关代码来检索属性值，并将该值分配给之前创建的`Country`对象中的适当字段。

如果属性是`name`，调用`JsonReader`的`String nextString()`方法返回下一个令牌的字符串值。如果属性是 population，`JsonReader`的`int nextInt()`方法被调用来返回令牌的`int`值。

处理`cities`属性更加复杂，因为它的值是一个数组:

`JsonReader`’s `void beginArray()` method is called to signify that a new array has been detected and to consume the open square bracket token.   A `while` loop is entered to repeatedly obtain the next array string value and add it to the previously created `cities` list.   `JsonReader`’s `void endArray()` method is called to signify the end of the current array and to consume the close square bracket token.   The `cities` list is converted to a Java array, which is assigned to the `Country` object’s `cities` member.  

外层`while`循环结束后，`read()`调用`endObject()`断言从令牌流中读取的下一个令牌是当前 JSON 对象的结尾，然后返回`Country`对象。

`write()`方法有点类似于`read()`。它调用`JsonWriter`的`JsonWriter name(String name)`方法将`name`指定的属性名编码成一个 JSON 属性名。同样，它调用`JsonWriter`的`JsonWriter value(long value)`和`JsonWriter value(String value)`方法将`value`编码为一个 JSON 数字或一个 JSON 字符串。

`main()`方法继续从一个`GsonBuilder`对象创建一个`Gson`对象，该对象执行`registerTypeAdapter(Country.class, new CountryAdapter())`来实例化`CountryAdapter`并用将要返回的`Gson`对象进行注册。`Country.class`表示`Country`对象将被序列化和反序列化。

最后，创建一个`Country`对象，将其序列化为一个字符串，然后反序列化为一个新的`Country`对象。

编译清单 [9-13](#Par235) 并运行生成的应用程序。您应该观察到以下输出:

```java
{"name":"England","population":53012456,"cities":["London","Birmingham","Cambridge"]}
Name = England
Population = 53012456
Cities = London Birmingham Cambridge

```

##### 方便地将类型适配器与类和字段相关联

`JsonAdapter`注释类型与`TypeAdapter Class`对象参数一起使用，将`TypeAdapter`实例与类或字段相关联。这样做之后，您就不需要向`Gson`注册`TypeAdapter`，这样会减少一点编码。

清单 [9-14](#Par256) 重构清单 [9-13](#Par235) 来演示`JsonAdapter`。

```java
import java.io.IOException;

import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.TypeAdapter;

import com.google.gson.annotations.JsonAdapter;

import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

public class GsonDemo
{
   @JsonAdapter(CountryAdapter.class)

   static
   class Country
   {
      String name;
      int population;
      String[] cities;

      Country() {}

      Country(String name, int population, String... cities)
      {
         this.name = name;
         this.population = population;
         this.cities = cities;
      }
   }

   static
   class CountryAdapter extends TypeAdapter<Country>
   {
      @Override
      public Country read(JsonReader in) throws IOException
      {
         System.out.println("read() called");
         Country c = new Country();
         List<String> cities = new ArrayList<>();
         in.beginObject();
         while (in.hasNext())
            switch (in.nextName())
            {
               case "name":
                  c.name = in.nextString();
                           break;

               case "population":
                  c.population = in.nextInt();
                  break;

               case "cities":
                  in.beginArray();
                  while (in.hasNext())
                     cities.add(in.nextString());
                  in.endArray();
                  c.cities = cities.toArray(new String[0]);
            }
         in.endObject();
         return c;
      }

      @Override
      public void write(JsonWriter out, Country c) throws IOException
      {

         System.out.println("write() called");
         out.beginObject();
         out.name("name").value(c.name);
         out.name("population").value(c.population);
         out.name("cities");
         out.beginArray();
         for (int i = 0; i < c.cities.length; i++)
            out.value(c.cities[i]);
         out.endArray();
         out.endObject();
      }
   }

   public static void main(String[] args)
   {
      Gson gson = new Gson();

      Country c = new Country("England", 53012456 /* 2011 census */, "London", "Birmingham", "Cambridge");
      String json = gson.toJson(c);
      System.out.println(json);
      c = gson.fromJson(json, c.getClass());
      System.out.printf("Name = %s%n", c.name);
      System.out.printf("Population = %d%n", c.population);
      System.out.print("Cities = ");
      for (String city: c.cities)
         System.out.print(city + " ");
      System.out.println();
   }
}

Listing 9-14.Serializing and Deserializing a Country Object Annotated with a Type Adapter

```

在清单 [9-14](#Par256) 中，我加粗了与清单 [9-13](#Par235) 的两个本质区别:`Country`类型适配器类被标注为`@JsonAdapter(CountryAdapter.class)`，并且指定了`Gson gson = new Gson();`而不是使用`GsonBuilder`对象及其`create()`方法。

编译清单 [9-14](#Par256) 并运行生成的应用程序。您应该观察到以下输出:

```java
write() called
{"name":"England","population":53012456,"cities":["London","Birmingham","Cambridge"]}
read() ca

lled
Name = England
Population = 53012456
Cities = London Birmingham Cambridge

```

`read() called`和`write called()`输出行证明`Gson`使用自定义类型适配器而不是其内部类型适配器。

Exercises

以下练习旨在测试你对第 [9](09.html) 章内容的理解。

Define Gson.   Identify and describe Gson’s packages.   What are the two ways to obtain a `Gson` object?   Identify the types for which `Gson` provides default serialization and deserialization.   How would you enable pretty-printing?   True or false: By default, `Gson` excludes `transient` or `static` fields from consideration for serialization and deserialization.   Once you have a `Gson` object, what methods can you call to convert between JSON and Java objects?   How do you use Gson to customize JSON object parsing?   Describe the `JsonElement` class.   Identify the `JsonElement` subclasses.   What `GsonBuilder` method do you call to register a serializer or deserializer with a `Gson` object?   What method does `JsonSerializer` provide to serialize a Java object to a JSON object?   What annotation types does Gson provide to simplify serialization and deserialization?   True or false: To use `Expose`, it’s enough to annotate a field, as in `@Expose(serialize = true, deserialize = false)`.   What do `JsonSerializationContext` and `JsonDeserializationContext` provide?   True or false: You can call `<T> T fromJson(` [`String`](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true#class%20or%20interface%20in%20java.lang) `json,` [`Class`](http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true#class%20or%20interface%20in%20java.lang) `<T> classOfT)` to deserialize any kind of object.   Why should you prefer `TypeAdapter` to `JsonSerializer` and `JsonDeserializer`?   Modify Listing [9-8](#Par154) so that the `static` field named `field5` is also serialized and deserialized.  

## 摘要

Gson 是一个小型的基于 Java 的库，用于解析和创建 JSON 对象。谷歌为自己的项目开发了 Gson，但后来从 1.0 版本开始，Gson 公开可用。

Gson 通过将 JSON 对象反序列化为 Java 对象来解析 JSON 对象。类似地，它通过将 Java 对象序列化为 JSON 对象来创建 JSON 对象。Gson 依靠 Java 的反射 API 来协助完成这些任务。

Gson 由 30 多个类和接口组成，分布在四个包中:`com.google.gson`(提供对主类`Gson`的访问)；`com.google.gson.annotations`(提供用于 Gson 的注释类型)；`com.google.gson.reflect`(提供用于从泛型类型获取类型信息的实用程序类)；`com.google.gson.stream`(提供用于读写 JSON 编码值的实用程序类)。

`Gson`类处理 JSON 和 Java 对象之间的转换。您可以通过使用`Gson()`构造函数实例化这个类，或者通过使用`GsonBuilder`类获得一个`Gson`实例。

一旦有了一个`Gson`对象，就可以调用各种`fromJson()`和`toJson()`方法在 JSON 和 Java 对象之间进行转换。因为这些方法分别依赖于 Gson 的默认反序列化和序列化机制，所以您可以通过使用`JsonDeserializer<T>`和`JsonSerializer<T>`接口来自定义反序列化和序列化。

Gson 提供了额外的有用特性，包括用于简化序列化和反序列化的注释、用于自动化嵌套对象和数组序列化的上下文、对泛型的支持以及类型适配器。

第 [10 章](10.html)介绍了用于提取 JSON 值的 JsonPath。